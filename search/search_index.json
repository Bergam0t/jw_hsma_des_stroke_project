{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Discrete Event Simulation of a Stroke Unit","text":""},{"location":"#what-impact-do-specialised-stroke-same-day-emergency-care-sdec-units-and-ct-perfusion-scanning-have-on-stroke-patient-flow","title":"What impact do specialised stroke same day emergency care (SDEC) units and CT perfusion scanning have on stroke patient flow?","text":"<p>Welcome to the documentation for this discrete event simulation.</p> <p>This model is designed to help answer questions about the impact of CT perfusion scanner availability and the use of a specialised stroke SDEC on stroke ward capacity, the suitable number of beds, and potential cost-savings from increased use of these approaches.</p> <p></p>"},{"location":"#where-can-i-find-out-more","title":"Where can I find out more?","text":"<p>This documentation contains technical details of the modelling code.</p> <p>For a higher-level overview, you can find details in the Streamlit app.</p> <p>Details of how to run the Streamlit app locally can be found in the repository readme.</p>"},{"location":"CHANGELOG/","title":"v0.2.0","text":"<p>The main focus of this release is adding an interactive web app frontend to the model.</p> <p>Where possible, the fundamental structure of the model code has been left unchanged. Some unavoidable changes to support front end result display, reproducibility, or flexibility of parameter input. Various bugfixes have also been introduced after discussion with the primary contributor. Additional comments and docstrings have also been added for readability, and the code has been linted.</p> <p>However, changes for aesthetic reasons, or where the change would reduce the readability/understandability of the code for contributors with less experience in coding, have been avoided.</p>"},{"location":"CHANGELOG/#new-features","title":"New features","text":""},{"location":"CHANGELOG/#web-app","title":"Web App","text":"<ul> <li>Built first draft of web app in Streamlit <ul> <li>Display key metrics relating to model function (e.g. number of patients generated), and model outputs (e.g. money saved)</li> <li>Allow setting of various parameters, including<ul> <li>Beds available in ward</li> <li>Beds available in SDEC</li> <li>SDEC and CTP operational hours</li> <li>Uplift in arrival rates</li> <li>Therapy support</li> <li>Number of runs</li> <li>Run and warm-up duration</li> <li>Random seed</li> <li>Debug message generation (sent to console)</li> </ul> </li> <li>Added vidigi animation</li> <li>Added vidigi process maps</li> <li>Added ward and SDEC occupancy plots<ul> <li>Added warm-up duration line to ward plot to allow visual assessment of whether warm-up period is appropriate</li> </ul> </li> <li>Added debugging plot for all patient attributes</li> <li>Added about page with process diagram and placeholders for pathway and model FAQs.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#automated-tests","title":"Automated Tests","text":"<ul> <li>Added<ul> <li>backtest (test against a known 'good' set of results)</li> <li>test for the same results being generated when the same paramaters and seed are used</li> <li>test for different results being generated when the same parameters and a different seed are used</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#documentation","title":"Documentation","text":"<ul> <li>Add numpydoc-style docstrings to all core model features</li> <li>Wrote comprehensive README</li> <li>Set up documentation site using mkdocs, mkdocs-material and mkdocstrings<ul> <li>Set up automatic building and publishing of site with GitHub action</li> <li>Added .nojekyll file to ensure GitHub doesn't try to post-process the built site</li> </ul> </li> <li>Built model flow diagram with Mermaid (/docs/diagrams/pathway_diagram.mmd)<ul> <li>This is also available to view in the 'About' page of the Streamlit app</li> </ul> </li> <li>Added first draft of STRESS DES model documentation<ul> <li>This can be viewed as part of the documentation site</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#enhancements","title":"Enhancements","text":""},{"location":"CHANGELOG/#unavailability-times-for-ctp-and-sdec","title":"Unavailability times for CTP and SDEC","text":"<ul> <li>Adjusted how ctp_value and sdec_value are set up and used across the model, making it consistent across the script running and app methods and more consistent with how other variables are managed (i.e. using g class)</li> <li>Allow independent setting of the start hour for CTP and SDEC<ul> <li>Previously, the CTP and SDEC would always have their first period of availability commencing at sim time 0.</li> <li>Sim time 0 has been reconceptualised to be midnight on the first simulated day.</li> <li>Users can now provide separate offsets to separate the start time of CTP and SDEC</li> <li>This also makes conversion of sim time to clock time more intuitive</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#patient-arrivals","title":"Patient Arrivals","text":"<ul> <li>Significantly adjusted how the inter-arrival time parameter is handled in the app to allow for demand adjustment via the web app interface<ul> <li>this more closely matches how inter-arrival time is defined in resources like HSMA's 'the little book of DES'</li> <li>calculations were adjusted so that the average inter-arrival time passed through to the distribution did not change</li> </ul> </li> <li>Allowed setting the start and end times of the arrival time periods<ul> <li>Previously, the start time of the first frequent arrival (daytime) period would be at sim time 0</li> <li>Sim time 0 has been reconceptualised to be midnight on the first simulated day.</li> <li>The start time and duration of the high/low arrival periods can now be set</li> <li>This means that the arrival time periods can be decoupled from the CTP and SDEC availability times if desired</li> </ul> </li> <li>Adjusted sampling to avoid peaks at changeover times</li> <li>Switched to a single patient generator that uses the non-stationary poisson process thinning algorithm.<ul> <li>This avoids arrivals being higher at the start of the changeover to the lower rate period and gradually declining.</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#patient-object","title":"Patient object","text":"<ul> <li>Switched<ul> <li>float and integer defaults from 0 to np.NaN.</li> <li>boolean defaults from False to None (with the exception of 'journey_complete').</li> <li>This all helps to avoid masking subtle bugs arising from attributes not getting set, as well as the possibility of metric calculations being influenced by incorrect 0 values.</li> </ul> </li> <li>Recorded various additional attributes in patient object for easier referencing later</li> <li>Split joint CT/CTP scanning attributes into separate attributes for easier debugging and pathway tracking</li> <li>Added method that tests that all patient attributes that should always have a value set during the course of the model display this behaviour</li> <li>Adjust setting of onset type so that it can vary for patients generated in hours and out-of-hours<ul> <li>set default so that slightly more patients will arrive with an unknown onset time during out-of-hours (which defaults to overnight period from midnight to 7am) than daytime hours<ul> <li>this has had preliminary values set based on https://strokeaudit.org/SupportFiles/Documents/Posters-and-oral-presentations/2020/ESOC-2020-Onset-to-arrival-times_Poster.aspx but will need replacing with more accurate values</li> </ul> </li> <li>may wish to decouple the time boundaries for this from the time boundaries for arrival rate in the future</li> </ul> </li> <li>Created a new attribute for tracking when patients with TIA, stroke-mimic or non-stroke are avoiding admission due to admission % chance check versus when ICH and I patients avoid admission in the 'true' sense (the sense that this model is primarily interested in)</li> </ul>"},{"location":"CHANGELOG/#reproducibility","title":"Reproducibility","text":"<ul> <li>Enhanced controllable randomness and reproducibility<ul> <li>Set up distinct random number streams per generator and activity using sim-tools distributions</li> <li>Set up uncorrelated random number streams using np.seedsequence</li> <li>Allowed user control of 'master' random seed used by np.seedsequence in g class and web frontend</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#animation-and-generated-pathway-diagrams","title":"Animation and generated pathway diagrams","text":"<ul> <li>Switched from simpy resources to equivalent vidigi resources to support the recording of resource IDs in logs</li> <li>Added function to convert produced log into vidigi-style event log (<code>app/convert_event_log.py</code>)</li> </ul>"},{"location":"CHANGELOG/#other","title":"Other","text":"<ul> <li>Added logging of model steps using the sim-tools trace function<ul> <li>Rich logging of individual steps enhances debugging and understanding of the model for those who are less familiar with its structure</li> <li>Clock-time aware logging (i.e. using 'real' time with am/pm, rather than just sim-start relative time) used to make logs easier to interpret</li> </ul> </li> <li>Added patient objects to a list in the model, allowing for easy individual post-hoc querying of all recorded patient attributes</li> <li>Recorded various additional attributes in trial object for easier referencing later</li> </ul>"},{"location":"CHANGELOG/#bugfixes","title":"Bugfixes","text":""},{"location":"CHANGELOG/#sdec","title":"SDEC","text":"<ul> <li>Fixed typo in conditional check where it was accidentally looking at the sdec_value in the case where sdec_value was 100, where instead it should have been checking for ctp_value == 100 in that branch (Click here to view commit, though note it's not showing the original code properly)</li> <li>Swapped SDEC fullness check from &lt;= to &lt; (as previously may have allowed patients in if SDEC at capacity)<ul> <li>note that this has also been added into the original repository (https://github.com/jfwilliams4/des_stroke_project/commit/d68374d3b24ab28609f63eb4eb2019ac0d7faf85)</li> </ul> </li> <li>Remove resource check from SDEC admission code as this was seemingly sometimes causing delayed arrivals (aedd7cd5555424984c63becc2d95ef548974956e) where the patient would enter SDEC during a period where SDEC should be closed</li> </ul>"},{"location":"CHANGELOG/#patient-pathways","title":"Patient Pathways","text":"<ul> <li>Adjust admission avoidance code to ensure that patients never incorrectly jump from CT/CTP scan to discharge when the SDEC is open, and will always spend time in the SDEC at least</li> <li>Generally reviewed patient pathways to check behaviour for each subgroup of patients is correct, based on revised understanding of pathways from conversations with original model builder.<ul> <li>Checked subgroups by<ul> <li>SDEC being open</li> <li>SDEC being full/having capacity</li> <li>CT/CTP scanner availability</li> <li>Patient diagnosis type</li> <li>Admission avoidance flag</li> <li>Thrombolysis</li> </ul> </li> </ul> </li> </ul>"},{"location":"CHANGELOG/#patients","title":"Patients","text":"<ul> <li>Fixed bug in patient diagnosis allocation where a diagnosis between the stroke mimic and non-stroke threshold would not get allocated any diagnosis (Click here to view commit)<ul> <li>note that this has also been added into the original repository (https://github.com/jfwilliams4/des_stroke_project/commit/d68374d3b24ab28609f63eb4eb2019ac0d7faf85)</li> </ul> </li> <li>Ensured ward LOS was recorded in patient object for both thrombolysed and non-thrombolysed patients (Click here to view commit)</li> </ul>"},{"location":"CHANGELOG/#code-admin-and-structure-changes","title":"Code Admin and Structure Changes","text":"<ul> <li>Updated structure of code to package structure to support better long-term development and use of additional documentation tools<ul> <li>Model classes split into separate file to model running code</li> <li>All code moved into src/stroke_ward_model</li> <li>Classes split into separate files as some had become very long after adding docstrings</li> <li>Added pyproject.toml file</li> </ul> </li> <li>Added \"MARK\" comments as markers to enable richer code minimap in core classes.<ul> <li>These will appear if you are using the VSCode minimap</li> </ul> </li> <li>Updated gitignore with wildcards to make matching of additional results files more robust</li> <li>Added a minimal requirements.txt and environment.yml files to replace strongly specified win_environment and mac_environment folders<ul> <li>Added new requirements including streamlit, mkdocs, mkdocs-material, mkdocstrings, vidigi, pytest</li> </ul> </li> <li>Added a separate requirements.txt file for web app<ul> <li>This removes the requirements that are not required for the web app, such as mkdocs and pytest</li> <li>This will be picked up by Streamlit community cloud, and shortens the load time for container reloads</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#v010","title":"v0.1.0","text":"<p>Initial model release.</p>"},{"location":"app/","title":"Try out the Model","text":"<p>The model is hosted on a free hosting platform - Streamlit Community Cloud.</p> <p>You can use this to try out the model without having to run any code locally.</p> <p>Note</p> <p>If you are using the app for decision-making, it is recommended that you run it locally, which will allow for much faster running of multiple scenarios across a higher number of runs or a longer timeframe.</p> <p>Click here for instructions for running the code locally</p> <p>You can take a quick look at the app below. However, for the best experience, we'd recommend you open it in a new window.</p> <p>Click to open the app in a new window</p> <p> </p>"},{"location":"g/","title":"Reference","text":"<p>Global simulation configuration parameters.</p> <p>This class stores all model-wide constants used in the discrete-event simulation, including runtime settings, resource capacities, operational constraints, diagnosis-based length-of-stay (LOS) values, cost parameters, and state flags modified during execution. All attributes are class variables and are intended to be accessed without instantiation.</p> <p>Attributes:</p> Name Type Description <code>sim_duration</code> <code>int</code> <p>Total simulated time in minutes (default: 525600, one year).</p> <code>number_of_runs</code> <code>int</code> <p>Number of simulation replications.</p> <code>warm_up_period</code> <code>float</code> <p>Number of minutes considered warm-up (not included in statistics), defined as one-fifth of the total simulation time.</p> <code>patient_inter_day</code> <code>int</code> <p>Interarrival time (minutes) for daytime patient generation. NOTE that this is not used in entirely the way that you might expect. This may be changed in future. NOTE that this has now been changed to be used directly as an average IAT, but this may change in future. This supersedes the previous note.</p> <code>patient_inter_night</code> <code>int</code> <p>Interarrival time (minutes) for nighttime patient generation. NOTE that this is not used in entirely the way that you might expect. This may be changed in future. NOTE that this has now been changed to be used directly as an average IAT, but this may change in future. This supersedes the previous note.</p> <code>number_of_nurses</code> <code>int</code> <p>Number of nurses available in the system.</p> <code>mean_n_consult_time</code> <code>int</code> <p>Mean consultation time in minutes.</p> <code>mean_n_ct_time</code> <code>int</code> <p>Mean CT processing time in minutes.</p> <code>number_of_ctp</code> <code>int</code> <p>Number of CT processing units available.</p> <code>sdec_beds</code> <code>int</code> <p>Number of SDEC (Same Day Emergency Care) beds.</p> <code>mean_n_sdec_time</code> <code>int</code> <p>Mean SDEC stay duration in minutes.</p> <code>number_of_ward_beds</code> <code>int</code> <p>Number of inpatient ward beds.</p> <code>mean_n_i_ward_time_mrs_0</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (0).</p> <code>mean_n_i_ward_time_mrs_1</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (1).</p> <code>mean_n_i_ward_time_mrs_2</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (2).</p> <code>mean_n_i_ward_time_mrs_3</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (3).</p> <code>mean_n_i_ward_time_mrs_4</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (4).</p> <code>mean_n_i_ward_time_mrs_5</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (5).</p> <code>mean_n_ich_ward_time_mrs_0</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (0).</p> <code>mean_n_ich_ward_time_mrs_1</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (1).</p> <code>mean_n_ich_ward_time_mrs_2</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (2).</p> <code>mean_n_ich_ward_time_mrs_3</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (3).</p> <code>mean_n_ich_ward_time_mrs_4</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (4).</p> <code>mean_n_ich_ward_time_mrs_5</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (5).</p> <code>mean_n_non_stroke_ward_time</code> <code>int</code> <p>LOS (minutes) for non-stroke patients (TODO: CHECK INTERPRETATION).</p> <code>mean_n_tia_ward_time</code> <code>int</code> <p>LOS (minutes) for TIA patients.</p> <code>thrombolysis_los_save</code> <code>float</code> <p>Proportional reduction in LOS for thrombolysed patients. This is used as a multiplier with the sampled length of stay. For example, if a patient has a LOS of 10 days, and the value of <code>thrombolysis_los_save</code> was 0.75, the calculation would be 10 * 0.75, resulting in a LOS of 7.5 days.</p> <code>mean_mrs</code> <code>int</code> <p>Default/mean modified Rankin Scale score used in the model.</p> <code>ich</code> <code>int</code> <p>Percentage likelihood of intracerebral hemorrhage diagnosis (TODO: CHECK INTERPRETATION).</p> <code>i</code> <code>int</code> <p>Percentage likelihood of ischemic stroke diagnosis.</p> <code>tia</code> <code>int</code> <p>Percentage likelihood of TIA diagnosis.</p> <code>stroke_mimic</code> <code>int</code> <p>Percentage likelihood of stroke mimic diagnosis.</p> <code>tia_admission</code> <code>int</code> <p>Percentage chance that a TIA requires admission.</p> <code>stroke_mimic_admission</code> <code>int</code> <p>Percentage chance that a stroke mimic requires admission.</p> <code>sdec_dr_cost_min</code> <code>float</code> <p>Cost per minute for SDEC doctor time.</p> <code>inpatient_bed_cost</code> <code>float</code> <p>Cost of a standard inpatient bed stay, per day.</p> <code>inpatient_bed_cost_thrombolysis</code> <code>float</code> <p>Cost of an inpatient stay following thrombolysis, per day.</p> <code>sdec_unav_time</code> <code>int</code> <p>Operational unavailability duration of SDEC</p> <code>sdec_unav_freq</code> <code>int</code> <p>How often SDEC unavailability duration occurs</p> <code>ctp_unav_time</code> <code>int</code> <p>Operational unavailability duration of CT perfusion scanner</p> <code>ctp_unav_freq</code> <code>int</code> <p>How often CT perfusion unavailability duration occurs</p> <code>sdec_unav</code> <code>bool</code> <p>Indicates whether SDEC is unavailable.</p> <code>ctp_unav</code> <code>bool</code> <p>Indicates whether CT processing is unavailable.</p> <code>write_to_csv</code> <code>bool</code> <p>Whether the simulation should write results to CSV.</p> <code>gen_graph</code> <code>bool</code> <p>Whether visualisation graphs should be generated.</p> <code>therapy_sdec</code> <code>bool</code> <p>Whether therapy is delivered through SDEC.</p> <code>trials_run_counter</code> <code>int</code> <p>Internal counter tracking completed simulation replications.</p> <code>patient_arrival_gen_1</code> <code>bool</code> <p>Flag used by the simulation to control one patient arrival stream.</p> <code>patient_arrival_gen_2</code> <code>bool</code> <p>Flag used by the simulation to control a second patient arrival stream.</p> <code>master_seed</code> <code>int</code> <p>Master random seed used to adjust the underlying seeds used to populate the random number streams. Trials run without changing parameters or the master seed will be consistent.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of ChatGPT 5.1. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/inputs.py</code> <pre><code>class g:\n    \"\"\"\n    Global simulation configuration parameters.\n\n    This class stores all model-wide constants used in the discrete-event\n    simulation, including runtime settings, resource capacities, operational\n    constraints, diagnosis-based length-of-stay (LOS) values, cost parameters,\n    and state flags modified during execution. All attributes are class\n    variables and are intended to be accessed without instantiation.\n\n    Attributes\n    ----------\n    sim_duration : int\n        Total simulated time in minutes (default: 525600, one year).\n    number_of_runs : int\n        Number of simulation replications.\n    warm_up_period : float\n        Number of minutes considered warm-up (not included in statistics),\n        defined as one-fifth of the total simulation time.\n    patient_inter_day : int\n        Interarrival time (minutes) for daytime patient generation.\n        NOTE that this is not used in entirely the way that you might expect.\n        This may be changed in future.\n        NOTE that this has now been changed to be used directly as an average\n        IAT, but this may change in future. This supersedes the previous note.\n    patient_inter_night : int\n        Interarrival time (minutes) for nighttime patient generation.\n        NOTE that this is not used in entirely the way that you might expect.\n        This may be changed in future.\n        NOTE that this has now been changed to be used directly as an average\n        IAT, but this may change in future. This supersedes the previous note.\n    number_of_nurses : int\n        Number of nurses available in the system.\n    mean_n_consult_time : int\n        Mean consultation time in minutes.\n    mean_n_ct_time : int\n        Mean CT processing time in minutes.\n    number_of_ctp : int\n        Number of CT processing units available.\n    sdec_beds : int\n        Number of SDEC (Same Day Emergency Care) beds.\n    mean_n_sdec_time : int\n        Mean SDEC stay duration in minutes.\n    number_of_ward_beds : int\n        Number of inpatient ward beds.\n    mean_n_i_ward_time_mrs_0 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (0).\n    mean_n_i_ward_time_mrs_1 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (1).\n    mean_n_i_ward_time_mrs_2 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (2).\n    mean_n_i_ward_time_mrs_3 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (3).\n    mean_n_i_ward_time_mrs_4 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (4).\n    mean_n_i_ward_time_mrs_5 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (5).\n    mean_n_ich_ward_time_mrs_0 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (0).\n    mean_n_ich_ward_time_mrs_1 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (1).\n    mean_n_ich_ward_time_mrs_2 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (2).\n    mean_n_ich_ward_time_mrs_3 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (3).\n    mean_n_ich_ward_time_mrs_4 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (4).\n    mean_n_ich_ward_time_mrs_5 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (5).\n    mean_n_non_stroke_ward_time : int\n        LOS (minutes) for non-stroke patients (TODO: CHECK INTERPRETATION).\n    mean_n_tia_ward_time : int\n        LOS (minutes) for TIA patients.\n    thrombolysis_los_save : float\n        Proportional reduction in LOS for thrombolysed patients.\n        This is used as a multiplier with the sampled length of stay.\n        For example, if a patient has a LOS of 10 days, and the value of\n        `thrombolysis_los_save` was 0.75, the calculation would be 10 * 0.75,\n        resulting in a LOS of 7.5 days.\n    mean_mrs : int\n        Default/mean modified Rankin Scale score used in the model.\n    ich : int\n        Percentage likelihood of intracerebral hemorrhage diagnosis\n        (TODO: CHECK INTERPRETATION).\n    i : int\n        Percentage likelihood of ischemic stroke diagnosis.\n    tia : int\n        Percentage likelihood of TIA diagnosis.\n    stroke_mimic : int\n        Percentage likelihood of stroke mimic diagnosis.\n    tia_admission : int\n        Percentage chance that a TIA requires admission.\n    stroke_mimic_admission : int\n        Percentage chance that a stroke mimic requires admission.\n    sdec_dr_cost_min : float\n        Cost per minute for SDEC doctor time.\n    inpatient_bed_cost : float\n        Cost of a standard inpatient bed stay, per day.\n    inpatient_bed_cost_thrombolysis : float\n        Cost of an inpatient stay following thrombolysis, per day.\n    sdec_unav_time : int\n        Operational unavailability duration of SDEC\n    sdec_unav_freq : int\n        How often SDEC unavailability duration occurs\n    ctp_unav_time : int\n        Operational unavailability duration of CT perfusion scanner\n    ctp_unav_freq : int\n        How often CT perfusion unavailability duration occurs\n    sdec_unav : bool\n        Indicates whether SDEC is unavailable.\n    ctp_unav : bool\n        Indicates whether CT processing is unavailable.\n    write_to_csv : bool\n        Whether the simulation should write results to CSV.\n    gen_graph : bool\n        Whether visualisation graphs should be generated.\n    therapy_sdec : bool\n        Whether therapy is delivered through SDEC.\n    trials_run_counter : int\n        Internal counter tracking completed simulation replications.\n    patient_arrival_gen_1 : bool\n        Flag used by the simulation to control one patient arrival stream.\n    patient_arrival_gen_2 : bool\n        Flag used by the simulation to control a second patient arrival stream.\n    master_seed : int\n        Master random seed used to adjust the underlying seeds used to populate\n        the random number streams. Trials run without changing parameters or the\n        master seed will be consistent.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid of\n    ChatGPT 5.1.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    # 525600 (Year of Minutes)\n    sim_duration = 525600\n    number_of_runs = 10\n    warm_up_period = sim_duration / 5\n\n    # TODO: SR query: confirm with John in case this was done in this way for\n    # a particular reason, but I've swapped it to a more intuitive use and\n    # something that will allow for setting via the app interface too\n    # patient_inter_day = 5\n    # patient_inter_night = 5\n    patient_inter_day = 200.0\n    patient_inter_night = 666.666666666667\n\n    number_of_nurses = 2\n    number_of_ctp = 1\n    sdec_beds = 5\n    number_of_ward_beds = 1\n\n    mean_n_consult_time = 60\n    mean_n_ct_time = 20\n    mean_n_sdec_time = 240\n\n    # Different variables for ward stay based on diagnosis, thrombolysis and MRS\n    # TODO: SR - how are these determined? Assume historical data?\n    # TODO: SR - what is suspected reason for MRS of 1 having lower LOS than MRS of 0 whether ICH or I?\n\n    mean_n_i_ward_time_mrs_0 = 1440 * 2.88\n    mean_n_i_ward_time_mrs_1 = 1440 * 4.54\n    mean_n_i_ward_time_mrs_2 = 1440 * 7.4\n    mean_n_i_ward_time_mrs_3 = 1440 * 14.14\n    mean_n_i_ward_time_mrs_4 = 1440 * 26.06\n    mean_n_i_ward_time_mrs_5 = 1440 * 29.7\n\n    mean_n_ich_ward_time_mrs_0 = 1440 * 2.62\n    mean_n_ich_ward_time_mrs_1 = 1440 * 7.03\n    mean_n_ich_ward_time_mrs_2 = 1440 * 12.15\n    mean_n_ich_ward_time_mrs_3 = 1440 * 18.91\n    mean_n_ich_ward_time_mrs_4 = 1440 * 32.45\n    mean_n_ich_ward_time_mrs_5 = 1440 * 41.83\n\n    # Set parameters for mild (TIA) and non-stroke stays\n    mean_n_non_stroke_ward_time = 1440 * 3  # 4320\n    mean_n_tia_ward_time = 1440 * 1\n\n    thrombolysis_los_save = 0.75\n\n    sdec_dr_cost_min = 0.50\n    # TODO: SR: John, I assume these are costs per day?\n    # Can we explain where these values are taken from? Is it specific to a\n    # given trust? What year are these values calculated for?\n    inpatient_bed_cost = 876\n    inpatient_bed_cost_thrombolysis = 528.17\n    mean_mrs = 2\n\n    # Diagnosis % range\n    ich = 10\n    i = 60\n    tia = 70\n    stroke_mimic = 80\n\n    # Admission Range (% Chance of Admission) for TIA and Stroke Mimic, non\n    # stroke shares the range with stroke mimic in this model. (This is\n    # reflected in our real data mainly because most non strokes are often\n    # mimics that are not classified under the stroke mimic criteria in our\n    # data collection)\n    tia_admission = 10\n    stroke_mimic_admission = 30\n\n    # Operational hours of SDEC and CTP are set by the user and stored in the\n    # variables below.\n\n    sdec_unav_time = 0\n    sdec_unav_freq = 0\n    ctp_unav_time = 0\n    ctp_unav_freq = 0\n\n    sdec_value = 0\n    ctp_value = 0\n\n    sdec_opening_hour = 0\n    ctp_opening_hour = 0\n\n    in_hours_start = 7\n    ooh_start = 0\n\n    # Setting of relative frequencies of onsets\n\n    in_hours_known_onset = 0.7\n    in_hours_unknown_onset_inside_ctp = 0.15\n    in_hours_unknown_onset_outside_ctp = 0.15\n\n    out_of_hours_known_onset = 0.2\n    out_of_hours_unknown_onset_inside_ctp = 0.4\n    out_of_hours_unknown_onset_outside_ctp = 0.4\n\n    # These values are changed by the model itself\n\n    sdec_unav = False\n    ctp_unav = False\n    write_to_csv = False\n    gen_graph = False\n    therapy_sdec = False\n    trials_run_counter = 1\n    patient_arrival_gen_1 = False\n    patient_arrival_gen_2 = False\n\n    show_trace = False\n    tracked_cases = list(range(1, 1500))\n    trace_config = {\"tracked\": tracked_cases}\n\n    master_seed = 42\n</code></pre>"},{"location":"model/","title":"Reference","text":"<p>A SimPy simulation model representing a stroke patient pathway.</p> <p>This class coordinates the simulation environment, manages clinical resources (nurses, scanners, and beds), and tracks performance metrics throughout the duration of a simulation run.</p> <p>Parameters:</p> Name Type Description Default <code>run_number</code> <code>int</code> <p>The unique identifier for the specific simulation run.</p> required <p>Attributes:</p> Name Type Description <code>env</code> <code>Environment</code> <p>The SimPy environment in which the simulation is executed.</p> <code>patient_counter</code> <code>int</code> <p>A running count of patients who have entered the system, used as a unique ID. This is shared across in-hours and out-of-hours arrivals.</p> <code>nurse</code> <code>VidigiStore</code> <p>A SimPy resource representing stroke nurses available for assessment.</p> <code>ctp_scanner</code> <code>VidigiPriorityStore</code> <p>A priority resource representing CTP scanners.</p> <code>sdec_bed</code> <code>VidigiPriorityStore</code> <p>A priority resource representing Same Day Emergency Care (SDEC) beds.</p> <code>ward_bed</code> <code>VidigiStore</code> <p>A SimPy resource representing standard ward beds.</p> <code>run_number</code> <code>int</code> <p>The identifier for the current simulation iteration.</p> <code>results_df</code> <code>DataFrame</code> <p>A central data repository for patient-level results, including queue times, lengths of stay, and diagnostic statuses.</p> <code>sdec_freeze_counter</code> <code>int</code> <p>Counter tracking the frequency of SDEC capacity freezes.</p> <code>mean_q_time_nurse</code> <code>float</code> <p>The calculated average time patients spent queuing for a nurse.</p> <code>mean_q_time_ward</code> <code>float</code> <p>The calculated average time patients spent queuing for a ward bed.</p> <code>mean_los_ward</code> <code>float</code> <p>The average length of stay for patients admitted to the ward.</p> <code>thrombolysis_savings</code> <code>float</code> <p>Aggregated metric representing the savings or benefits derived from thrombolysis.</p> <code>q_for_assessment</code> <code>list</code> <p>A list tracking patients currently waiting in the assessment queue.</p> <code>nurse_q_graph_df</code> <code>DataFrame</code> <p>Time-series data for monitoring nurse queue lengths over time.</p> <code>sdec_occupancy</code> <code>list</code> <p>Historical record of SDEC bed utilization.</p> <code>admission_avoidance</code> <code>list</code> <p>Historical record of patients who avoided inpatient admission.</p> <code>ward_occupancy</code> <code>list</code> <p>Historical record of ward bed utilization.</p> <code>non_admissions</code> <code>list</code> <p>Record of patients classified as non-admissions.</p> <code>occupancy_graph_df</code> <code>DataFrame</code> <p>Time-series data for monitoring ward occupancy levels.</p> <code>patient_objects</code> <code>list</code> <p>A collection of all <code>Patient</code> class instances created during the simulation.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>class Model:\n    \"\"\"\n    A SimPy simulation model representing a stroke patient pathway.\n\n    This class coordinates the simulation environment, manages clinical\n    resources (nurses, scanners, and beds), and tracks performance metrics\n    throughout the duration of a simulation run.\n\n    Parameters\n    ----------\n    run_number : int\n        The unique identifier for the specific simulation run.\n\n    Attributes\n    ----------\n    env : simpy.core.Environment\n        The SimPy environment in which the simulation is executed.\n    patient_counter : int\n        A running count of patients who have entered the system, used as a\n        unique ID. This is shared across in-hours and out-of-hours arrivals.\n    nurse : vidigi.resources.VidigiStore\n        A SimPy resource representing stroke nurses available for assessment.\n    ctp_scanner : vidigi.resources.VidigiPriorityStore\n        A priority resource representing CTP scanners.\n    sdec_bed : vidigi.resources.VidigiPriorityStore\n        A priority resource representing Same Day Emergency Care (SDEC) beds.\n    ward_bed : vidigi.resources.VidigiStore\n        A SimPy resource representing standard ward beds.\n    run_number : int\n        The identifier for the current simulation iteration.\n    results_df : pd.DataFrame\n        A central data repository for patient-level results, including queue\n        times, lengths of stay, and diagnostic statuses.\n    sdec_freeze_counter : int\n        Counter tracking the frequency of SDEC capacity freezes.\n    mean_q_time_nurse : float\n        The calculated average time patients spent queuing for a nurse.\n    mean_q_time_ward : float\n        The calculated average time patients spent queuing for a ward bed.\n    mean_los_ward : float\n        The average length of stay for patients admitted to the ward.\n    thrombolysis_savings : float\n        Aggregated metric representing the savings or benefits derived from\n        thrombolysis.\n    q_for_assessment : list\n        A list tracking patients currently waiting in the assessment queue.\n    nurse_q_graph_df : pd.DataFrame\n        Time-series data for monitoring nurse queue lengths over time.\n    sdec_occupancy : list\n        Historical record of SDEC bed utilization.\n    admission_avoidance : list\n        Historical record of patients who avoided inpatient admission.\n    ward_occupancy : list\n        Historical record of ward bed utilization.\n    non_admissions : list\n        Record of patients classified as non-admissions.\n    occupancy_graph_df : pd.DataFrame\n        Time-series data for monitoring ward occupancy levels.\n    patient_objects : list\n        A collection of all `Patient` class instances created during the\n        simulation.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    initialise_distributions = initialise_distributions\n\n    # Constructor to set up the model for a run. We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment\n        self.env = simpy.Environment()\n\n        # Create a patient counter for the first patient Generator\n        self.patient_counter = 0\n\n        # Create a SimPy resources to represent stroke nurses, ctp scanners,\n        # sdec beds, and ward beds. Set in class g\n\n        # SR: I have replaced these with the Vidigi equivalents, which are\n        # functionally identical apart from also allowing the resource ID to be\n        # tracked, which is useful for animation\n        # self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n        self.nurse = Resource(self.env, num_resources=g.number_of_nurses)\n\n        # self.ctp_scanner = simpy.PriorityResource(self.env, capacity=g.number_of_ctp)\n        self.ctp_scanner = PriorityResource(self.env, num_resources=g.number_of_ctp)\n\n        # self.sdec_bed = simpy.PriorityResource(self.env, capacity=g.sdec_beds)\n        self.sdec_bed = PriorityResource(self.env, num_resources=g.sdec_beds)\n\n        # self.ward_bed = simpy.Resource(self.env, capacity=g.number_of_ward_beds)\n        self.ward_bed = Resource(self.env, num_resources=g.number_of_ward_beds)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a Pandas DataFrame that will store a majority of the results\n        # with the patient ID as the index.\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Ward\"] = [0.0]\n        self.results_df[\"Ward LOS\"] = [0.0]\n        self.results_df[\"Time with CTP\"] = [0.0]\n        self.results_df[\"Time with CT\"] = [0.0]\n        self.results_df[\"Time in SDEC\"] = [0.0]\n        self.results_df[\"CTP Status\"] = [\"\"]\n        self.results_df[\"SDEC Status\"] = [\"\"]\n        self.results_df[\"Thrombolysis\"] = [\"\"]\n        self.results_df[\"SDEC Occupancy\"] = [0.0]\n        self.results_df[\"Admission Avoidance\"] = [\"\"]\n        self.results_df[\"SDEC Savings\"] = [0.0]\n        self.results_df[\"MRS Type\"] = [0.0]\n        self.results_df[\"MRS DC\"] = [0.0]\n        self.results_df[\"MRS Change\"] = [0.0]\n        self.results_df[\"Onset Type\"] = [0.0]\n        self.results_df[\"Diagnosis Type\"] = [\"\"]\n        self.results_df[\"Thrombolysis Savings\"] = [0.0]\n        self.results_df[\"Ward Occupancy\"] = [0.0]\n        self.results_df[\"Arrival Time\"] = [0.0]\n        self.results_df[\"Patient Gen 1 Status\"] = [\"\"]\n        self.results_df[\"Patient Gen 2 Status\"] = [\"\"]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # A variable to count the number of SDEC freezes\n        self.sdec_freeze_counter = 0\n\n        # Create a variable to store the mean queuing time for the nurse\n        self.mean_q_time_nurse = 0\n\n        # Create a variable to store the mean queuing time for the nurse\n        self.max_q_time_nurse = 0\n\n        # Create a variable to store the mean time waiting for a ward bed\n        self.mean_q_time_ward = 0\n\n        # Create a variable to store the max time waiting for a ward bed\n        self.max_q_time_ward = 0\n\n        # Create a variable to store the mean length of stay in the ward\n        self.mean_los_ward = 0\n\n        # Create a variable to store the mean number of thrombolysis savings\n        self.thrombolysis_savings = 0\n\n        # set up a list to store the queue for stroke nurse assessment\n        self.q_for_assessment = []\n\n        # a PD dataframe for the assessment queue graph\n        self.nurse_q_graph_df = pd.DataFrame()\n        self.nurse_q_graph_df[\"Time\"] = [0.0]\n        self.nurse_q_graph_df[\"Patients in Assessment Queue\"] = [0.0]\n\n        # a list that will store the number of patients in the SDEC\n        self.sdec_occupancy = []\n\n        # A list that will store the number of admissions avoided\n        self.admission_avoidance = []\n\n        # A list that will store the number of patients in the ward\n        self.ward_occupancy = []\n\n        # A list to store the number of patients avoiding admission\n        self.non_admissions = []\n\n        self.ward_occupancy_graph_df = pd.DataFrame()\n        self.ward_occupancy_graph_df[\"Time\"] = [0.0]\n        self.ward_occupancy_graph_df[\"Occupancy\"] = [0.0]\n        self.ward_occupancy_graph_df[\"During Warm-Up\"] = True\n\n        self.sdec_occupancy_graph_df = pd.DataFrame()\n        self.sdec_occupancy_graph_df[\"Time\"] = [0.0]\n        self.sdec_occupancy_graph_df[\"Occupancy\"] = [0.0]\n        self.sdec_occupancy_graph_df[\"During Warm-Up\"] = True\n\n        # A list to store the patient objects\n        self.patient_objects = []\n\n        # Add counts for each type of stroke patient to cross-check with this\n        # in other places\n        self.i_patients_count = 0\n        self.ich_patients_count = 0\n        self.tia_patients_count = 0\n        self.stroke_mimic_patient_count = 0\n        self.non_stroke_patient_count = 0\n\n        # Add a count of patients who were able to be thrombolysed due to the\n        # use of the CT perfusion scanner but otherwise would not have been\n        # able to be thrombolysed\n        self.additional_thrombolysis_from_ctp = 0\n\n        self.initialise_distributions()\n\n    def is_in_hours(self, time_of_day):\n        start = g.in_hours_start * 60\n        end = g.ooh_start * 60\n\n        if start &lt; end:\n            # Normal case (does not cross midnight)\n            return start &lt;= time_of_day &lt; end\n        else:\n            # Wraps over midnight\n            return time_of_day &gt;= start or time_of_day &lt; end\n\n    def is_out_of_hours(self, time_of_day):\n        return not self.is_in_hours(time_of_day)\n\n    # MARK: M: in-hours arrivals\n    # A generator function for the patient arrivals in hours.\n    def generator_patient_arrivals(self):\n        \"\"\"\n        A SimPy process generator that handles \"in-hours\" patient arrivals.\n\n        This function runs as a continuous loop. It checks if the current\n        simulation time is within daytime operating hours (0-960 minutes\n        relative to the start of a 1440-minute day).\n\n        If in-hours, it:\n\n        1. Updates global arrival flags.\n\n        2. Instantiates a new Patient object.\n\n        3. Records trace information.\n\n        4. Triggers the `stroke_assessment` process for the patient.\n\n        5. Samples an inter-arrival time and yields a timeout.\n\n        If out-of-hours, it yields a small timeout before checking again.\n\n        Arrival rates are determined by `random.expovariate` using the\n        `g.patient_inter_day` parameter. NOTE that this does not use the\n        `g.patient_inter_day` parameter directly, and instead uses it\n        alongside a rate modifier - careful inspection of the code to\n        understand the impacts of changing `g.patient_inter_day` is\n        recommended, and this may be adjusted in a future version of the model.\n\n        Patients generated here have their `arrived_ooh` attribute set to False.\n\n        This process triggers the `stroke_assessment` process for every\n        newly created patient.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        while True:\n            sampled_inter = self.patient_inter_dist.sample(simulation_time=self.env.now)\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time has elapsed.\n            yield self.env.timeout(sampled_inter)\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u23f2\ufe0f Next patient arriving in {sampled_inter:.1f} minutes\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n\n            # Increment the patient counter by 1 for each new patient\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above. patient counter ID passed from above to patient\n            # class.\n            p = Patient(self.patient_counter)\n            self.patient_objects.append(p)\n            if self.env.now &lt; g.warm_up_period:\n                p.generated_during_warm_up = True\n            else:\n                p.generated_during_warm_up = False\n\n            time_of_day = self.env.now % 1440\n\n            if self.is_in_hours(time_of_day):\n                # Change the Global Class variable\n                g.patient_arrival_gen_1 = True\n                g.patient_arrival_gen_2 = False\n\n                p.onset_type = self.onset_type_distribution_in_hours.sample()\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u2600\ufe0f IN-HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                    identifier=p.id,\n                    config=g.trace_config,\n                )\n\n                p.arrived_ooh = False\n\n            elif self.is_out_of_hours(time_of_day):\n                # Change the Global Class variable\n                g.patient_arrival_gen_1 = False\n                g.patient_arrival_gen_2 = True\n\n                p.onset_type = self.onset_type_distribution_out_of_hours.sample()\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83c\udf19 OUT OF HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                    identifier=p.id,\n                    config=g.trace_config,\n                )\n\n                p.arrived_ooh = True\n\n            # Tell SimPy to start the stroke assessment function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.stroke_assessment(p))\n\n    # MARK: M: Obstruct CTP\n    def obstruct_ctp(self):\n        \"\"\"\n        Simulates periodic CTP scanner unavailability (off time).\n\n        This process acts as a \"blocker\" by requesting the CTP scanner resource\n        with a priority of -1. Since patients typically have a priority of 1,\n        this process effectively preempts the queue, preventing patients from\n        using the scanners during this period.\n\n        The scanner will not stop a scan that is already in progress;\n        it waits for the current user to finish before taking the\n        resource offline.\n\n        Frequencies and durations are governed by `g.ctp_unav_freq`\n        and `g.ctp_unav_time`.\n\n        Yields\n        ------\n        simpy.events.Timeout\n            Initial offset for opening hours and subsequent intervals\n            between downtime events.\n        simpy.events.ResourceRequest\n            A high-priority request to seize the CTP scanner and take\n            it \"offline.\"\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n\n        \"\"\"\n        # SR: Add initial offset\n        # SR: Patient generators have also been updated\n        # to match with how this is working\n        yield self.env.timeout(g.ctp_opening_hour * 60)\n\n        while True:\n            yield self.env.timeout(g.ctp_unav_freq)\n            # Once elapsed, this generator requests the ctp scanner with\n            # a priority of -1. As the patient priority is set at 1\n            # the scanner will take priority over any patients waiting.\n            # This method also means that the scanner won't stop mid scan.\n            g.ctp_unav = True\n            with self.ctp_scanner.request(priority=-1) as req:\n                yield req\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83d\udd2c CTP scanner OFFLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                    identifier=self.patient_counter,\n                    config=g.trace_config,\n                )\n                # Freeze with the scanners held in place for the unavailability\n                # time, in the model this means patients admitted in this time\n                # will not have a ctp scan.\n                # freq and unav times are set in the g class\n                yield self.env.timeout(g.ctp_unav_time)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83d\udd2c CTP scanner back ONLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                    identifier=self.patient_counter,\n                    config=g.trace_config,\n                )\n                g.ctp_unav = False\n\n    # MARK: M: Obstruct SDEC\n    def obstruct_sdec(self):\n        \"\"\"\n        Simulates the scheduled closure or unavailability of the SDEC unit.\n\n        Similar to the CTP obstruction, this process seizes an SDEC bed\n        at a high priority (-1) for a defined duration. This models the\n        real-world scenario where the SDEC unit closes at night or\n        during specific hours, forcing patients to bypass this pathway.\n\n        If a closure occurs after the simulation warm-up period, the\n        `sdec_freeze_counter` is incremented.\n\n        Patients arriving while the SDEC is \"obstructed\" will be\n        unable to access SDEC resources.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # SR: Add initial offset\n        # SR: Patient generators have also been updated\n        # to match with how this is working\n        yield self.env.timeout(g.sdec_opening_hour * 60)\n\n        while True:\n            yield self.env.timeout(g.sdec_unav_freq)\n            g.sdec_unav = True\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udfe5 SDEC CLOSES at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy at closure: {len(self.sdec_occupancy)} of {g.sdec_beds} beds.\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n\n            # Freeze with the SDEC held in place for the unavailability\n            # time, in the model this means patients admitted in this time\n            # will not have passed through the SDEC.\n            # freq and unav times are set in the g class\n            yield self.env.timeout(g.sdec_unav_time)\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udfe5 SDEC OPENS at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy at opening: {len(self.sdec_occupancy)} of {g.sdec_beds} beds.\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n\n            g.sdec_unav = False\n\n            if self.env.now &gt; g.warm_up_period:\n                self.sdec_freeze_counter += 1\n\n    def set_patient_attributes(self, patient):\n        \"\"\"\n        Sets a series of randomised per-patient attributes\n\n        Parameters\n        ----------\n        patient : Instance of class `Patient`\n            One single unique patient object.\n        \"\"\"\n        # For now, no-one gets thrombectomy\n        patient.thrombectomy = False\n\n        # Populate various patient attributes\n        # patient.mrs_type = min(round(random.expovariate(1.0 / g.mean_mrs)), 5)\n        patient.mrs_type = min(round(self.mrs_type_distribution.sample()), 5)\n        # patient.diagnosis = random.randint(0, 100)\n        patient.diagnosis = self.diagnosis_distribution.sample()\n        # patient.non_admission = random.randint(0, 100)\n        patient.non_admission = self.non_admission_distribution.sample()\n\n        # Define threshold for admission for TIA + stroke mimic patients\n        self.tia_admission_chance = self.tia_admission_chance_distribution.sample()\n\n        self.stroke_mimic_admission_chance = (\n            self.stroke_mimic_admission_chance_distribution.sample()\n        )\n\n        # This code introduces a slight element of randomness into the patient's\n        # diagnosis.\n\n        # self.ich_range = random.normalvariate(g.ich, 1)\n        self.ich_range = self.ich_range_distribution.sample()\n        # self.i_range = max(random.normalvariate(g.i, 1), self.ich_range)\n        self.i_range = max(self.i_range_distribution.sample(), self.ich_range)\n        # self.tia_range = max(random.normalvariate(g.tia, 1), self.i_range)\n        self.tia_range = max(self.tia_range_distribution.sample(), self.i_range)\n        # self.stroke_mimic_range = max(\n        #     random.normalvariate(g.stroke_mimic, 1), self.tia_range\n        # )\n        self.stroke_mimic_range = max(\n            self.stroke_mimic_range_distribution.sample(), self.tia_range\n        )\n        # self.non_stroke_range = max(\n        #     random.normalvariate(g.stroke_mimic, 1), self.stroke_mimic_range\n        # )\n        self.non_stroke_range = max(\n            self.non_stroke_range_distribution.sample(), self.stroke_mimic_range\n        )\n\n        if patient.diagnosis &lt;= self.ich_range:\n            patient.patient_diagnosis = 0\n            patient.patient_diagnosis_type = \"ICH\"\n            self.ich_patients_count += 1\n        elif patient.diagnosis &lt;= self.i_range:\n            patient.patient_diagnosis = 1\n            patient.patient_diagnosis_type = \"I\"\n            self.i_patients_count += 1\n        elif patient.diagnosis &lt;= self.tia_range:\n            patient.patient_diagnosis = 2\n            patient.patient_diagnosis_type = \"TIA\"\n            self.tia_patients_count += 1\n        elif patient.diagnosis &lt;= self.stroke_mimic_range:\n            patient.patient_diagnosis = 3\n            patient.patient_diagnosis_type = \"Stroke Mimic\"\n            self.stroke_mimic_patient_count += 1\n        # SR - this was changed from an elif as was resulting in patients in\n        # between the two thresholds not getting allocated a diagnosis, which\n        # causes errors elsewhere\n        else:\n            patient.patient_diagnosis = 4\n            patient.patient_diagnosis_type = \"Non Stroke\"\n            self.non_stroke_patient_count += 1\n\n        # The below code records the patients diagnosis attribute, this is\n        # added to the DF to check the diagnosis code is working correctly.\n        # SR - refactored recording of diagnosis type in results df as that's\n        # now recorded as a patient attribute earlier\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Diagnosis Type\"] = (\n                patient.patient_diagnosis_type\n            )\n\n            self.results_df.at[patient.id, \"Onset Type\"] = patient.onset_type\n\n            # This code adds the Patient's MRS to the DF, this can be used to\n            # check all code that interacts with this runs correctly.\n            self.results_df.at[patient.id, \"MRS Type\"] = patient.mrs_type\n\n    # MARK: M: Stroke assessment\n    # A generator function that represents the pathway for a patient going\n    # through the stroke assessment process.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def stroke_assessment(self, patient):\n        \"\"\"\n        Simulates the full assessment and treatment pathway for patients\n        in a stroke pathway.\n\n        Parameters\n        ----------\n        patient : Instance of class `Patient`\n            One single unique patient object.\n        \"\"\"\n        self.set_patient_attributes(patient)\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"Patient {patient.id} Patient Diagnosis (category 1-4): {patient.patient_diagnosis}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n        patient.nurse_q_start_time = self.env.now\n\n        self.q_for_assessment.append(patient)\n\n        # Add the arrival time to the main DF\n        # This is partly to test if the\n        # patient arrival times mirror the real world data\n        # SR: this is also now used for animation generation\n\n        patient.clock_start = self.env.now\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Arrival Time\"] = patient.clock_start\n\n            self.results_df.at[patient.id, \"Patient Gen 1 Status\"] = (\n                g.patient_arrival_gen_1\n            )\n\n            self.results_df.at[patient.id, \"Patient Gen 2 Status\"] = (\n                g.patient_arrival_gen_2\n            )\n\n        #######################################################################\n        # MARK: Nurse triage\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        ########################################################################\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            nurse_attending = yield req\n            # SR - have added recording of the resource ID that's possible as\n            # it's now using vidigi resources\n            patient.nurse_attending_id = nurse_attending.id_attribute\n            patient.nurse_triage_start_time = self.env.now\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udc69\u200d\u2695\ufe0f Patient {patient.id} is being seen by a nurse at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            # Control is passed back to the generator function once the request\n            # is met for a nurse. As the queue for the nurse is finished\n            # the patient then leaves the assessment queue list.\n\n            end_q_nurse = self.env.now\n\n            self.q_for_assessment.remove(patient)\n\n            # The code below checks if the warm up period has passed before\n            # entering data into the df, this code exists when ever data is\n            # recorded\n\n            if self.env.now &gt; g.warm_up_period:\n                self.nurse_q_graph_df.loc[len(self.nurse_q_graph_df)] = [\n                    self.env.now,\n                    len(self.q_for_assessment),\n                ]\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # The below code creates a random action time for the nurse based\n            # on the mean in g class, and assigns it ot a variable. Currently\n            # using a Exponential distribution but might need to switch to\n            # a Log normal one (though the intense variation in the real life\n            # consult time might mean a exponetial distribution is better)\n            # sampled_nurse_act_time = random.expovariate(1.0 / g.mean_n_consult_time)\n            sampled_nurse_act_time = self.nurse_consult_time_dist.sample()\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            patient.nurse_triage_end_time = self.env.now\n\n            # In the .at function below, the first value is the row, the second\n            # value is the column in which to add data. The final value is the\n            # the data that is to be added to the DF, in this case the Nurse\n            # Q time\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = patient.q_time_nurse\n                self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                    sampled_nurse_act_time\n                )\n\n        # TIME WITH NURSE ENDS - NURSE RESOURCE RELEASED HERE FOR NEXT PATIENT\n\n        # MARK: CT and CT Perfusion Scanner Use\n        # The if formula below checks to see if the CTP scanner is active\n        # and if it is the following code is followed including updating the\n        # patient advanced CT pathway attribute\n\n        if g.ctp_unav == False:\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u27a1\ufe0f Patient {patient.id} sent on CTP scanner pathway at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            patient.ctp_scan_start_time = self.env.now\n\n            patient.advanced_ct_pathway = True\n\n            # Randomly sample the mean ct time, as with above this may need to\n            # be updated to a log normal distribution\n\n            # sampled_ctp_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n            sampled_ctp_act_time = self.ct_time_dist.sample()\n            patient.ctp_duration = sampled_ctp_act_time\n            # Freeze this function in place for the activity time that was\n            # sampled above.\n            yield self.env.timeout(sampled_ctp_act_time)\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u27a1\ufe0f Patient {patient.id} finishes CTP scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ctp_act_time:.1f} minutes.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            patient.ctp_scan_end_time = self.env.now\n\n            # Add data to the DF afer the warm up period.\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Time with CTP\"] = sampled_ctp_act_time\n\n        # If the CTP pathway is not active the below code runs, it is the same\n        # as the above however adds data to a different column and the patient\n        # advanced CT pathway remains False.\n\n        else:\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udeab Patient {patient.id} NOT sent on CTP scanner pathway - normal CT scan commencing at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            patient.advanced_ct_pathway = False\n\n            patient.ct_scan_start_time = self.env.now\n\n            # sampled_ct_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n            sampled_ct_act_time = self.ct_time_dist.sample()\n            patient.ct_duration = sampled_ct_act_time\n\n            yield self.env.timeout(sampled_ct_act_time)\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udeab Patient {patient.id} finishes normal CT scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ct_act_time:.1f} minutes.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            patient.ct_scan_end_time = self.env.now\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Time with CT\"] = sampled_ct_act_time\n\n        # The below code records the status of both the CTP pathway.\n        # Both exist as generators and this data is record to ensure they are\n        # operating as expected.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"CTP Status\"] = g.ctp_unav\n\n        #############################\n        # MARK: Thrombolysis\n        #############################\n        # The below code checks the patient's attributes to see if the\n        # thrombolysis attribute should be changed to True, this is based off\n        # the patient diagnosis, onset type and mrs type. There are different\n        # conditions depending on if CTP is available or not.\n\n        if (\n            patient.patient_diagnosis == 1\n            and patient.onset_type == 0\n            and patient.mrs_type &gt; 0\n        ):\n            patient.thrombolysis = True\n\n        elif (\n            patient.patient_diagnosis == 1\n            and patient.onset_type == 1\n            and patient.advanced_ct_pathway == True\n            and patient.mrs_type &gt; 0\n        ):\n            patient.thrombolysis = True\n            self.additional_thrombolysis_from_ctp += 1\n\n        else:\n            patient.thrombolysis = False\n\n        # Thrombolysis status is added to the DF, this is mainly used to check\n        # if it is being applied correctly.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Thrombolysis\"] = patient.thrombolysis\n\n        #########################\n        # MARK: SDEC Admission\n        #########################\n\n        # The below code records the status of both the SDEC pathway.\n        # Both exist as generators and this data is recorded to ensure they are\n        # operating as expected.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"SDEC Status\"] = g.sdec_unav\n\n        # The if statement below checks if the SDEC pathway is active at this\n        # given time and if there is space in the SDEC itself.\n\n        if g.sdec_unav:\n            patient.sdec_running_when_required = False\n            patient.sdec_full_when_required = False\n        else:\n            patient.sdec_running_when_required = True\n\n            if len(self.sdec_occupancy) &lt; g.sdec_beds:\n                patient.sdec_full_when_required = False\n            else:\n                patient.sdec_full_when_required = True\n\n        # Branch for if SDEC is available\n        # SR: Note that I have changed the check from &lt;= to &lt; (so that patients\n        # are only allowed to request a bed when a bed is free)\n        if g.sdec_unav == False and len(self.sdec_occupancy) &lt; g.sdec_beds:\n            # If the conditions above are met the patient attribute for the\n            # SDEC are changed to True and the patient is added to the SDEC\n            # occupancy list.\n\n            # SR: The request is only necessary here for being able to\n            # determine which bed ends up being used, which we require for\n            # animating it correctly. However, we still need to hold it for the\n            # duration of this code block so that someone else doesn't end up\n            # in the same bed!\n            with self.sdec_bed.request() as req:\n                sdec_bed_used = yield req\n                patient.sdec_bed_id = sdec_bed_used.id_attribute\n\n                patient.sdec_admit_time = self.env.now\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83d\udecf\ufe0f\ud83c\udfce\ufe0f Patient {patient.id} admitted to SDEC (occupancy before admission: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds) at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n                self.sdec_occupancy.append(patient)\n\n                # The below code record the SDEC Occupancy as the patient passes\n                # this point to ensure it is working as expected.\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"SDEC Occupancy\"] = len(\n                        self.sdec_occupancy\n                    )\n\n                    self.sdec_occupancy_graph_df.loc[\n                        len(self.sdec_occupancy_graph_df)\n                    ] = [\n                        self.env.now,\n                        len(self.sdec_occupancy),\n                        False,\n                    ]\n                else:\n                    self.sdec_occupancy_graph_df.loc[\n                        len(self.sdec_occupancy_graph_df)\n                    ] = [\n                        self.env.now,\n                        len(self.sdec_occupancy),\n                        True,\n                    ]\n\n                patient.sdec_pathway = True\n\n                ###########################################################\n                # ADMISSION AVOIDANCE\n                # This code checks if the patient is eligible for admission\n                # avoidance depending on if therapy support is enabled.\n                ###########################################################\n                if g.therapy_sdec == False:\n                    if (\n                        patient.patient_diagnosis &lt; 2\n                        and patient.mrs_type &lt; 2\n                        and patient.thrombolysis == False\n                    ):\n                        patient.admission_avoidance = True\n\n                elif g.therapy_sdec == True:\n                    if (\n                        patient.patient_diagnosis &lt; 2\n                        and patient.mrs_type &lt;= 3\n                        and patient.thrombolysis == False\n                    ):\n                        patient.admission_avoidance = True\n                else:\n                    patient.admission_avoidance = False\n\n                ##########################################################\n                # Non-admission - non-stroke, TIA and stroke mimic       #\n                ##########################################################\n                # For patients who have TIA, non-stroke or stroke mimic,\n                # they have a high chance of avoiding admission, but this\n                # is not counted in the same way\n\n                if (\n                    patient.non_admission &gt;= self.tia_admission_chance\n                    and patient.patient_diagnosis == 2\n                ):\n                    patient.admission_avoidance = False\n                    patient.non_admitted_tia_ns_sm = True\n\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\u21a9\ufe0f TIA Patient {patient.id} avoided admission.\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n\n                elif (\n                    patient.non_admission &gt;= self.stroke_mimic_admission_chance\n                    and patient.patient_diagnosis &gt; 2\n                ):\n                    patient.admission_avoidance = False\n                    patient.non_admitted_tia_ns_sm = True\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\u21a9\ufe0f Stroke mimic or non-stroke Patient {patient.id} (diagnosis {patient.diagnosis}) avoided admission.\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                else:\n                    patient.non_admitted_tia_ns_sm = False\n\n                # Calculate SDEC stay time from exponential\n                # sampled_sdec_stay_time = random.expovariate(1.0 / g.mean_n_sdec_time)\n                sampled_sdec_stay_time = self.sdec_time_dist.sample()\n\n                # Add patient SDEC LOS to their patient object\n                patient.sdec_los = sampled_sdec_stay_time\n\n                # Freeze this function in place for the activity time we sampled\n                # above.\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in SDEC for {sampled_sdec_stay_time:.1f} minutes ({(sampled_sdec_stay_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n                yield self.env.timeout(sampled_sdec_stay_time)\n\n                # This code checks if the ward is full, if this is the case the\n                # patient will not be released from the SDEC, thus impeding it use\n\n                if (\n                    not patient.admission_avoidance\n                    and not patient.non_admitted_tia_ns_sm\n                ):\n                    while len(self.ward_occupancy) &gt;= g.number_of_ward_beds:\n                        yield self.env.timeout(1)\n\n                # Once the above code is complete the patient is removed from the\n                # SDEC occupancy list.\n\n                self.sdec_occupancy.remove(patient)\n                patient.sdec_discharge_time = self.env.now\n\n                # Code to record the SDEC stay time in the results DataFrame.\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Time in SDEC\"] = (\n                        sampled_sdec_stay_time\n                    )\n\n                # MARK: Discharged from SDEC\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83c\udfce\ufe0f Patient {patient.id} discharged from SDEC at {minutes_to_ampm(int(self.env.now % 1440))} after {patient.sdec_los:.1f} minutes ({(patient.sdec_los / 60 / 24):.1f} days). Occupancy after discharge: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n            ##########################################\n            # MARK: Admission Avoidance cost savings\n            ##########################################\n            # This code add information regarding the patients admission avoidance.\n\n            if patient.admission_avoidance == True and patient.patient_diagnosis &lt; 2:\n                # Update savings value in model results\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Admission Avoidance\"] = (\n                        patient.sdec_pathway\n                    )\n\n                    last_index = self.results_df[\"SDEC Savings\"].last_valid_index()\n                    last_value = self.results_df.loc[last_index, \"SDEC Savings\"]\n                    if last_index &gt; 0 and pd.notnull:\n                        self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                            last_value + g.inpatient_bed_cost\n                        )\n\n                    else:\n                        self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                            g.inpatient_bed_cost\n                        )\n\n                # Regardless of whether the warm-up has passed, recording in\n                # patient object that this patient's journey was completed\n                patient.exit_time = self.env.now\n                patient.journey_completed = True\n\n                # Patients with a True admission avoidance are added to a list\n                # that is used to calculate the savings from the avoided admissions.\n                if (\n                    patient.admission_avoidance == True\n                    and patient.patient_diagnosis &lt; 2\n                    and self.env.now &gt; g.warm_up_period\n                ):\n                    self.admission_avoidance.append(patient)\n\n                # This code exists after the admission avoidance code so they\n                # are not added to the admission avoidance list, as that should\n                # only be for SDEC patients who avoid admission.\n                # This code ensures that these patients get an exit time\n\n                if patient.non_admitted_tia_ns_sm == True:\n                    patient.exit_time = self.env.now\n                    patient.journey_completed = True\n\n        ###############################################\n        # MARK: SDEC Full or closed\n        # Branch of logic for if SDEC is not available\n        ###############################################\n        else:\n            patient.sdec_pathway = False\n\n            # If SDEC not available, we will see some % of TIA and ED patients be returned\n            # to ED at this stage (i.e. outside of the modelled part of the system) and they\n            # won't be seen again.\n            if (\n                patient.non_admission &gt;= self.tia_admission_chance\n                and patient.patient_diagnosis == 2\n            ):\n                patient.admission_avoidance = False\n                patient.non_admitted_tia_ns_sm = True\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u21a9\ufe0f TIA Patient {patient.id} avoided admission.\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n            elif (\n                patient.non_admission &gt;= self.stroke_mimic_admission_chance\n                and patient.patient_diagnosis &gt; 2\n            ):\n                patient.admission_avoidance = False\n                patient.non_admitted_tia_ns_sm = True\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u21a9\ufe0f Stroke mimic or non-stroke Patient {patient.id} (diagnosis {patient.diagnosis}) avoided admission.\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n            else:\n                patient.non_admitted_tia_ns_sm = False\n\n            if patient.non_admitted_tia_ns_sm == True:\n                patient.exit_time = self.env.now\n                patient.journey_completed = True\n\n        #####################################################################\n        # MARK: Ward Admission\n        # once all the above code has been run all patients who will not admit\n        # have a True admission avoidance attribute. For all the patients that\n        # remain false, the below code will run simulating the admission to the\n        # ward.\n        ############################################################################\n\n        # TODO: sampled ward activity time is done after a bed is obtained.\n        # TODO: this is what is recorded as LOS within the model, but arguably\n        # the 'TRUE' LOS is therefore longer in the model as\n        # or is LOS in these cases sampled from stroke ward LOS only?\n        # is LOS increased by spending time on an 'inappropriate' ward in the\n        # real world, and if so, does this need to be reflected here?\n\n        if not patient.admission_avoidance and not patient.non_admitted_tia_ns_sm:\n            # Anyone who has made it to here has definitely not avoided admission\n            patient.admission_avoidance = False\n\n            # These code assigns a time to the start q variable. In stroke care\n            # delays can have serious consequence so modeling this is very\n            # important as flow disruption are a common issue.\n\n            start_q_ward = self.env.now\n            patient.ward_q_start_time = self.env.now\n\n            # Request the ward bed and hold the patient in a queue until this\n            # is met.\n\n            with self.ward_bed.request() as req:\n                ward_bed_used = yield req\n                patient.ward_bed_id = ward_bed_used.id_attribute\n                # Add patient to the ward list\n\n                self.ward_occupancy.append(patient)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83d\udecf\ufe0f Patient {patient.id} admitted to main ward at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy after admission: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n                patient.ward_admit_time = self.env.now\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Ward Occupancy\"] = len(\n                        self.ward_occupancy\n                    )\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.ward_occupancy_graph_df.loc[\n                        len(self.ward_occupancy_graph_df)\n                    ] = [\n                        self.env.now,\n                        len(self.ward_occupancy),\n                        False,\n                    ]\n                else:\n                    self.ward_occupancy_graph_df.loc[\n                        len(self.ward_occupancy_graph_df)\n                    ] = [\n                        self.env.now,\n                        len(self.ward_occupancy),\n                        True,\n                    ]\n\n                # The patient attribute for the queuing time in the ward is\n                # assigned here.\n\n                end_q_ward = self.env.now\n\n                patient.q_time_ward = end_q_ward - start_q_ward\n\n                # The below code checks the patients diagnosis and MRS,\n                # adjusting MRS change and LOS baised on these. This code is\n                # for ICH patients.\n\n                ###############################\n                # MARK: Patient diagnosis = 0 #\n                # Intracerebral haemorrhage   #\n                # Unsuitable for thrombolysis #\n                ###############################\n\n                if patient.patient_diagnosis == 0 and patient.mrs_type == 0:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_ich_ward_time_mrs_0\n                    # )\n                    sampled_ward_act_time = self.ich_ward_time_mrs_0_dist.sample()\n                    patient.mrs_discharge = patient.mrs_type\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 1:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_ich_ward_time_mrs_1\n                    # )\n                    sampled_ward_act_time = self.ich_ward_time_mrs_1_dist.sample()\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 2:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_ich_ward_time_mrs_2\n                    # )\n                    sampled_ward_act_time = self.ich_ward_time_mrs_2_dist.sample()\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 3:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_ich_ward_time_mrs_3\n                    # )\n                    sampled_ward_act_time = self.ich_ward_time_mrs_3_dist.sample()\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 4:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_ich_ward_time_mrs_4\n                    # )\n                    sampled_ward_act_time = self.ich_ward_time_mrs_4_dist.sample()\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 5:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_ich_ward_time_mrs_5\n                    # )\n                    sampled_ward_act_time = self.ich_ward_time_mrs_5_dist.sample()\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                ###############################\n                # MARK: Patient diagnosis = 1 #\n                # Ischaemic Stroke            #\n                # Some may be suitable for    #\n                # thrombolysis                #\n                ###############################\n\n                # The below code checks the patients diagnosis and MRS,\n                # adjusting MRS change and LOS baised on these. This code is\n                # for I patients amd also checks for thrombolysis and adjusts\n                # LOS and associated savings accordingly.\n\n                if patient.patient_diagnosis == 1 and patient.mrs_type == 0:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_i_ward_time_mrs_0\n                    # )\n                    sampled_ward_act_time = self.i_ward_time_mrs_0_dist.sample()\n                    patient.mrs_discharge = patient.mrs_type\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 1:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_i_ward_time_mrs_1\n                    # )\n                    sampled_ward_act_time = self.i_ward_time_mrs_1_dist.sample()\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        patient.mrs_discharge = (\n                            patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        patient.mrs_discharge = (\n                            patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 2:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_i_ward_time_mrs_2\n                    # )\n                    sampled_ward_act_time = self.i_ward_time_mrs_2_dist.sample()\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        patient.mrs_discharge = (\n                            patient.mrs_type\n                            - self.mrs_reduction_during_stay_thrombolysed.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        patient.mrs_discharge = (\n                            patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 3:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_i_ward_time_mrs_3\n                    # )\n                    sampled_ward_act_time = self.i_ward_time_mrs_3_dist.sample()\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        patient.mrs_discharge = (\n                            patient.mrs_type\n                            - self.mrs_reduction_during_stay_thrombolysed.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        patient.mrs_discharge = (\n                            patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 4:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_i_ward_time_mrs_4\n                    # )\n                    sampled_ward_act_time = self.i_ward_time_mrs_4_dist.sample()\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        patient.mrs_discharge = (\n                            patient.mrs_type\n                            - self.mrs_reduction_during_stay_thrombolysed.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        patient.mrs_discharge = (\n                            patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 5:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_i_ward_time_mrs_5\n                    # )\n                    sampled_ward_act_time = self.i_ward_time_mrs_5_dist.sample()\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        patient.mrs_discharge = (\n                            patient.mrs_type\n                            - self.mrs_reduction_during_stay_thrombolysed.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        # Record generated LOS in patient object\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        patient.mrs_discharge = (\n                            patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                        )\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        # Record generated LOS in patient object\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        patient.ward_discharge_time = self.env.now\n                        self.ward_occupancy.remove(patient)\n\n                #################################\n                # MARK: Patient diagnosis = 2   #\n                # Transient Ischaemic Attack    #\n                # Not suitable for thrombolysis #\n                #################################\n                # The below code is for the non stroke diagnosis.\n\n                if patient.patient_diagnosis == 2:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_tia_ward_time\n                    # )\n                    sampled_ward_act_time = self.tia_ward_time_dist.sample()\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    # Record generated LOS in patient object\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n                ###############################\n                # MARK: Patient diagnosis &gt; 2 #\n                # Stroke mimic OR non-stroke  #\n                ###############################\n                if patient.patient_diagnosis &gt; 2:\n                    # sampled_ward_act_time = random.expovariate(\n                    #     1.0 / g.mean_n_non_stroke_ward_time\n                    # )\n                    sampled_ward_act_time = self.non_stroke_ward_time_dist.sample()\n\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n\n                    # Record generated LOS in patient object\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n            # Relevent information is recorded in the results DataFrame.\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Ward\"] = patient.q_time_ward\n\n            # TODO: SR: I've tweaked this to take whichever of the ward_los or thrombolysis los is generated\n            # TODO SR: It would be better to take a more robust approach to this step.\n            try:\n                final_ward_los = sampled_ward_act_time\n            except:\n                final_ward_los = sampled_ward_act_time_thrombolysis\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Ward LOS\"] = final_ward_los\n\n                self.results_df.at[patient.id, \"MRS DC\"] = patient.mrs_discharge\n\n                self.results_df.at[patient.id, \"MRS Change\"] = (\n                    patient.mrs_type - patient.mrs_discharge\n                )\n\n            # MARK: Discharged from main ward\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\ude97 Patient {patient.id} discharged from main ward at {minutes_to_ampm(int(self.env.now % 1440))} after {final_ward_los:.1f} minutes ({(final_ward_los / 24 / 60):.1f} days). Occupancy after discharge: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            patient.exit_time = self.env.now\n            patient.journey_completed = True\n\n        # Record patients who exited at any remaining points\n        patient.exit_time = self.env.now\n        patient.journey_completed = True\n\n    # MARK: M: Run result calculation\n    # This method calculates results over a single run.\n    def calculate_run_results(self):\n        \"\"\"\n        Calculate summary statistics and financial metrics for a single\n        simulation run.\n\n        This method aggregates raw data collected throughout the simulation,\n        performs unit conversions, and computes Key Performance Indicators\n        (KPIs) related to clinical flow and financial impact. It cleans the\n        results dataframe and updates class-level attributes for use in\n        trial-level reporting.\n\n        - **Data Cleaning**: Removes the initial dummy row (index label 1) used\n          to initialize the `results_df`.\n        - **Unit Conversions**: Automatically converts ward-related timings\n          (Queue Time and Length of Stay) from minutes to hours for reporting.\n        - **SDEC Logic**: Financial staff costs for SDEC are adjusted based on\n          the `sdec_freeze_counter` to ensure costs are only incurred during\n          active operational periods.\n        - **Precision**:\n            - Financial and time-based KPIs are rounded to 0 decimal places.\n            - Clinical outcomes (MRS Change) are rounded to 2 decimal places.\n\n        Calculated Attributes\n        ---------------------\n        mean_q_time_nurse : float\n            Average wait time for a nurse in minutes.\n        number_of_admissions_avoided : int\n            Total count of patients diverted from inpatient wards via SDEC.\n        mean_q_time_ward : float\n            Average wait time for a ward bed in hours.\n        mean_ward_occupancy : float\n            The average number of beds occupied during the run.\n        admission_delays : int\n            Total number of patients who experienced any wait time for a ward\n            bed.\n        mean_los_ward : float\n            Average inpatient length of stay in hours.\n        sdec_financial_savings : float\n            Gross savings based on avoided bed days.\n        medical_staff_cost : float\n            The net operational cost of SDEC staffing.\n        savings_sdec : float\n            Net financial impact (Savings - Costs) of the SDEC unit.\n        total_savings : float\n            Combined net impact of SDEC and thrombolysis-related savings.\n        mean_mrs_change : float\n            Average change in Modified Rankin Scale for the patient cohort.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # Drop the first row of the results DataFrame, as this is just a dummy\n        # and will take on the value of zero.\n        self.results_df.drop([1], inplace=True)\n\n        # The below code calculates the average or cumulative values the model\n        # is concerned with.\n\n        self.mean_q_time_nurse = round(self.results_df[\"Q Time Nurse\"].mean(), 0)\n\n        self.max_q_time_nurse = round(self.results_df[\"Q Time Nurse\"].max(), 0)\n\n        self.number_of_admissions_avoided = len(self.admission_avoidance)\n\n        self.mean_q_time_ward = round(self.results_df[\"Q Time Ward\"].mean() / 60, 0)\n\n        self.max_q_time_ward = round(self.results_df[\"Q Time Ward\"].max() / 60, 0)\n\n        try:\n            self.mean_ward_occupancy = round(self.results_df[\"Ward Occupancy\"].mean())\n        except ValueError:\n            self.mean_ward_occupancy = np.NaN\n\n        self.admission_delays = len(self.results_df[self.results_df[\"Q Time Ward\"] &gt; 0])\n\n        self.mean_los_ward = round(self.results_df[\"Ward LOS\"].mean() / 60, 0)\n\n        # Note that this is using the admission avoidance MODEL attribute,\n        # which is populated entirely separately from the patient-level\n        # admission avoidance attributes and will ensure that only SDEC\n        # patients who are explicitly benefitting from admission avoidance\n        # via SDEC will be counted here\n        self.sdec_financial_savings = (\n            len(self.admission_avoidance) * g.inpatient_bed_cost\n        )\n\n        # The below code ensures that the SDEC incurs no cost if it is not\n        # running at all in the model. This was introduced as a bug was causing\n        # it to return small values even if the SDEC was not running. This is\n        # now fixed, but the code works so I have left it in place.\n\n        if g.sdec_unav_freq == 0:\n            self.medical_staff_cost = 0\n        else:\n            self.medical_staff_cost = round(\n                g.sdec_dr_cost_min * (g.sim_duration)\n                - g.sdec_dr_cost_min * self.sdec_freeze_counter * g.sdec_unav_time,\n                0,\n            )\n\n        self.savings_sdec = round(\n            self.sdec_financial_savings - self.medical_staff_cost, 0\n        )\n\n        self.thrombolysis_savings = round(\n            self.results_df[\"Thrombolysis Savings\"].sum(), 0\n        )\n        self.total_savings = self.thrombolysis_savings + self.savings_sdec\n\n        self.mean_mrs_change = round(self.results_df[\"MRS Change\"].mean(), 2)\n\n    # MARK: M: per-run plotting\n    # This method plots the stroke nurse assessment queue graph, as it is after\n    # the run method it will appear after the run has completed in the output.\n    # Might need to change this...\n\n    def plot_stroke_run_graphs(self, plot=True):\n        \"\"\"\n        Generate and display time-series visualizations for the simulation run.\n\n        This method creates a line plot of the Stroke Ward occupancy over the\n        duration of the simulation. It includes both the raw occupancy data\n        and a linear trend line to help identify long-term capacity issues.\n        Execution is dependent on the global `g.gen_graph` toggle.\n\n        - **Data Cleaning**: Automatically drops the first row (index 0) of\n          `occupancy_graph_df`, which is typically used as a placeholder.\n        - **Trend Analysis**: Uses a first-order polynomial fit\n          (`numpy.polyfit`) to calculate and display a linear trend line over\n          the occupancy data.\n        - **Extensibility**: Contains placeholder (commented-out) logic for\n          an additional \"Nurse Assessment Queue\" graph.\n        - **Dependencies**: Requires `matplotlib.pyplot` as `plt` and\n          `numpy` as `np`.\n\n        Parameters\n        ----------\n        plot : bool, default True\n            If True, the generated figure is displayed immediately using\n            `plt.show()`. If False, the figure object is returned to the\n            caller for further processing (e.g., aggregation in a Trial report).\n\n        Returns\n        -------\n        matplotlib.figure.Figure or None\n            Returns a Matplotlib Figure object if `plot` is False.\n            Returns None if `plot` is True or if `g.gen_graph` is False.\n\n\n        See Also\n        --------\n        Trial.run_trial : The method that may collect these figures for batch\n        reporting.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        if g.gen_graph == True:\n            # Queue for Nurse Assessment Graph (Currently Commented Out)\n\n            # self.nurse_q_graph_df.drop([0], inplace=True)\n\n            # fig, ax = plt.subplots()\n\n            # ax.set_xlabel(\"Time\")\n            # ax.set_ylabel(\"Number of patients in Q for Assessment\")\n            # ax.set_title(f\"Number of Patients in Nurse Assessment Queue \\\n            # Over Time \"f\"{self.run_number}\")\n\n            # ax.plot(self.nurse_q_graph_df[\"Time\"],\n            # self.nurse_q_graph_df[\"Patients in Assessment Queue\"],\n            # color=\"m\",\n            # linestyle=\"-\",\n            # label=\"Q for Stroke Nurse Assessment\")\n\n            # ax.legend(loc=\"upper right\")\n\n            # fig.show()\n\n            # Ward Occupancy Graph\n\n            self.ward_occupancy_graph_df.drop([0], inplace=True)\n\n            occupancy_after_warm_up = self.ward_occupancy_graph_df[\n                self.ward_occupancy_graph_df[\"After Warm-Up\"] == True\n            ]\n\n            fig, ax = plt.subplots()\n\n            ax.set_xlabel(\"Time\")\n            ax.set_ylabel(\"Stroke Ward Occupancy\")\n            ax.set_title(\n                f\"Trial \"\n                f\"{g.trials_run_counter}\\\n                         Ward Occupancy Over Time \"\n                f\"{self.run_number}\"\n            )\n\n            ax.plot(\n                occupancy_after_warm_up[\"Time\"],\n                occupancy_after_warm_up[\"Ward Occupancy\"],\n                color=\"b\",\n                linestyle=\"-\",\n                label=\"Ward Occupancy\",\n            )\n\n            # Add trend line\n            x = occupancy_after_warm_up[\"Time\"]\n            y = occupancy_after_warm_up[\"Ward Occupancy\"]\n            z = np.polyfit(x, y, 1)  # 1 = linear fit\n            p = np.poly1d(z)\n            ax.plot(x, p(x), color=\"b\", linestyle=\"--\", label=\"Trend Line\")\n\n            ax.legend(loc=\"upper right\")\n\n            if plot:\n                fig.show()\n            else:\n                return fig\n\n    def track_days(self):\n        \"\"\"\n        A SimPy process that logs the progression of simulation days.\n\n        This generator functions as a background 'clock' process. It wakes up\n        at the start of every 1440-minute interval (24 hours) to output a\n        formatted debug message indicating the current day of the simulation\n        run. This helps track progress in the console during long-running\n        simulations.\n\n        - The day calculation is performed using floor division:\n          `self.env.now // 1440`.\n        - The trace message visibility depends on the `g.show_trace` flag and\n          the `g.tracked_cases` configuration.\n        - This process runs concurrently with patient arrivals and clinical\n          obstructions without interfering with their logic.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # Print a debugging message every day\n        while self.env.now &lt;= g.sim_duration:\n            # TODO: this doesn't always reliably appear depending on number of tracked cases\n            trace(\n                msg=f\"========= DAY {(self.env.now // 1440):.0f} ===============\",\n                time=self.env.now,\n                debug=g.show_trace,\n                identifier=max(g.tracked_cases),\n                config=g.trace_config,\n            )\n            yield self.env.timeout(1440)\n\n    # MARK: M: run model\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        \"\"\"\n        Execute the simulation run lifecycle.\n\n        This method initializes the simulation by registering background\n        processes, executes the SimPy event loop for a specified duration,\n        and performs post-simulation data processing and export tasks.\n\n        The execution sequence is as follows:\n        1. Register time-tracking, patient arrival, and resource obstruction\n           generators as SimPy processes.\n        2. Execute the simulation engine until the combined limit of the\n           warm-up period and active simulation duration is reached.\n        3. Trigger final calculation of run-level results.\n        4. (Optional) Export patient-level results to a CSV file.\n\n        - **Warm-up Period**: The total runtime includes `g.warm_up_period`. This\n          is crucial for allowing the model to reach a 'steady state' before\n          results are recorded as valid.\n        - **Concurrency**: All methods passed to `self.env.process()` run\n          pseudo-parallelly, managed by the SimPy event scheduler.\n        - **Post-Processing**: This method must be called for `results_df`\n          and other KPIs to be populated with final values.\n\n        See Also\n        --------\n        track_days : The background process that logs day transitions.\n\n        generator_patient_arrivals: generates in-hours patients and sends them\n            through the assessment pathway.\n\n        obstruct_ctp: ensures the ctp scanner is only available for the\n            specified times.\n\n        obstruct_sdec: ensures the sdec is only available for the specified\n            times.\n\n        calculate_run_results : The method called to process data after the\n            event loop finishes.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # starts up the generators in the model, of which there are three.\n\n        self.env.process(self.track_days())\n        self.env.process(self.generator_patient_arrivals())\n        self.env.process(self.obstruct_ctp())\n        self.env.process(self.obstruct_sdec())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Check that all patient objects generated are valid\n        # This can highlight errors with patients who don't get all of their attributes set,\n        # which can indicate issues with logic branches\n        # Only check for patients with a completed journey as those with incomplete journeys\n        # may simply have not reached the point in the model where the relevant attribute was set\n        [p.validate() for p in self.patient_objects if p.journey_completed]\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model, this is commented out at the moment.\n\n        # print (f\"Run Number {self.run_number}\")\n        # print (self.results_df)\n\n        if g.write_to_csv == True:\n            self.results_df.to_csv(\n                f\"trial {g.trials_run_counter} output {self.run_number}.csv\",\n                index=False,\n            )\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.calculate_run_results","title":"<code>calculate_run_results()</code>","text":"<p>Calculate summary statistics and financial metrics for a single simulation run.</p> <p>This method aggregates raw data collected throughout the simulation, performs unit conversions, and computes Key Performance Indicators (KPIs) related to clinical flow and financial impact. It cleans the results dataframe and updates class-level attributes for use in trial-level reporting.</p> <ul> <li>Data Cleaning: Removes the initial dummy row (index label 1) used   to initialize the <code>results_df</code>.</li> <li>Unit Conversions: Automatically converts ward-related timings   (Queue Time and Length of Stay) from minutes to hours for reporting.</li> <li>SDEC Logic: Financial staff costs for SDEC are adjusted based on   the <code>sdec_freeze_counter</code> to ensure costs are only incurred during   active operational periods.</li> <li>Precision:<ul> <li>Financial and time-based KPIs are rounded to 0 decimal places.</li> <li>Clinical outcomes (MRS Change) are rounded to 2 decimal places.</li> </ul> </li> </ul> Calculated Attributes <p>mean_q_time_nurse : float     Average wait time for a nurse in minutes. number_of_admissions_avoided : int     Total count of patients diverted from inpatient wards via SDEC. mean_q_time_ward : float     Average wait time for a ward bed in hours. mean_ward_occupancy : float     The average number of beds occupied during the run. admission_delays : int     Total number of patients who experienced any wait time for a ward     bed. mean_los_ward : float     Average inpatient length of stay in hours. sdec_financial_savings : float     Gross savings based on avoided bed days. medical_staff_cost : float     The net operational cost of SDEC staffing. savings_sdec : float     Net financial impact (Savings - Costs) of the SDEC unit. total_savings : float     Combined net impact of SDEC and thrombolysis-related savings. mean_mrs_change : float     Average change in Modified Rankin Scale for the patient cohort.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def calculate_run_results(self):\n    \"\"\"\n    Calculate summary statistics and financial metrics for a single\n    simulation run.\n\n    This method aggregates raw data collected throughout the simulation,\n    performs unit conversions, and computes Key Performance Indicators\n    (KPIs) related to clinical flow and financial impact. It cleans the\n    results dataframe and updates class-level attributes for use in\n    trial-level reporting.\n\n    - **Data Cleaning**: Removes the initial dummy row (index label 1) used\n      to initialize the `results_df`.\n    - **Unit Conversions**: Automatically converts ward-related timings\n      (Queue Time and Length of Stay) from minutes to hours for reporting.\n    - **SDEC Logic**: Financial staff costs for SDEC are adjusted based on\n      the `sdec_freeze_counter` to ensure costs are only incurred during\n      active operational periods.\n    - **Precision**:\n        - Financial and time-based KPIs are rounded to 0 decimal places.\n        - Clinical outcomes (MRS Change) are rounded to 2 decimal places.\n\n    Calculated Attributes\n    ---------------------\n    mean_q_time_nurse : float\n        Average wait time for a nurse in minutes.\n    number_of_admissions_avoided : int\n        Total count of patients diverted from inpatient wards via SDEC.\n    mean_q_time_ward : float\n        Average wait time for a ward bed in hours.\n    mean_ward_occupancy : float\n        The average number of beds occupied during the run.\n    admission_delays : int\n        Total number of patients who experienced any wait time for a ward\n        bed.\n    mean_los_ward : float\n        Average inpatient length of stay in hours.\n    sdec_financial_savings : float\n        Gross savings based on avoided bed days.\n    medical_staff_cost : float\n        The net operational cost of SDEC staffing.\n    savings_sdec : float\n        Net financial impact (Savings - Costs) of the SDEC unit.\n    total_savings : float\n        Combined net impact of SDEC and thrombolysis-related savings.\n    mean_mrs_change : float\n        Average change in Modified Rankin Scale for the patient cohort.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # Drop the first row of the results DataFrame, as this is just a dummy\n    # and will take on the value of zero.\n    self.results_df.drop([1], inplace=True)\n\n    # The below code calculates the average or cumulative values the model\n    # is concerned with.\n\n    self.mean_q_time_nurse = round(self.results_df[\"Q Time Nurse\"].mean(), 0)\n\n    self.max_q_time_nurse = round(self.results_df[\"Q Time Nurse\"].max(), 0)\n\n    self.number_of_admissions_avoided = len(self.admission_avoidance)\n\n    self.mean_q_time_ward = round(self.results_df[\"Q Time Ward\"].mean() / 60, 0)\n\n    self.max_q_time_ward = round(self.results_df[\"Q Time Ward\"].max() / 60, 0)\n\n    try:\n        self.mean_ward_occupancy = round(self.results_df[\"Ward Occupancy\"].mean())\n    except ValueError:\n        self.mean_ward_occupancy = np.NaN\n\n    self.admission_delays = len(self.results_df[self.results_df[\"Q Time Ward\"] &gt; 0])\n\n    self.mean_los_ward = round(self.results_df[\"Ward LOS\"].mean() / 60, 0)\n\n    # Note that this is using the admission avoidance MODEL attribute,\n    # which is populated entirely separately from the patient-level\n    # admission avoidance attributes and will ensure that only SDEC\n    # patients who are explicitly benefitting from admission avoidance\n    # via SDEC will be counted here\n    self.sdec_financial_savings = (\n        len(self.admission_avoidance) * g.inpatient_bed_cost\n    )\n\n    # The below code ensures that the SDEC incurs no cost if it is not\n    # running at all in the model. This was introduced as a bug was causing\n    # it to return small values even if the SDEC was not running. This is\n    # now fixed, but the code works so I have left it in place.\n\n    if g.sdec_unav_freq == 0:\n        self.medical_staff_cost = 0\n    else:\n        self.medical_staff_cost = round(\n            g.sdec_dr_cost_min * (g.sim_duration)\n            - g.sdec_dr_cost_min * self.sdec_freeze_counter * g.sdec_unav_time,\n            0,\n        )\n\n    self.savings_sdec = round(\n        self.sdec_financial_savings - self.medical_staff_cost, 0\n    )\n\n    self.thrombolysis_savings = round(\n        self.results_df[\"Thrombolysis Savings\"].sum(), 0\n    )\n    self.total_savings = self.thrombolysis_savings + self.savings_sdec\n\n    self.mean_mrs_change = round(self.results_df[\"MRS Change\"].mean(), 2)\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.generator_patient_arrivals","title":"<code>generator_patient_arrivals()</code>","text":"<p>A SimPy process generator that handles \"in-hours\" patient arrivals.</p> <p>This function runs as a continuous loop. It checks if the current simulation time is within daytime operating hours (0-960 minutes relative to the start of a 1440-minute day).</p> <p>If in-hours, it:</p> <ol> <li> <p>Updates global arrival flags.</p> </li> <li> <p>Instantiates a new Patient object.</p> </li> <li> <p>Records trace information.</p> </li> <li> <p>Triggers the <code>stroke_assessment</code> process for the patient.</p> </li> <li> <p>Samples an inter-arrival time and yields a timeout.</p> </li> </ol> <p>If out-of-hours, it yields a small timeout before checking again.</p> <p>Arrival rates are determined by <code>random.expovariate</code> using the <code>g.patient_inter_day</code> parameter. NOTE that this does not use the <code>g.patient_inter_day</code> parameter directly, and instead uses it alongside a rate modifier - careful inspection of the code to understand the impacts of changing <code>g.patient_inter_day</code> is recommended, and this may be adjusted in a future version of the model.</p> <p>Patients generated here have their <code>arrived_ooh</code> attribute set to False.</p> <p>This process triggers the <code>stroke_assessment</code> process for every newly created patient.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def generator_patient_arrivals(self):\n    \"\"\"\n    A SimPy process generator that handles \"in-hours\" patient arrivals.\n\n    This function runs as a continuous loop. It checks if the current\n    simulation time is within daytime operating hours (0-960 minutes\n    relative to the start of a 1440-minute day).\n\n    If in-hours, it:\n\n    1. Updates global arrival flags.\n\n    2. Instantiates a new Patient object.\n\n    3. Records trace information.\n\n    4. Triggers the `stroke_assessment` process for the patient.\n\n    5. Samples an inter-arrival time and yields a timeout.\n\n    If out-of-hours, it yields a small timeout before checking again.\n\n    Arrival rates are determined by `random.expovariate` using the\n    `g.patient_inter_day` parameter. NOTE that this does not use the\n    `g.patient_inter_day` parameter directly, and instead uses it\n    alongside a rate modifier - careful inspection of the code to\n    understand the impacts of changing `g.patient_inter_day` is\n    recommended, and this may be adjusted in a future version of the model.\n\n    Patients generated here have their `arrived_ooh` attribute set to False.\n\n    This process triggers the `stroke_assessment` process for every\n    newly created patient.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    while True:\n        sampled_inter = self.patient_inter_dist.sample(simulation_time=self.env.now)\n\n        # Freeze this instance of this function in place until the\n        # inter-arrival time has elapsed.\n        yield self.env.timeout(sampled_inter)\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\u23f2\ufe0f Next patient arriving in {sampled_inter:.1f} minutes\",\n            identifier=self.patient_counter,\n            config=g.trace_config,\n        )\n\n        # Increment the patient counter by 1 for each new patient\n        self.patient_counter += 1\n\n        # Create a new patient - an instance of the Patient Class we\n        # defined above. patient counter ID passed from above to patient\n        # class.\n        p = Patient(self.patient_counter)\n        self.patient_objects.append(p)\n        if self.env.now &lt; g.warm_up_period:\n            p.generated_during_warm_up = True\n        else:\n            p.generated_during_warm_up = False\n\n        time_of_day = self.env.now % 1440\n\n        if self.is_in_hours(time_of_day):\n            # Change the Global Class variable\n            g.patient_arrival_gen_1 = True\n            g.patient_arrival_gen_2 = False\n\n            p.onset_type = self.onset_type_distribution_in_hours.sample()\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u2600\ufe0f IN-HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                identifier=p.id,\n                config=g.trace_config,\n            )\n\n            p.arrived_ooh = False\n\n        elif self.is_out_of_hours(time_of_day):\n            # Change the Global Class variable\n            g.patient_arrival_gen_1 = False\n            g.patient_arrival_gen_2 = True\n\n            p.onset_type = self.onset_type_distribution_out_of_hours.sample()\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udf19 OUT OF HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                identifier=p.id,\n                config=g.trace_config,\n            )\n\n            p.arrived_ooh = True\n\n        # Tell SimPy to start the stroke assessment function with\n        # this patient (the generator function that will model the\n        # patient's journey through the system)\n        self.env.process(self.stroke_assessment(p))\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.obstruct_ctp","title":"<code>obstruct_ctp()</code>","text":"<p>Simulates periodic CTP scanner unavailability (off time).</p> <p>This process acts as a \"blocker\" by requesting the CTP scanner resource with a priority of -1. Since patients typically have a priority of 1, this process effectively preempts the queue, preventing patients from using the scanners during this period.</p> <p>The scanner will not stop a scan that is already in progress; it waits for the current user to finish before taking the resource offline.</p> <p>Frequencies and durations are governed by <code>g.ctp_unav_freq</code> and <code>g.ctp_unav_time</code>.</p> <p>Yields:</p> Type Description <code>Timeout</code> <p>Initial offset for opening hours and subsequent intervals between downtime events.</p> <code>ResourceRequest</code> <p>A high-priority request to seize the CTP scanner and take it \"offline.\"</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def obstruct_ctp(self):\n    \"\"\"\n    Simulates periodic CTP scanner unavailability (off time).\n\n    This process acts as a \"blocker\" by requesting the CTP scanner resource\n    with a priority of -1. Since patients typically have a priority of 1,\n    this process effectively preempts the queue, preventing patients from\n    using the scanners during this period.\n\n    The scanner will not stop a scan that is already in progress;\n    it waits for the current user to finish before taking the\n    resource offline.\n\n    Frequencies and durations are governed by `g.ctp_unav_freq`\n    and `g.ctp_unav_time`.\n\n    Yields\n    ------\n    simpy.events.Timeout\n        Initial offset for opening hours and subsequent intervals\n        between downtime events.\n    simpy.events.ResourceRequest\n        A high-priority request to seize the CTP scanner and take\n        it \"offline.\"\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n\n    \"\"\"\n    # SR: Add initial offset\n    # SR: Patient generators have also been updated\n    # to match with how this is working\n    yield self.env.timeout(g.ctp_opening_hour * 60)\n\n    while True:\n        yield self.env.timeout(g.ctp_unav_freq)\n        # Once elapsed, this generator requests the ctp scanner with\n        # a priority of -1. As the patient priority is set at 1\n        # the scanner will take priority over any patients waiting.\n        # This method also means that the scanner won't stop mid scan.\n        g.ctp_unav = True\n        with self.ctp_scanner.request(priority=-1) as req:\n            yield req\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udd2c CTP scanner OFFLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n            # Freeze with the scanners held in place for the unavailability\n            # time, in the model this means patients admitted in this time\n            # will not have a ctp scan.\n            # freq and unav times are set in the g class\n            yield self.env.timeout(g.ctp_unav_time)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udd2c CTP scanner back ONLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n            g.ctp_unav = False\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.obstruct_sdec","title":"<code>obstruct_sdec()</code>","text":"<p>Simulates the scheduled closure or unavailability of the SDEC unit.</p> <p>Similar to the CTP obstruction, this process seizes an SDEC bed at a high priority (-1) for a defined duration. This models the real-world scenario where the SDEC unit closes at night or during specific hours, forcing patients to bypass this pathway.</p> <p>If a closure occurs after the simulation warm-up period, the <code>sdec_freeze_counter</code> is incremented.</p> <p>Patients arriving while the SDEC is \"obstructed\" will be unable to access SDEC resources.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def obstruct_sdec(self):\n    \"\"\"\n    Simulates the scheduled closure or unavailability of the SDEC unit.\n\n    Similar to the CTP obstruction, this process seizes an SDEC bed\n    at a high priority (-1) for a defined duration. This models the\n    real-world scenario where the SDEC unit closes at night or\n    during specific hours, forcing patients to bypass this pathway.\n\n    If a closure occurs after the simulation warm-up period, the\n    `sdec_freeze_counter` is incremented.\n\n    Patients arriving while the SDEC is \"obstructed\" will be\n    unable to access SDEC resources.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # SR: Add initial offset\n    # SR: Patient generators have also been updated\n    # to match with how this is working\n    yield self.env.timeout(g.sdec_opening_hour * 60)\n\n    while True:\n        yield self.env.timeout(g.sdec_unav_freq)\n        g.sdec_unav = True\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83c\udfe5 SDEC CLOSES at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy at closure: {len(self.sdec_occupancy)} of {g.sdec_beds} beds.\",\n            identifier=self.patient_counter,\n            config=g.trace_config,\n        )\n\n        # Freeze with the SDEC held in place for the unavailability\n        # time, in the model this means patients admitted in this time\n        # will not have passed through the SDEC.\n        # freq and unav times are set in the g class\n        yield self.env.timeout(g.sdec_unav_time)\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83c\udfe5 SDEC OPENS at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy at opening: {len(self.sdec_occupancy)} of {g.sdec_beds} beds.\",\n            identifier=self.patient_counter,\n            config=g.trace_config,\n        )\n\n        g.sdec_unav = False\n\n        if self.env.now &gt; g.warm_up_period:\n            self.sdec_freeze_counter += 1\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.plot_stroke_run_graphs","title":"<code>plot_stroke_run_graphs(plot=True)</code>","text":"<p>Generate and display time-series visualizations for the simulation run.</p> <p>This method creates a line plot of the Stroke Ward occupancy over the duration of the simulation. It includes both the raw occupancy data and a linear trend line to help identify long-term capacity issues. Execution is dependent on the global <code>g.gen_graph</code> toggle.</p> <ul> <li>Data Cleaning: Automatically drops the first row (index 0) of   <code>occupancy_graph_df</code>, which is typically used as a placeholder.</li> <li>Trend Analysis: Uses a first-order polynomial fit   (<code>numpy.polyfit</code>) to calculate and display a linear trend line over   the occupancy data.</li> <li>Extensibility: Contains placeholder (commented-out) logic for   an additional \"Nurse Assessment Queue\" graph.</li> <li>Dependencies: Requires <code>matplotlib.pyplot</code> as <code>plt</code> and   <code>numpy</code> as <code>np</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>If True, the generated figure is displayed immediately using <code>plt.show()</code>. If False, the figure object is returned to the caller for further processing (e.g., aggregation in a Trial report).</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure or None</code> <p>Returns a Matplotlib Figure object if <code>plot</code> is False. Returns None if <code>plot</code> is True or if <code>g.gen_graph</code> is False.</p> See Also <p>Trial.run_trial : The method that may collect these figures for batch reporting.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def plot_stroke_run_graphs(self, plot=True):\n    \"\"\"\n    Generate and display time-series visualizations for the simulation run.\n\n    This method creates a line plot of the Stroke Ward occupancy over the\n    duration of the simulation. It includes both the raw occupancy data\n    and a linear trend line to help identify long-term capacity issues.\n    Execution is dependent on the global `g.gen_graph` toggle.\n\n    - **Data Cleaning**: Automatically drops the first row (index 0) of\n      `occupancy_graph_df`, which is typically used as a placeholder.\n    - **Trend Analysis**: Uses a first-order polynomial fit\n      (`numpy.polyfit`) to calculate and display a linear trend line over\n      the occupancy data.\n    - **Extensibility**: Contains placeholder (commented-out) logic for\n      an additional \"Nurse Assessment Queue\" graph.\n    - **Dependencies**: Requires `matplotlib.pyplot` as `plt` and\n      `numpy` as `np`.\n\n    Parameters\n    ----------\n    plot : bool, default True\n        If True, the generated figure is displayed immediately using\n        `plt.show()`. If False, the figure object is returned to the\n        caller for further processing (e.g., aggregation in a Trial report).\n\n    Returns\n    -------\n    matplotlib.figure.Figure or None\n        Returns a Matplotlib Figure object if `plot` is False.\n        Returns None if `plot` is True or if `g.gen_graph` is False.\n\n\n    See Also\n    --------\n    Trial.run_trial : The method that may collect these figures for batch\n    reporting.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    if g.gen_graph == True:\n        # Queue for Nurse Assessment Graph (Currently Commented Out)\n\n        # self.nurse_q_graph_df.drop([0], inplace=True)\n\n        # fig, ax = plt.subplots()\n\n        # ax.set_xlabel(\"Time\")\n        # ax.set_ylabel(\"Number of patients in Q for Assessment\")\n        # ax.set_title(f\"Number of Patients in Nurse Assessment Queue \\\n        # Over Time \"f\"{self.run_number}\")\n\n        # ax.plot(self.nurse_q_graph_df[\"Time\"],\n        # self.nurse_q_graph_df[\"Patients in Assessment Queue\"],\n        # color=\"m\",\n        # linestyle=\"-\",\n        # label=\"Q for Stroke Nurse Assessment\")\n\n        # ax.legend(loc=\"upper right\")\n\n        # fig.show()\n\n        # Ward Occupancy Graph\n\n        self.ward_occupancy_graph_df.drop([0], inplace=True)\n\n        occupancy_after_warm_up = self.ward_occupancy_graph_df[\n            self.ward_occupancy_graph_df[\"After Warm-Up\"] == True\n        ]\n\n        fig, ax = plt.subplots()\n\n        ax.set_xlabel(\"Time\")\n        ax.set_ylabel(\"Stroke Ward Occupancy\")\n        ax.set_title(\n            f\"Trial \"\n            f\"{g.trials_run_counter}\\\n                     Ward Occupancy Over Time \"\n            f\"{self.run_number}\"\n        )\n\n        ax.plot(\n            occupancy_after_warm_up[\"Time\"],\n            occupancy_after_warm_up[\"Ward Occupancy\"],\n            color=\"b\",\n            linestyle=\"-\",\n            label=\"Ward Occupancy\",\n        )\n\n        # Add trend line\n        x = occupancy_after_warm_up[\"Time\"]\n        y = occupancy_after_warm_up[\"Ward Occupancy\"]\n        z = np.polyfit(x, y, 1)  # 1 = linear fit\n        p = np.poly1d(z)\n        ax.plot(x, p(x), color=\"b\", linestyle=\"--\", label=\"Trend Line\")\n\n        ax.legend(loc=\"upper right\")\n\n        if plot:\n            fig.show()\n        else:\n            return fig\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.run","title":"<code>run()</code>","text":"<p>Execute the simulation run lifecycle.</p> <p>This method initializes the simulation by registering background processes, executes the SimPy event loop for a specified duration, and performs post-simulation data processing and export tasks.</p> <p>The execution sequence is as follows: 1. Register time-tracking, patient arrival, and resource obstruction    generators as SimPy processes. 2. Execute the simulation engine until the combined limit of the    warm-up period and active simulation duration is reached. 3. Trigger final calculation of run-level results. 4. (Optional) Export patient-level results to a CSV file.</p> <ul> <li>Warm-up Period: The total runtime includes <code>g.warm_up_period</code>. This   is crucial for allowing the model to reach a 'steady state' before   results are recorded as valid.</li> <li>Concurrency: All methods passed to <code>self.env.process()</code> run   pseudo-parallelly, managed by the SimPy event scheduler.</li> <li>Post-Processing: This method must be called for <code>results_df</code>   and other KPIs to be populated with final values.</li> </ul> See Also <p>track_days : The background process that logs day transitions.</p> <p>generator_patient_arrivals: generates in-hours patients and sends them     through the assessment pathway.</p> <p>obstruct_ctp: ensures the ctp scanner is only available for the     specified times.</p> <p>obstruct_sdec: ensures the sdec is only available for the specified     times.</p> <p>calculate_run_results : The method called to process data after the     event loop finishes.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def run(self):\n    \"\"\"\n    Execute the simulation run lifecycle.\n\n    This method initializes the simulation by registering background\n    processes, executes the SimPy event loop for a specified duration,\n    and performs post-simulation data processing and export tasks.\n\n    The execution sequence is as follows:\n    1. Register time-tracking, patient arrival, and resource obstruction\n       generators as SimPy processes.\n    2. Execute the simulation engine until the combined limit of the\n       warm-up period and active simulation duration is reached.\n    3. Trigger final calculation of run-level results.\n    4. (Optional) Export patient-level results to a CSV file.\n\n    - **Warm-up Period**: The total runtime includes `g.warm_up_period`. This\n      is crucial for allowing the model to reach a 'steady state' before\n      results are recorded as valid.\n    - **Concurrency**: All methods passed to `self.env.process()` run\n      pseudo-parallelly, managed by the SimPy event scheduler.\n    - **Post-Processing**: This method must be called for `results_df`\n      and other KPIs to be populated with final values.\n\n    See Also\n    --------\n    track_days : The background process that logs day transitions.\n\n    generator_patient_arrivals: generates in-hours patients and sends them\n        through the assessment pathway.\n\n    obstruct_ctp: ensures the ctp scanner is only available for the\n        specified times.\n\n    obstruct_sdec: ensures the sdec is only available for the specified\n        times.\n\n    calculate_run_results : The method called to process data after the\n        event loop finishes.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # starts up the generators in the model, of which there are three.\n\n    self.env.process(self.track_days())\n    self.env.process(self.generator_patient_arrivals())\n    self.env.process(self.obstruct_ctp())\n    self.env.process(self.obstruct_sdec())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Check that all patient objects generated are valid\n    # This can highlight errors with patients who don't get all of their attributes set,\n    # which can indicate issues with logic branches\n    # Only check for patients with a completed journey as those with incomplete journeys\n    # may simply have not reached the point in the model where the relevant attribute was set\n    [p.validate() for p in self.patient_objects if p.journey_completed]\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n    # Print the run number with the patient-level results from this run of\n    # the model, this is commented out at the moment.\n\n    # print (f\"Run Number {self.run_number}\")\n    # print (self.results_df)\n\n    if g.write_to_csv == True:\n        self.results_df.to_csv(\n            f\"trial {g.trials_run_counter} output {self.run_number}.csv\",\n            index=False,\n        )\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.set_patient_attributes","title":"<code>set_patient_attributes(patient)</code>","text":"<p>Sets a series of randomised per-patient attributes</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Instance of class `Patient`</code> <p>One single unique patient object.</p> required Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def set_patient_attributes(self, patient):\n    \"\"\"\n    Sets a series of randomised per-patient attributes\n\n    Parameters\n    ----------\n    patient : Instance of class `Patient`\n        One single unique patient object.\n    \"\"\"\n    # For now, no-one gets thrombectomy\n    patient.thrombectomy = False\n\n    # Populate various patient attributes\n    # patient.mrs_type = min(round(random.expovariate(1.0 / g.mean_mrs)), 5)\n    patient.mrs_type = min(round(self.mrs_type_distribution.sample()), 5)\n    # patient.diagnosis = random.randint(0, 100)\n    patient.diagnosis = self.diagnosis_distribution.sample()\n    # patient.non_admission = random.randint(0, 100)\n    patient.non_admission = self.non_admission_distribution.sample()\n\n    # Define threshold for admission for TIA + stroke mimic patients\n    self.tia_admission_chance = self.tia_admission_chance_distribution.sample()\n\n    self.stroke_mimic_admission_chance = (\n        self.stroke_mimic_admission_chance_distribution.sample()\n    )\n\n    # This code introduces a slight element of randomness into the patient's\n    # diagnosis.\n\n    # self.ich_range = random.normalvariate(g.ich, 1)\n    self.ich_range = self.ich_range_distribution.sample()\n    # self.i_range = max(random.normalvariate(g.i, 1), self.ich_range)\n    self.i_range = max(self.i_range_distribution.sample(), self.ich_range)\n    # self.tia_range = max(random.normalvariate(g.tia, 1), self.i_range)\n    self.tia_range = max(self.tia_range_distribution.sample(), self.i_range)\n    # self.stroke_mimic_range = max(\n    #     random.normalvariate(g.stroke_mimic, 1), self.tia_range\n    # )\n    self.stroke_mimic_range = max(\n        self.stroke_mimic_range_distribution.sample(), self.tia_range\n    )\n    # self.non_stroke_range = max(\n    #     random.normalvariate(g.stroke_mimic, 1), self.stroke_mimic_range\n    # )\n    self.non_stroke_range = max(\n        self.non_stroke_range_distribution.sample(), self.stroke_mimic_range\n    )\n\n    if patient.diagnosis &lt;= self.ich_range:\n        patient.patient_diagnosis = 0\n        patient.patient_diagnosis_type = \"ICH\"\n        self.ich_patients_count += 1\n    elif patient.diagnosis &lt;= self.i_range:\n        patient.patient_diagnosis = 1\n        patient.patient_diagnosis_type = \"I\"\n        self.i_patients_count += 1\n    elif patient.diagnosis &lt;= self.tia_range:\n        patient.patient_diagnosis = 2\n        patient.patient_diagnosis_type = \"TIA\"\n        self.tia_patients_count += 1\n    elif patient.diagnosis &lt;= self.stroke_mimic_range:\n        patient.patient_diagnosis = 3\n        patient.patient_diagnosis_type = \"Stroke Mimic\"\n        self.stroke_mimic_patient_count += 1\n    # SR - this was changed from an elif as was resulting in patients in\n    # between the two thresholds not getting allocated a diagnosis, which\n    # causes errors elsewhere\n    else:\n        patient.patient_diagnosis = 4\n        patient.patient_diagnosis_type = \"Non Stroke\"\n        self.non_stroke_patient_count += 1\n\n    # The below code records the patients diagnosis attribute, this is\n    # added to the DF to check the diagnosis code is working correctly.\n    # SR - refactored recording of diagnosis type in results df as that's\n    # now recorded as a patient attribute earlier\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Diagnosis Type\"] = (\n            patient.patient_diagnosis_type\n        )\n\n        self.results_df.at[patient.id, \"Onset Type\"] = patient.onset_type\n\n        # This code adds the Patient's MRS to the DF, this can be used to\n        # check all code that interacts with this runs correctly.\n        self.results_df.at[patient.id, \"MRS Type\"] = patient.mrs_type\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.stroke_assessment","title":"<code>stroke_assessment(patient)</code>","text":"<p>Simulates the full assessment and treatment pathway for patients in a stroke pathway.</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Instance of class `Patient`</code> <p>One single unique patient object.</p> required Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def stroke_assessment(self, patient):\n    \"\"\"\n    Simulates the full assessment and treatment pathway for patients\n    in a stroke pathway.\n\n    Parameters\n    ----------\n    patient : Instance of class `Patient`\n        One single unique patient object.\n    \"\"\"\n    self.set_patient_attributes(patient)\n\n    trace(\n        time=self.env.now,\n        debug=g.show_trace,\n        msg=f\"Patient {patient.id} Patient Diagnosis (category 1-4): {patient.patient_diagnosis}.\",\n        identifier=patient.id,\n        config=g.trace_config,\n    )\n\n    # Record the time the patient started queuing for a nurse\n    start_q_nurse = self.env.now\n    patient.nurse_q_start_time = self.env.now\n\n    self.q_for_assessment.append(patient)\n\n    # Add the arrival time to the main DF\n    # This is partly to test if the\n    # patient arrival times mirror the real world data\n    # SR: this is also now used for animation generation\n\n    patient.clock_start = self.env.now\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Arrival Time\"] = patient.clock_start\n\n        self.results_df.at[patient.id, \"Patient Gen 1 Status\"] = (\n            g.patient_arrival_gen_1\n        )\n\n        self.results_df.at[patient.id, \"Patient Gen 2 Status\"] = (\n            g.patient_arrival_gen_2\n        )\n\n    #######################################################################\n    # MARK: Nurse triage\n    # This code says request a nurse resource, and do all of the following\n    # block of code with that nurse resource held in place (and therefore\n    # not usable by another patient)\n    ########################################################################\n    with self.nurse.request() as req:\n        # Freeze the function until the request for a nurse can be met.\n        # The patient is currently queuing.\n        nurse_attending = yield req\n        # SR - have added recording of the resource ID that's possible as\n        # it's now using vidigi resources\n        patient.nurse_attending_id = nurse_attending.id_attribute\n        patient.nurse_triage_start_time = self.env.now\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\udc69\u200d\u2695\ufe0f Patient {patient.id} is being seen by a nurse at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        # Control is passed back to the generator function once the request\n        # is met for a nurse. As the queue for the nurse is finished\n        # the patient then leaves the assessment queue list.\n\n        end_q_nurse = self.env.now\n\n        self.q_for_assessment.remove(patient)\n\n        # The code below checks if the warm up period has passed before\n        # entering data into the df, this code exists when ever data is\n        # recorded\n\n        if self.env.now &gt; g.warm_up_period:\n            self.nurse_q_graph_df.loc[len(self.nurse_q_graph_df)] = [\n                self.env.now,\n                len(self.q_for_assessment),\n            ]\n\n        # Calculate the time this patient was queuing for the nurse, and\n        # record it in the patient's attribute\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n        # The below code creates a random action time for the nurse based\n        # on the mean in g class, and assigns it ot a variable. Currently\n        # using a Exponential distribution but might need to switch to\n        # a Log normal one (though the intense variation in the real life\n        # consult time might mean a exponetial distribution is better)\n        # sampled_nurse_act_time = random.expovariate(1.0 / g.mean_n_consult_time)\n        sampled_nurse_act_time = self.nurse_consult_time_dist.sample()\n\n        # Freeze this function in place for the activity time we sampled\n        # above.  This is the patient spending time with the nurse.\n        yield self.env.timeout(sampled_nurse_act_time)\n\n        patient.nurse_triage_end_time = self.env.now\n\n        # In the .at function below, the first value is the row, the second\n        # value is the column in which to add data. The final value is the\n        # the data that is to be added to the DF, in this case the Nurse\n        # Q time\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = patient.q_time_nurse\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time\n            )\n\n    # TIME WITH NURSE ENDS - NURSE RESOURCE RELEASED HERE FOR NEXT PATIENT\n\n    # MARK: CT and CT Perfusion Scanner Use\n    # The if formula below checks to see if the CTP scanner is active\n    # and if it is the following code is followed including updating the\n    # patient advanced CT pathway attribute\n\n    if g.ctp_unav == False:\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\u27a1\ufe0f Patient {patient.id} sent on CTP scanner pathway at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        patient.ctp_scan_start_time = self.env.now\n\n        patient.advanced_ct_pathway = True\n\n        # Randomly sample the mean ct time, as with above this may need to\n        # be updated to a log normal distribution\n\n        # sampled_ctp_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n        sampled_ctp_act_time = self.ct_time_dist.sample()\n        patient.ctp_duration = sampled_ctp_act_time\n        # Freeze this function in place for the activity time that was\n        # sampled above.\n        yield self.env.timeout(sampled_ctp_act_time)\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\u27a1\ufe0f Patient {patient.id} finishes CTP scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ctp_act_time:.1f} minutes.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        patient.ctp_scan_end_time = self.env.now\n\n        # Add data to the DF afer the warm up period.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Time with CTP\"] = sampled_ctp_act_time\n\n    # If the CTP pathway is not active the below code runs, it is the same\n    # as the above however adds data to a different column and the patient\n    # advanced CT pathway remains False.\n\n    else:\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\udeab Patient {patient.id} NOT sent on CTP scanner pathway - normal CT scan commencing at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        patient.advanced_ct_pathway = False\n\n        patient.ct_scan_start_time = self.env.now\n\n        # sampled_ct_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n        sampled_ct_act_time = self.ct_time_dist.sample()\n        patient.ct_duration = sampled_ct_act_time\n\n        yield self.env.timeout(sampled_ct_act_time)\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\udeab Patient {patient.id} finishes normal CT scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ct_act_time:.1f} minutes.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        patient.ct_scan_end_time = self.env.now\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Time with CT\"] = sampled_ct_act_time\n\n    # The below code records the status of both the CTP pathway.\n    # Both exist as generators and this data is record to ensure they are\n    # operating as expected.\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"CTP Status\"] = g.ctp_unav\n\n    #############################\n    # MARK: Thrombolysis\n    #############################\n    # The below code checks the patient's attributes to see if the\n    # thrombolysis attribute should be changed to True, this is based off\n    # the patient diagnosis, onset type and mrs type. There are different\n    # conditions depending on if CTP is available or not.\n\n    if (\n        patient.patient_diagnosis == 1\n        and patient.onset_type == 0\n        and patient.mrs_type &gt; 0\n    ):\n        patient.thrombolysis = True\n\n    elif (\n        patient.patient_diagnosis == 1\n        and patient.onset_type == 1\n        and patient.advanced_ct_pathway == True\n        and patient.mrs_type &gt; 0\n    ):\n        patient.thrombolysis = True\n        self.additional_thrombolysis_from_ctp += 1\n\n    else:\n        patient.thrombolysis = False\n\n    # Thrombolysis status is added to the DF, this is mainly used to check\n    # if it is being applied correctly.\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Thrombolysis\"] = patient.thrombolysis\n\n    #########################\n    # MARK: SDEC Admission\n    #########################\n\n    # The below code records the status of both the SDEC pathway.\n    # Both exist as generators and this data is recorded to ensure they are\n    # operating as expected.\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"SDEC Status\"] = g.sdec_unav\n\n    # The if statement below checks if the SDEC pathway is active at this\n    # given time and if there is space in the SDEC itself.\n\n    if g.sdec_unav:\n        patient.sdec_running_when_required = False\n        patient.sdec_full_when_required = False\n    else:\n        patient.sdec_running_when_required = True\n\n        if len(self.sdec_occupancy) &lt; g.sdec_beds:\n            patient.sdec_full_when_required = False\n        else:\n            patient.sdec_full_when_required = True\n\n    # Branch for if SDEC is available\n    # SR: Note that I have changed the check from &lt;= to &lt; (so that patients\n    # are only allowed to request a bed when a bed is free)\n    if g.sdec_unav == False and len(self.sdec_occupancy) &lt; g.sdec_beds:\n        # If the conditions above are met the patient attribute for the\n        # SDEC are changed to True and the patient is added to the SDEC\n        # occupancy list.\n\n        # SR: The request is only necessary here for being able to\n        # determine which bed ends up being used, which we require for\n        # animating it correctly. However, we still need to hold it for the\n        # duration of this code block so that someone else doesn't end up\n        # in the same bed!\n        with self.sdec_bed.request() as req:\n            sdec_bed_used = yield req\n            patient.sdec_bed_id = sdec_bed_used.id_attribute\n\n            patient.sdec_admit_time = self.env.now\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udecf\ufe0f\ud83c\udfce\ufe0f Patient {patient.id} admitted to SDEC (occupancy before admission: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds) at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            self.sdec_occupancy.append(patient)\n\n            # The below code record the SDEC Occupancy as the patient passes\n            # this point to ensure it is working as expected.\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"SDEC Occupancy\"] = len(\n                    self.sdec_occupancy\n                )\n\n                self.sdec_occupancy_graph_df.loc[\n                    len(self.sdec_occupancy_graph_df)\n                ] = [\n                    self.env.now,\n                    len(self.sdec_occupancy),\n                    False,\n                ]\n            else:\n                self.sdec_occupancy_graph_df.loc[\n                    len(self.sdec_occupancy_graph_df)\n                ] = [\n                    self.env.now,\n                    len(self.sdec_occupancy),\n                    True,\n                ]\n\n            patient.sdec_pathway = True\n\n            ###########################################################\n            # ADMISSION AVOIDANCE\n            # This code checks if the patient is eligible for admission\n            # avoidance depending on if therapy support is enabled.\n            ###########################################################\n            if g.therapy_sdec == False:\n                if (\n                    patient.patient_diagnosis &lt; 2\n                    and patient.mrs_type &lt; 2\n                    and patient.thrombolysis == False\n                ):\n                    patient.admission_avoidance = True\n\n            elif g.therapy_sdec == True:\n                if (\n                    patient.patient_diagnosis &lt; 2\n                    and patient.mrs_type &lt;= 3\n                    and patient.thrombolysis == False\n                ):\n                    patient.admission_avoidance = True\n            else:\n                patient.admission_avoidance = False\n\n            ##########################################################\n            # Non-admission - non-stroke, TIA and stroke mimic       #\n            ##########################################################\n            # For patients who have TIA, non-stroke or stroke mimic,\n            # they have a high chance of avoiding admission, but this\n            # is not counted in the same way\n\n            if (\n                patient.non_admission &gt;= self.tia_admission_chance\n                and patient.patient_diagnosis == 2\n            ):\n                patient.admission_avoidance = False\n                patient.non_admitted_tia_ns_sm = True\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u21a9\ufe0f TIA Patient {patient.id} avoided admission.\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n            elif (\n                patient.non_admission &gt;= self.stroke_mimic_admission_chance\n                and patient.patient_diagnosis &gt; 2\n            ):\n                patient.admission_avoidance = False\n                patient.non_admitted_tia_ns_sm = True\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u21a9\ufe0f Stroke mimic or non-stroke Patient {patient.id} (diagnosis {patient.diagnosis}) avoided admission.\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n            else:\n                patient.non_admitted_tia_ns_sm = False\n\n            # Calculate SDEC stay time from exponential\n            # sampled_sdec_stay_time = random.expovariate(1.0 / g.mean_n_sdec_time)\n            sampled_sdec_stay_time = self.sdec_time_dist.sample()\n\n            # Add patient SDEC LOS to their patient object\n            patient.sdec_los = sampled_sdec_stay_time\n\n            # Freeze this function in place for the activity time we sampled\n            # above.\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in SDEC for {sampled_sdec_stay_time:.1f} minutes ({(sampled_sdec_stay_time / 60 / 24):.1f} days).\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            yield self.env.timeout(sampled_sdec_stay_time)\n\n            # This code checks if the ward is full, if this is the case the\n            # patient will not be released from the SDEC, thus impeding it use\n\n            if (\n                not patient.admission_avoidance\n                and not patient.non_admitted_tia_ns_sm\n            ):\n                while len(self.ward_occupancy) &gt;= g.number_of_ward_beds:\n                    yield self.env.timeout(1)\n\n            # Once the above code is complete the patient is removed from the\n            # SDEC occupancy list.\n\n            self.sdec_occupancy.remove(patient)\n            patient.sdec_discharge_time = self.env.now\n\n            # Code to record the SDEC stay time in the results DataFrame.\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Time in SDEC\"] = (\n                    sampled_sdec_stay_time\n                )\n\n            # MARK: Discharged from SDEC\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udfce\ufe0f Patient {patient.id} discharged from SDEC at {minutes_to_ampm(int(self.env.now % 1440))} after {patient.sdec_los:.1f} minutes ({(patient.sdec_los / 60 / 24):.1f} days). Occupancy after discharge: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n        ##########################################\n        # MARK: Admission Avoidance cost savings\n        ##########################################\n        # This code add information regarding the patients admission avoidance.\n\n        if patient.admission_avoidance == True and patient.patient_diagnosis &lt; 2:\n            # Update savings value in model results\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Admission Avoidance\"] = (\n                    patient.sdec_pathway\n                )\n\n                last_index = self.results_df[\"SDEC Savings\"].last_valid_index()\n                last_value = self.results_df.loc[last_index, \"SDEC Savings\"]\n                if last_index &gt; 0 and pd.notnull:\n                    self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                        last_value + g.inpatient_bed_cost\n                    )\n\n                else:\n                    self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                        g.inpatient_bed_cost\n                    )\n\n            # Regardless of whether the warm-up has passed, recording in\n            # patient object that this patient's journey was completed\n            patient.exit_time = self.env.now\n            patient.journey_completed = True\n\n            # Patients with a True admission avoidance are added to a list\n            # that is used to calculate the savings from the avoided admissions.\n            if (\n                patient.admission_avoidance == True\n                and patient.patient_diagnosis &lt; 2\n                and self.env.now &gt; g.warm_up_period\n            ):\n                self.admission_avoidance.append(patient)\n\n            # This code exists after the admission avoidance code so they\n            # are not added to the admission avoidance list, as that should\n            # only be for SDEC patients who avoid admission.\n            # This code ensures that these patients get an exit time\n\n            if patient.non_admitted_tia_ns_sm == True:\n                patient.exit_time = self.env.now\n                patient.journey_completed = True\n\n    ###############################################\n    # MARK: SDEC Full or closed\n    # Branch of logic for if SDEC is not available\n    ###############################################\n    else:\n        patient.sdec_pathway = False\n\n        # If SDEC not available, we will see some % of TIA and ED patients be returned\n        # to ED at this stage (i.e. outside of the modelled part of the system) and they\n        # won't be seen again.\n        if (\n            patient.non_admission &gt;= self.tia_admission_chance\n            and patient.patient_diagnosis == 2\n        ):\n            patient.admission_avoidance = False\n            patient.non_admitted_tia_ns_sm = True\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u21a9\ufe0f TIA Patient {patient.id} avoided admission.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n        elif (\n            patient.non_admission &gt;= self.stroke_mimic_admission_chance\n            and patient.patient_diagnosis &gt; 2\n        ):\n            patient.admission_avoidance = False\n            patient.non_admitted_tia_ns_sm = True\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u21a9\ufe0f Stroke mimic or non-stroke Patient {patient.id} (diagnosis {patient.diagnosis}) avoided admission.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n        else:\n            patient.non_admitted_tia_ns_sm = False\n\n        if patient.non_admitted_tia_ns_sm == True:\n            patient.exit_time = self.env.now\n            patient.journey_completed = True\n\n    #####################################################################\n    # MARK: Ward Admission\n    # once all the above code has been run all patients who will not admit\n    # have a True admission avoidance attribute. For all the patients that\n    # remain false, the below code will run simulating the admission to the\n    # ward.\n    ############################################################################\n\n    # TODO: sampled ward activity time is done after a bed is obtained.\n    # TODO: this is what is recorded as LOS within the model, but arguably\n    # the 'TRUE' LOS is therefore longer in the model as\n    # or is LOS in these cases sampled from stroke ward LOS only?\n    # is LOS increased by spending time on an 'inappropriate' ward in the\n    # real world, and if so, does this need to be reflected here?\n\n    if not patient.admission_avoidance and not patient.non_admitted_tia_ns_sm:\n        # Anyone who has made it to here has definitely not avoided admission\n        patient.admission_avoidance = False\n\n        # These code assigns a time to the start q variable. In stroke care\n        # delays can have serious consequence so modeling this is very\n        # important as flow disruption are a common issue.\n\n        start_q_ward = self.env.now\n        patient.ward_q_start_time = self.env.now\n\n        # Request the ward bed and hold the patient in a queue until this\n        # is met.\n\n        with self.ward_bed.request() as req:\n            ward_bed_used = yield req\n            patient.ward_bed_id = ward_bed_used.id_attribute\n            # Add patient to the ward list\n\n            self.ward_occupancy.append(patient)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udecf\ufe0f Patient {patient.id} admitted to main ward at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy after admission: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            patient.ward_admit_time = self.env.now\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Ward Occupancy\"] = len(\n                    self.ward_occupancy\n                )\n\n            if self.env.now &gt; g.warm_up_period:\n                self.ward_occupancy_graph_df.loc[\n                    len(self.ward_occupancy_graph_df)\n                ] = [\n                    self.env.now,\n                    len(self.ward_occupancy),\n                    False,\n                ]\n            else:\n                self.ward_occupancy_graph_df.loc[\n                    len(self.ward_occupancy_graph_df)\n                ] = [\n                    self.env.now,\n                    len(self.ward_occupancy),\n                    True,\n                ]\n\n            # The patient attribute for the queuing time in the ward is\n            # assigned here.\n\n            end_q_ward = self.env.now\n\n            patient.q_time_ward = end_q_ward - start_q_ward\n\n            # The below code checks the patients diagnosis and MRS,\n            # adjusting MRS change and LOS baised on these. This code is\n            # for ICH patients.\n\n            ###############################\n            # MARK: Patient diagnosis = 0 #\n            # Intracerebral haemorrhage   #\n            # Unsuitable for thrombolysis #\n            ###############################\n\n            if patient.patient_diagnosis == 0 and patient.mrs_type == 0:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_ich_ward_time_mrs_0\n                # )\n                sampled_ward_act_time = self.ich_ward_time_mrs_0_dist.sample()\n                patient.mrs_discharge = patient.mrs_type\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 1:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_ich_ward_time_mrs_1\n                # )\n                sampled_ward_act_time = self.ich_ward_time_mrs_1_dist.sample()\n                # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                patient.mrs_discharge = (\n                    patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                )\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 2:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_ich_ward_time_mrs_2\n                # )\n                sampled_ward_act_time = self.ich_ward_time_mrs_2_dist.sample()\n                # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                patient.mrs_discharge = (\n                    patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                )\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 3:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_ich_ward_time_mrs_3\n                # )\n                sampled_ward_act_time = self.ich_ward_time_mrs_3_dist.sample()\n                # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                patient.mrs_discharge = (\n                    patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                )\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 4:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_ich_ward_time_mrs_4\n                # )\n                sampled_ward_act_time = self.ich_ward_time_mrs_4_dist.sample()\n                # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                patient.mrs_discharge = (\n                    patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                )\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 5:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_ich_ward_time_mrs_5\n                # )\n                sampled_ward_act_time = self.ich_ward_time_mrs_5_dist.sample()\n                # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                patient.mrs_discharge = (\n                    patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                )\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            ###############################\n            # MARK: Patient diagnosis = 1 #\n            # Ischaemic Stroke            #\n            # Some may be suitable for    #\n            # thrombolysis                #\n            ###############################\n\n            # The below code checks the patients diagnosis and MRS,\n            # adjusting MRS change and LOS baised on these. This code is\n            # for I patients amd also checks for thrombolysis and adjusts\n            # LOS and associated savings accordingly.\n\n            if patient.patient_diagnosis == 1 and patient.mrs_type == 0:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_i_ward_time_mrs_0\n                # )\n                sampled_ward_act_time = self.i_ward_time_mrs_0_dist.sample()\n                patient.mrs_discharge = patient.mrs_type\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 1:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_i_ward_time_mrs_1\n                # )\n                sampled_ward_act_time = self.i_ward_time_mrs_1_dist.sample()\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n                else:\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 2:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_i_ward_time_mrs_2\n                # )\n                sampled_ward_act_time = self.i_ward_time_mrs_2_dist.sample()\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    patient.mrs_discharge = (\n                        patient.mrs_type\n                        - self.mrs_reduction_during_stay_thrombolysed.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n                else:\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 3:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_i_ward_time_mrs_3\n                # )\n                sampled_ward_act_time = self.i_ward_time_mrs_3_dist.sample()\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    patient.mrs_discharge = (\n                        patient.mrs_type\n                        - self.mrs_reduction_during_stay_thrombolysed.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n                else:\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 4:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_i_ward_time_mrs_4\n                # )\n                sampled_ward_act_time = self.i_ward_time_mrs_4_dist.sample()\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    patient.mrs_discharge = (\n                        patient.mrs_type\n                        - self.mrs_reduction_during_stay_thrombolysed.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n                else:\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 5:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_i_ward_time_mrs_5\n                # )\n                sampled_ward_act_time = self.i_ward_time_mrs_5_dist.sample()\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    patient.mrs_discharge = (\n                        patient.mrs_type\n                        - self.mrs_reduction_during_stay_thrombolysed.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    # Record generated LOS in patient object\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n                else:\n                    # patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    patient.mrs_discharge = (\n                        patient.mrs_type - self.mrs_reduction_during_stay.sample()\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    # Record generated LOS in patient object\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    patient.ward_discharge_time = self.env.now\n                    self.ward_occupancy.remove(patient)\n\n            #################################\n            # MARK: Patient diagnosis = 2   #\n            # Transient Ischaemic Attack    #\n            # Not suitable for thrombolysis #\n            #################################\n            # The below code is for the non stroke diagnosis.\n\n            if patient.patient_diagnosis == 2:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_tia_ward_time\n                # )\n                sampled_ward_act_time = self.tia_ward_time_dist.sample()\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                # Record generated LOS in patient object\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n            ###############################\n            # MARK: Patient diagnosis &gt; 2 #\n            # Stroke mimic OR non-stroke  #\n            ###############################\n            if patient.patient_diagnosis &gt; 2:\n                # sampled_ward_act_time = random.expovariate(\n                #     1.0 / g.mean_n_non_stroke_ward_time\n                # )\n                sampled_ward_act_time = self.non_stroke_ward_time_dist.sample()\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n                # Record generated LOS in patient object\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                patient.ward_discharge_time = self.env.now\n                self.ward_occupancy.remove(patient)\n\n        # Relevent information is recorded in the results DataFrame.\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Q Time Ward\"] = patient.q_time_ward\n\n        # TODO: SR: I've tweaked this to take whichever of the ward_los or thrombolysis los is generated\n        # TODO SR: It would be better to take a more robust approach to this step.\n        try:\n            final_ward_los = sampled_ward_act_time\n        except:\n            final_ward_los = sampled_ward_act_time_thrombolysis\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Ward LOS\"] = final_ward_los\n\n            self.results_df.at[patient.id, \"MRS DC\"] = patient.mrs_discharge\n\n            self.results_df.at[patient.id, \"MRS Change\"] = (\n                patient.mrs_type - patient.mrs_discharge\n            )\n\n        # MARK: Discharged from main ward\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\ude97 Patient {patient.id} discharged from main ward at {minutes_to_ampm(int(self.env.now % 1440))} after {final_ward_los:.1f} minutes ({(final_ward_los / 24 / 60):.1f} days). Occupancy after discharge: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        patient.exit_time = self.env.now\n        patient.journey_completed = True\n\n    # Record patients who exited at any remaining points\n    patient.exit_time = self.env.now\n    patient.journey_completed = True\n</code></pre>"},{"location":"model/#stroke_ward_model.model.Model.track_days","title":"<code>track_days()</code>","text":"<p>A SimPy process that logs the progression of simulation days.</p> <p>This generator functions as a background 'clock' process. It wakes up at the start of every 1440-minute interval (24 hours) to output a formatted debug message indicating the current day of the simulation run. This helps track progress in the console during long-running simulations.</p> <ul> <li>The day calculation is performed using floor division:   <code>self.env.now // 1440</code>.</li> <li>The trace message visibility depends on the <code>g.show_trace</code> flag and   the <code>g.tracked_cases</code> configuration.</li> <li>This process runs concurrently with patient arrivals and clinical   obstructions without interfering with their logic.</li> </ul> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/model.py</code> <pre><code>def track_days(self):\n    \"\"\"\n    A SimPy process that logs the progression of simulation days.\n\n    This generator functions as a background 'clock' process. It wakes up\n    at the start of every 1440-minute interval (24 hours) to output a\n    formatted debug message indicating the current day of the simulation\n    run. This helps track progress in the console during long-running\n    simulations.\n\n    - The day calculation is performed using floor division:\n      `self.env.now // 1440`.\n    - The trace message visibility depends on the `g.show_trace` flag and\n      the `g.tracked_cases` configuration.\n    - This process runs concurrently with patient arrivals and clinical\n      obstructions without interfering with their logic.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # Print a debugging message every day\n    while self.env.now &lt;= g.sim_duration:\n        # TODO: this doesn't always reliably appear depending on number of tracked cases\n        trace(\n            msg=f\"========= DAY {(self.env.now // 1440):.0f} ===============\",\n            time=self.env.now,\n            debug=g.show_trace,\n            identifier=max(g.tracked_cases),\n            config=g.trace_config,\n        )\n        yield self.env.timeout(1440)\n</code></pre>"},{"location":"pathway_diagram/","title":"Pathway Diagram","text":"<pre><code>flowchart TB\n    A[\"In-hours admissions &lt;br&gt;&lt;br&gt;Default 7am to 12 midnight\"] --&gt; n12[\"Patient Generated\"]\n    B[\"Nurse Triage\"] --&gt; C([\"Is the CT perfusion (CTP) scanner open?\"])\n    C -- Yes --&gt; n2[\"CTP Scan &lt;br&gt;(Advanced Scan)\"]\n    C -- No --&gt; n3[\"CT Scan\"]\n    n2 --&gt; n4([\"Patient has Ischaemic Stroke &lt;br&gt;&lt;b&gt;&lt;i&gt;AND &lt;/i&gt;&lt;/b&gt;MRS is 1 or above&lt;br&gt;&lt;br&gt;&lt;b&gt;AND onset time is known&lt;/b&gt;&lt;br&gt;OR onset time unknown but it is found that onset is &lt;br&gt;recent enough for thrombolysis to be effective\"])\n    n2 --&gt; n18([\"Patient has ICH&lt;br&gt;&lt;b&gt;OR &lt;/b&gt;MRS is 0&lt;br&gt;&lt;br&gt;&lt;b&gt;OR &lt;/b&gt;Onset time not known &lt;br&gt;&lt;b&gt;&lt;i&gt;AND&lt;/i&gt;&lt;/b&gt; it is found that too much time has passed &lt;br&gt;for thrombolysis to be effective&lt;br&gt;\"])\n    n2 --&gt; n19([\"Patient has a TIA, stroke mimic or no stroke&lt;br&gt;\"])\n    n5([\"Patient has Ischaemic Stroke&lt;br&gt;&lt;b&gt;AND&lt;/b&gt; MRS is 1 or above &lt;br&gt;&lt;b&gt;AND&lt;/b&gt; onset time is known\"])\n    n26([\"Patient has ICH&lt;br&gt;&lt;b&gt;OR&lt;/b&gt; MRS is 0&lt;br&gt;&lt;b&gt;OR &lt;/b&gt;Onset time not known&lt;br&gt;\"])\n    n3 --&gt; n5\n    n3 --&gt; n19\n    n3 --&gt; n26\n    n6([\"Is SDEC open?\"]) -- Yes --&gt; n7([\"Is a bed available in SDEC?\"])\n    n7 -- Yes --&gt; n8[\"Admit to SDEC\"]\n    n6 -- No --&gt; n30([\"SDEC bed unavailable for any reason\"])\n    n9[\"Admit to Ward&lt;br&gt;&lt;br&gt;LOS generated based on diagnosis and MRS\"] -.-&gt; n11[\"Discharge\"]\n    n8 --&gt; n20([\"Is therapy available in SDEC?\"])\n    n1[\"Out-of-hours admissions (less frequent)&lt;br&gt;&lt;br&gt;Default 12 midnight to 7am\"] --&gt; n12\n    n12 --&gt; B\n    n12 -.- n13[\"&lt;b&gt;Modified Rankin Scale Score on Presentation &lt;br&gt;&lt;/b&gt;&lt;br&gt;0 least disabled&lt;br&gt;5 most disabled&lt;br&gt;6 (dead) not modelled\"]\n    n12 -.- n14[\"&lt;b&gt;Stroke Onset Type&lt;br&gt;&lt;/b&gt;&lt;br&gt;Known&lt;br&gt;&lt;b&gt;OR&lt;/b&gt; Unknown but in CTP window&lt;br&gt;&lt;b&gt;OR&lt;/b&gt; unknown and outside CTP window&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;i&gt;ADJUSTED FOR IN/OUT OF HOURS PRESENTATION&lt;/i&gt;&lt;/b&gt;\"]\n    n15[\"&lt;b&gt;Patient Diagnosis&lt;br&gt;&lt;/b&gt;&lt;br&gt;Intracerebral Haemorrhage&lt;br&gt;&lt;b&gt;OR&lt;/b&gt; Ischaemic Stroke&lt;br&gt;&lt;b&gt;OR&lt;/b&gt; Transient Ischaemic Attack&lt;br&gt;&lt;b&gt;OR&lt;/b&gt; Stroke Mimic&lt;br&gt;&lt;b&gt;OR&lt;/b&gt; Non-Stroke\"] -.- n12\n    n16[\"Triage Priority &lt;br&gt;&lt;br&gt;Not currently used\"] -.- n12\n    n4 --&gt; n17[\"Thrombolyse&lt;br&gt;&lt;br&gt;Reduces LOS by a defined factor (but must be monitored for at least 24 hours)\"]\n    n5 --&gt; n17\n    n17 --&gt; n6\n    n18 --&gt; n6\n    n20 -- \"No\" --&gt; n21([\"Patient has Ischaemic Stroke or ICH&lt;br&gt;&lt;b&gt;AND &lt;/b&gt;MRS is 0 or 1&lt;b&gt;&lt;br&gt;AND &lt;/b&gt;patient was &lt;b&gt;not&lt;/b&gt; thrombolysed\"])\n    n20 -- \"Yes\" --&gt; n22([\"Patient has Ischaemic Stroke or ICH&lt;br&gt;&lt;b&gt;AND &lt;/b&gt;MRS is 0, 1 or 2&lt;br&gt;&lt;b&gt;AND &lt;/b&gt;patient was &lt;b&gt;not&lt;/b&gt; thrombolysed\"])\n    n21 -- \"Yes\" --&gt; n23[\"Avoided Admission\"]\n    n21 -- \"No\" --&gt; n25[\"Admission Not Avoided\"]\n    n22 -- \"Yes\" --&gt; n23\n    n23 -.-&gt; n11\n    n22 -- \"No\" --&gt; n25\n    n26 --&gt; n6\n    n19 --&gt; n6\n    n30 -- &lt;br&gt; --&gt; n27([\"Patient has ICH or Ischaemic Stroke\"])\n    n30 --&gt; n28([\"Patient has TIA\"])\n    n30 --&gt; n29([\"Patient has stroke mimic or no stroke\"])\n    n28 -- \"10% chance patient will be admitted to stroke ward\" --&gt; n9\n    n28 -. \"90% chance patient will return to ED (outside of bounds of this model)\" .-&gt; n11\n    n27 --&gt; n9\n    n29 -- \"30% chance patient will be admitted to stroke ward\" --&gt; n9\n    n29 -. \"70% patient will return to ED (outside of bounds of this model)\" .-&gt; n11\n    n7 -- \"No\" --&gt; n30\n    n25 --&gt; n27\n    n25 --&gt; n28\n    n25 --&gt; n29\n\n    style C fill:#FFF9C4\n    style n4 fill:#FFF9C4\n    style n18 fill:#FFF9C4\n    style n19 fill:#FFE0B2\n    style n5 fill:#FFF9C4\n    style n26 fill:#FFF9C4\n    style n6 fill:#FFF9C4\n    style n7 fill:#FFF9C4\n    style n30 fill:#FFF9C4\n    style n11 fill:#DD4040\n    style n20 fill:#FFF9C4\n    style n13 fill:#E1BEE7\n    style n14 fill:#E1BEE7\n    style n15 fill:#E1BEE7\n    style n16 fill:#E1BEE7\n    style n17 fill:#BBDEFB\n    style n21 fill:#FFF9C4\n    style n22 fill:#FFF9C4\n    style n23 fill:#C8E6C9\n    style n25 fill:#FFCDD2\n    style n27 fill:#FFF9C4\n    style n28 fill:#FFE0B2\n    style n29 fill:#FFE0B2\n    linkStyle 6 stroke:#FF6D00,fill:none\n    linkStyle 8 stroke:#FF6D00,fill:none\n    linkStyle 21 stroke:#2962FF,fill:none\n    linkStyle 22 stroke:#2962FF,fill:none\n    linkStyle 23 stroke:#2962FF,fill:none\n    linkStyle 33 stroke:#FF6D00,fill:none\n    linkStyle 34 stroke:#000000,fill:none\n    linkStyle 35 stroke:#FF6D00,fill:none\n    linkStyle 36 stroke:#FF6D00,fill:none\n    linkStyle 37 stroke:#FF6D00,fill:none\n    linkStyle 38 stroke:#FF6D00,fill:none\n    linkStyle 40 stroke:#FF6D00,fill:none\n    linkStyle 41 stroke:#FF6D00,fill:none\n</code></pre>"},{"location":"patient/","title":"Reference","text":"<p>Representation of an individual patient within the simulation.</p> <p>A <code>Patient</code> object stores all clinical, pathway, and state-related attributes required for modelling flow through the stroke care process.</p> <p>Several characteristics (onset type, MRS score, diagnosis category, admission likelihood) are randomly generated on creation (or at the start of assessment) using parameters defined in the global configuration class <code>g</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p_id</code> <code>int or str</code> <p>Unique identifier for the patient.</p> required <p>Attributes:</p> Name Type Description <code>id</code> <code>int or str</code> <p>Patient identifier.</p> <code>q_time_nurse</code> <code>float</code> <p>Time spent waiting for nursing assessment or consultation.</p> <code>q_time_ward</code> <code>float</code> <p>Time spent waiting for an inpatient ward bed.</p> <code>onset_type</code> <code>int or float</code> <p>Categorisation of onset information (initialized as NaN): - 0 : Known onset - 1 : Unknown onset but within CTP window - 2 : Unknown onset and outside CTP window</p> <code>mrs_type</code> <code>int or float</code> <p>Modified Rankin Scale score at presentation (0\u20135). Drawn from an exponential distribution and capped at 5.</p> <code>mrs_discharge</code> <code>int or float</code> <p>Modified Rankin Scale score at discharge.</p> <code>diagnosis</code> <code>int or float</code> <p>Raw randomised diagnostic value (0\u2013100). Used to map to a clinical category based on thresholds defined in <code>g</code>.</p> <code>patient_diagnosis</code> <code>int or float</code> <p>Encoded diagnosis category: - 0 : Intracerebral haemorrhage (ICH) - 1 : Ischaemic stroke (I) - 2 : Transient ischaemic attack (TIA) - 3 : Stroke mimic - 4 : Non-stroke</p> <code>patient_diagnosis_type</code> <code>str or None</code> <p>String representation or specific subtype of the diagnosis.</p> <code>priority</code> <code>int</code> <p>Triage priority level (used for queue ordering). Default is 1.</p> <code>non_admission</code> <code>int or float</code> <p>Randomised admission likelihood score (0\u2013100).</p> <code>advanced_ct_pathway</code> <code>bool or None</code> <p>Whether the patient enters an advanced CT imaging pathway.</p> <code>sdec_pathway</code> <code>bool or None</code> <p>Whether the patient is routed through SDEC.</p> <code>thrombolysis</code> <code>bool or None</code> <p>Whether the patient receives thrombolysis.</p> <code>thrombectomy</code> <code>bool or None</code> <p>Whether the patient receives thrombectomy.</p> <code>admission_avoidance</code> <code>bool or None</code> <p>Whether the patient avoids an admission by being seen in SDEC instead.</p> <code>non_admitted_tia_ns_sm</code> <code>bool or None</code> <p>Flag indicating if a TIA, Non-Stroke, or Stroke Mimic patient was not admitted.</p> <code>ward_los</code> <code>float</code> <p>Total length of stay in the ward.</p> <code>ward_los_thrombolysis</code> <code>float</code> <p>Specific length of stay component related to thrombolysis treatment.</p> <code>sdec_los</code> <code>float</code> <p>Total length of stay in the Same Day Emergency Care (SDEC) unit.</p> <code>ctp_duration</code> <code>float</code> <p>Time taken for CT Perfusion scan.</p> <code>ct_duration</code> <code>float</code> <p>Time taken for standard CT scan.</p> <code>arrived_ooh</code> <code>bool or None</code> <p>Flag indicating if the patient arrived Out of Hours.</p> <code>clock_start</code> <code>float</code> <p>Simulation time of patient arrival.</p> <code>nurse_q_start_time</code> <code>float</code> <p>Time patient joined the nurse queue.</p> <code>nurse_triage_start_time</code> <code>float</code> <p>Time nurse triage began.</p> <code>nurse_triage_end_time</code> <code>float</code> <p>Time nurse triage finished.</p> <code>ct_scan_start_time</code> <code>float</code> <p>Time CT scan began.</p> <code>ctp_scan_start_time</code> <code>float</code> <p>Time CTP scan began.</p> <code>ct_scan_end_time</code> <code>float</code> <p>Time CT scan finished.</p> <code>ctp_scan_end_time</code> <code>float</code> <p>Time CTP scan finished.</p> <code>sdec_admit_time</code> <code>float</code> <p>Time admitted to SDEC.</p> <code>sdec_discharge_time</code> <code>float</code> <p>Time discharged from SDEC.</p> <code>ward_q_start_time</code> <code>float</code> <p>Time patient joined the ward bed queue.</p> <code>ward_admit_time</code> <code>float</code> <p>Time admitted to the ward.</p> <code>ward_discharge_time</code> <code>float</code> <p>Time discharged from the ward.</p> <code>exit_time</code> <code>float</code> <p>Time the patient left the simulation entirely.</p> <code>nurse_attending_id</code> <code>int or float</code> <p>ID of the specific nurse resource assigned.</p> <code>ct_scanner_id</code> <code>int or float</code> <p>ID of the specific CT scanner resource assigned.</p> <code>sdec_bed_id</code> <code>int or float</code> <p>ID of the specific SDEC bed/cubicle assigned.</p> <code>ward_bed_id</code> <code>int or float</code> <p>ID of the specific ward bed assigned.</p> <code>sdec_running_when_required</code> <code>bool or None</code> <p>State of SDEC availability when the patient needed it.</p> <code>sdec_full_when_required</code> <code>bool or None</code> <p>State of SDEC capacity when the patient needed it.</p> <code>generated_during_warm_up</code> <code>bool or None</code> <p>Flag indicating if the patient was generated during the model warm-up period.</p> <code>journey_completed</code> <code>bool or None</code> <p>Flag indicating if the patient completed the full pathway or was removed/processed differently.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of ChatGPT 5.1 and subsequently updated by Gemini to reflect code changes. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/entities.py</code> <pre><code>class Patient:\n    \"\"\"\n    Representation of an individual patient within the simulation.\n\n    A `Patient` object stores all clinical, pathway, and state-related\n    attributes required for modelling flow through the stroke care\n    process.\n\n    Several characteristics (onset type, MRS score, diagnosis\n    category, admission likelihood) are randomly generated on creation\n    (or at the start of assessment) using parameters defined in the global\n    configuration class `g`.\n\n    Parameters\n    ----------\n    p_id : int or str\n        Unique identifier for the patient.\n\n    Attributes\n    ----------\n    id : int or str\n        Patient identifier.\n    q_time_nurse : float\n        Time spent waiting for nursing assessment or consultation.\n    q_time_ward : float\n        Time spent waiting for an inpatient ward bed.\n    onset_type : int or float\n        Categorisation of onset information (initialized as NaN):\n        - 0 : Known onset\n        - 1 : Unknown onset but within CTP window\n        - 2 : Unknown onset and outside CTP window\n    mrs_type : int or float\n        Modified Rankin Scale score at presentation (0\u20135).\n        Drawn from an exponential distribution and capped at 5.\n    mrs_discharge : int or float\n        Modified Rankin Scale score at discharge.\n    diagnosis : int or float\n        Raw randomised diagnostic value (0\u2013100). Used to map to a clinical\n        category based on thresholds defined in `g`.\n    patient_diagnosis : int or float\n        Encoded diagnosis category:\n        - 0 : Intracerebral haemorrhage (ICH)\n        - 1 : Ischaemic stroke (I)\n        - 2 : Transient ischaemic attack (TIA)\n        - 3 : Stroke mimic\n        - 4 : Non-stroke\n    patient_diagnosis_type : str or None\n        String representation or specific subtype of the diagnosis.\n    priority : int\n        Triage priority level (used for queue ordering). Default is 1.\n    non_admission : int or float\n        Randomised admission likelihood score (0\u2013100).\n    advanced_ct_pathway : bool or None\n        Whether the patient enters an advanced CT imaging pathway.\n    sdec_pathway : bool or None\n        Whether the patient is routed through SDEC.\n    thrombolysis : bool or None\n        Whether the patient receives thrombolysis.\n    thrombectomy : bool or None\n        Whether the patient receives thrombectomy.\n    admission_avoidance : bool or None\n        Whether the patient avoids an admission by being seen in SDEC instead.\n    non_admitted_tia_ns_sm : bool or None\n        Flag indicating if a TIA, Non-Stroke, or Stroke Mimic patient was\n        not admitted.\n    ward_los : float\n        Total length of stay in the ward.\n    ward_los_thrombolysis : float\n        Specific length of stay component related to thrombolysis treatment.\n    sdec_los : float\n        Total length of stay in the Same Day Emergency Care (SDEC) unit.\n    ctp_duration : float\n        Time taken for CT Perfusion scan.\n    ct_duration : float\n        Time taken for standard CT scan.\n    arrived_ooh : bool or None\n        Flag indicating if the patient arrived Out of Hours.\n    clock_start : float\n        Simulation time of patient arrival.\n    nurse_q_start_time : float\n        Time patient joined the nurse queue.\n    nurse_triage_start_time : float\n        Time nurse triage began.\n    nurse_triage_end_time : float\n        Time nurse triage finished.\n    ct_scan_start_time : float\n        Time CT scan began.\n    ctp_scan_start_time : float\n        Time CTP scan began.\n    ct_scan_end_time : float\n        Time CT scan finished.\n    ctp_scan_end_time : float\n        Time CTP scan finished.\n    sdec_admit_time : float\n        Time admitted to SDEC.\n    sdec_discharge_time : float\n        Time discharged from SDEC.\n    ward_q_start_time : float\n        Time patient joined the ward bed queue.\n    ward_admit_time : float\n        Time admitted to the ward.\n    ward_discharge_time : float\n        Time discharged from the ward.\n    exit_time : float\n        Time the patient left the simulation entirely.\n    nurse_attending_id : int or float\n        ID of the specific nurse resource assigned.\n    ct_scanner_id : int or float\n        ID of the specific CT scanner resource assigned.\n    sdec_bed_id : int or float\n        ID of the specific SDEC bed/cubicle assigned.\n    ward_bed_id : int or float\n        ID of the specific ward bed assigned.\n    sdec_running_when_required : bool or None\n        State of SDEC availability when the patient needed it.\n    sdec_full_when_required : bool or None\n        State of SDEC capacity when the patient needed it.\n    generated_during_warm_up : bool or None\n        Flag indicating if the patient was generated during the model warm-up\n        period.\n    journey_completed : bool or None\n        Flag indicating if the patient completed the full pathway or was\n        removed/processed differently.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of ChatGPT 5.1 and subsequently updated by Gemini to reflect code changes.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    _required_fields = [\n        \"arrived_ooh\",\n        \"advanced_ct_pathway\",\n        \"sdec_pathway\",\n        \"thrombolysis\",\n        \"thrombectomy\",\n        \"admission_avoidance\",\n        \"non_admitted_tia_ns_sm\",\n        \"sdec_running_when_required\",\n        \"sdec_full_when_required\",\n        \"generated_during_warm_up\",\n        # Numeric fields\n        \"clock_start\",\n        \"exit_time\",\n    ]\n\n    def __init__(self, p_id):\n        self.id = p_id\n\n        self.q_time_nurse = np.NaN  # SR NOTE - changed this to NaN by default\n        self.q_time_ward = np.NaN  # SR NOTE - changed this to NaN by default\n\n        # 0 = known onset, 1 = unknown onset (in ctp range),\n        # 2 = unknown (out of ctp range)\n        # SR NOTE: I've moved all random generation to the start of their\n        # assessment to allow for reproducibility\n        # self.onset_type = random.randint(0, 2)\n        self.onset_type = np.NaN\n\n        # Max MRS is set to 5\n        # self.mrs_type = min(round(random.expovariate(1.0 / g.mean_mrs)), 5)\n        self.mrs_type = np.NaN\n        self.mrs_discharge = np.NaN  # SR NOTE - changed this to NaN by default\n\n        # &lt;=5 is ICH, &lt;=55 is I, &lt;= 70 is TIA, &lt;=85 is Stroke Mimic, &gt;85 is\n        # non\\stroke, this set in g class\n        # TODO: SR: This comment does not appear to be in sync with actual\n        # values seen in the g class\n        # TODO: SR: Which is correct?\n        # self.diagnosis = random.randint(0, 100)\n        self.diagnosis = np.NaN\n        # 0 = ICH, 1 = I, 2 = TIA, 3 = Stroke Mimic, 4 = non stroke\n        self.patient_diagnosis = np.NaN  # SR NOTE - changed this to NaN by default\n        self.patient_diagnosis_type = \"None\"\n\n        self.priority = 1\n        # self.non_admission = random.randint(0, 100)\n        self.non_admission = np.NaN\n\n        self.advanced_ct_pathway = None\n        self.sdec_pathway = None\n\n        self.thrombolysis = None\n        self.thrombectomy = None\n\n        self.admission_avoidance = None\n        self.non_admitted_tia_ns_sm = None\n\n        # NOTE: Additional items added by SR\n        self.ward_los = np.NaN\n        self.ward_los_thrombolysis = np.NaN\n        self.sdec_los = np.NaN\n        self.ctp_duration = np.NaN\n        self.ct_duration = np.NaN\n\n        self.arrived_ooh = None\n\n        # Recording times of various events for animations and process logs\n        self.clock_start = np.NaN  # This can be considered to be their arrival time\n\n        self.nurse_q_start_time = np.NaN\n        self.nurse_triage_start_time = np.NaN\n        self.nurse_triage_end_time = np.NaN\n\n        self.ct_scan_start_time = np.NaN\n        self.ct_scan_end_time = np.NaN\n\n        self.ctp_scan_start_time = np.NaN\n        self.ctp_scan_end_time = np.NaN\n\n        self.sdec_running_when_required = None\n        self.sdec_full_when_required = None\n\n        self.sdec_admit_time = np.NaN\n        self.sdec_discharge_time = np.NaN\n\n        self.ward_q_start_time = np.NaN\n        self.ward_admit_time = np.NaN\n        self.ward_discharge_time = np.NaN\n        self.exit_time = np.NaN\n\n        self.nurse_attending_id = np.NaN\n        self.ct_scanner_id = np.NaN\n        self.sdec_bed_id = np.NaN\n        self.ward_bed_id = np.NaN\n\n        self.generated_during_warm_up = None\n\n        # Flag for optionally removing incomplete journeys or processing them\n        # in a different way in results\n        # Note that unlike other booleans defined in the patient object,\n        # we have defaulted this to False intentionally\n        self.journey_completed = False\n\n    def _is_unset(self, value):\n        if value is None:\n            return True\n        try:\n            return np.isnan(value)\n        except TypeError:\n            return False\n\n    def validate(self):\n        missing = [\n            field\n            for field in self._required_fields\n            if self._is_unset(getattr(self, field))\n        ]\n\n        if missing:\n            raise ValueError(\n                f\"Patient validation failed.\\n\"\n                f\"Missing fields: {missing}\\n\\n\"\n                f\"Full object state:\\n{self}\"\n            )\n\n    def __repr__(self):\n        attrs = vars(self)\n        return \"\\n\".join(f\"{k}: {v}\" for k, v in attrs.items())\n</code></pre>"},{"location":"running_locally/","title":"Running the model locally","text":""},{"location":"running_locally/#environment-setup","title":"Environment setup","text":"<p>Install the environment using <code>requirements.txt</code> or <code>environment.yml</code> (tested with Python 3.12.10), found in the <code>environment/</code> folder.</p> <p>This should automatically install the model code. If you receive errors about <code>stroke_ward_model</code> not being found in the environment you created then run: <code>pip install -e .</code></p> <p>Note: Legacy environments are also available in <code>win_environment/</code> and <code>mac_environment/</code>, but it is recommended that you use those provided in <code>environment/</code>.</p>"},{"location":"running_locally/#running-the-model","title":"Running the model","text":"<p>To run the model via a script, with prompts for input variables, run the file <code>scripts/run_stroke_admission_model.py</code>.</p>"},{"location":"running_locally/#web-app","title":"Web app","text":"<p>It is possible to run the model via a script, but for easy access to model parameters and all results tables and outputs, it is recommended to use the web app interface.</p> <p>The hosted web app is available at stroke-des.streamlit.app/.</p> <p>If you are unable to install Python code locally, you can use this free hosted version of the app, though note it may run more slowly.</p> <p>Click here to access the hosted version of the web app</p> <p>To run the web app locally, you will need to install a separate environment provided in the <code>app/</code> folder. This is a reduced environment used by the hosted version of the web app on Streamlit Community Cloud. It does not install <code>mkdocs</code>, <code>pytest</code>, and other packages needed only for wider repository tasks. This <code>app/</code> environment must be manually updated whenever changes are made to the files in <code>environment/</code>.</p> <p>Once the environment is installed, open a terminal in the root of the repository and run:</p> <pre><code>streamlit run app/streamlit_app.py\n</code></pre>"},{"location":"stress_des/","title":"Stress DES Checklist","text":"<p>This table is auto-generated from <code>checklists/stress_des.xlsx</code>.</p> Section/Subsection Item Recommendation Details 1. \u00a0  Objectives Purpose of the model 1.1 Explain the background and objectives for the model. The prevalence of strokes in the UK is on the increase, with some forecasts putting these increases at 60% between 2015 and 2035. As the number of stroke patients nationally rises the pressure on the already resourced stretched NHS will rise.In stroke care time critical interventions are key, patients need to be in the right place and within the correct time frames to receive treatment. Maintaining efficient flow from the ambulance to ED to the stroke unit itself is essential to meet these time critical interventions and the following monitoring.Flow is not only vital for early interventions but also for the stroke unit\u2019s workforce. A ward with higher occupancy puts pressure on the unit's medical, nursing and therapy staff. Higher ward occupancy leads to lowering staff patient ratios when staffing levels remain the same, reducing the quality of care and therapy input per patient.The purpose of this model is to assess the effect of changing variables on stroke unit flow and occupancy, to simulate different approaches to address the increasing pressure all stroke units in the UK will face in the coming years. The models key areas of focus are on the number of beds a ward possesses, the utilisation of the CT perfusion and the stroke SDEC model developed and currently operational at Maidstone Hospital.There is also a large focus on the financial savings generated from utilising CT perfusion and a stroke SDEC model, as both require an upfront investment, however are inherently cost saving through bed days saved. The secondary purpose of the model is to show that not only is the utilisation of CTP and stroke SDEC beneficial to patient flow and ward occupancy but also cost saving. Model Outputs 1.2 Define all quantitative performance measures that are reported, using equations where necessary.\u00a0 Specify how and when they are calculated during the model run along with how any measures of error such as confidence intervals are calculated. Number of Admissions Avoided : The number of patients within the simulation who are assigned a diagnosis of stroke, patient admission_avoidance = TRUE and an MRS value below the threshold set in the model. This is to simulate the same day discharge process of the Stroke SDEC, with patients meeting the criteria being able to avoid a stroke unit overnight stay while still receiving the same care.Mean Q Time Ward (Hours) : The mean time that passes in the simulation between patients requesting the ward bed resource and it being made available for them.Mean Ward Occupancy : The mean number of patients that are on the \u201cWard Occupancy List\u201d at each point a patient either is added to or leave the list.Total Number of Admission Delays : A sum of all patients who could not immediately be assigned a stroke bed in the simulation when it is requested.SDEC Total Savings (\u00a3) : The sum of the patients whose attributes for \u201cAdmission Avoidance\u201d are TRUE at the end of the simulation multiplied by the value stored in the g class for the cost of an overnight hyper acute bed.SDEC Medical Cost (\u00a3) : The sum of each simpy time value elapsed while the SDEC generator is set to FALSE multiplied the value of the \u201csdec_dr_cost_min\u201dSDEC Saving \u2013 Cost (\u00a3) : The value of SDEC Total Savings \u2013 SDEC Medical CostsThrombolysis Savings (\u00a3) : Each patient in the simulation that requests a ward bed will be assigned a \u201csampled_ward_act_time\u201d which is sampled from an exponential distribution based on the values in class g. If a patient\u2019s thrombolysis Boolean is TRUE the \u201csampled_ward_act_time\u201d will reduce by 25% and the difference between the original \u201csampled_ward_act_time\u201d and the new \u201csampled_ward_act_time_thrombolysis\u201d will be converted into days (with the time in the simpy model representing minutes). The sum of saved thrombolysis days is then multiplied by the cost of a HASU bed stored in the G class.\u00a0Trial Total Savings (\u00a3) : The sum of \u201cSDEC Saving \u2013 Cost (\u00a3) and \u201cThrombolysis Savings (\u00a3)\u201d. Experimentation Aims 1.3 If the model has been used for experimentation, state the objectives that it was used to investigate.a.)  Scenario based analysis \u2013 Provide a name and description for each scenario, providing a rationale for the choice of scenarios and ensure that item 2.3 (below) is completed.b.)  Design of experiments \u2013 Provide details of the overall design of the experiments with reference to performance measures and their parameters (provide further details in data below).  c.)\u00a0  Simulation Optimisation \u2013 (if appropriate) Provide full details of what is to be optimised, the parameters that were included and the algorithm(s) that was be used.\u00a0 Where possible provide a citation of the algorithm(s). All combinations of the following parameters were tested:Same Day Emergency Care (SDEC) availability - 0% Same Day Emergency Care (SDEC) availability- 50% SDEC availability (continuous 12 hour block from xam to ypm)- 100% SDEC availability (24 hour availability)CT perfusion scanner availability - 0% CT Perfusion (CTP) availability- 50% CTP availability (continuous 12 hour block from xam to ypm)- 100% CTP availability (24 hour availability)Therapy availability - Therapy is available with the Same Day Emergency Care setting. - Therapy is not available with the Same Day Emergency Care setting. In the instance that therapy is available,  which enables admission avoidance for haemhorraghic and ischamic strokes with a higher MRS score (up to 3). Where therapy is not available, the maximum MRS score that may be considered to avoid admission when seen in SDEC is 2. Current and projected demand[JOHN - how was projected demand determined?] 2. \u00a0  Logic Base model overview diagram 2.1 Describe the base model using appropriate diagrams and description.\u00a0 This could include one or more process flow, activity cycle or equivalent diagrams sufficient to describe the model to readers.\u00a0 Avoid complicated diagrams in the main text.\u00a0 The goal is to describe the breadth and depth of the model with respect to the system being studied. See diagram 2.1 in folder 'checklists' within GitHub repository Base model logic 2.2 Give details of the base model logic. Give additional model logic details sufficient to communicate to the reader how the model works. Patients arrive into the model based on two stochastic patient generators, calling on inter-arrival times for high arrival hours (determined as 7am to 11.59pm) and low arrival hours (12am to 6.59am).Patients are then assessed by a triage nurse. They will then undergo a CT or CT perfusion scan (see 2.3). They will then be admitted to SDEC if available (see 2.3). If they are not suitable to be discharged after their stay in SDEC, or SDEC is not available, they will be admitted to the main stroke ward. If the main stroke ward is full, they will queue for the stroke ward until a bed becomes available (which can be considered in a real-world to be admission to an alternative ward while waiting for a stroke ward bed to become available). They are then admitted to the stroke ward for the sampled duration of their stay. Scenario logic 2.3 Give details of the logical difference between the base case model and scenarios (if any).\u00a0 This could be incorporated as text or where differences are substantial could be incorporated in the same manner as 2.2. If CT perfusion scanner availability is greater than 0, patients who complete their nurse triage step while scanners are available will instead undergo a CT perfusion scan. For patients with an unknown stroke onset time who were otherwise eligible for thrombolysis, this makes them eligible for thrombolysis, which has a 50% chance to lead to a 1 point improvement in MRS on discharge compared to the same patient not undergoing thrombolysis, and also reduces LOS to 75% of the originally sampled LOS duration for that patient (i.e. their stay duration is reduced by 25%). If SDEC availability is greater than 0, patients who complete their CT or CT perfusion scan while the SDEC is open and has an available bed will be admitted to the SDEC instead of the inpatient ward. A subset of these patients will be considered eligible for avoiding a full subsequent admission and will be tagged as such. Further details of the criteria for admission avoidance are detailed in section 2.5.3.If SDEC therapy support is enabled, more patients will become eligible for admission avoidance. This is again detailed in section 2.5.3. Algorithms 2.4 Provide further detail on any algorithms in the model that (for example) mimic complex or manual processes in the real world (i.e.\u00a0 scheduling of arrivals/appointments/operations/maintenance, operation of a conveyor system, machine breakdowns, etc.). Sufficient detail should be included (or referred to in other published work) for the algorithms to be reproducible.\u00a0 Pseudo-code may be used to describe an algorithm. Components 2.5 2.5.1 Entities A single class of patient is used within the model, referenced as 'Patient' within the Python model code.These entities are the stroke and non-stroke patients who are seen within the pathway. Key attributes are as follows:ID = a persistent identifier used to track a single patient through their full system journeyonset_type = Categorisation of onset information: 0 : Known onset; 1 : Unknown onset but within CTP window; 2 : Unknown onset and outside CTP windowmrs_type =  Modified Rankin Scale score at presentation (0\u20135). Drawn from an exponential distribution and capped at 5.  0 indicates no disability, while 5 represents severe disability. mrs_discharge = Modified Rankin Scale score at discharge. Unlike mrs_type, which is set on patient generation, the mrs_discharge is set later by the model and may differ depending on the availability of different pathways within the model - e.g. a patient may have a lower MRS on discharge if the CT perfusion scanner availability permits them to have thrombolysis. diagnosis = Raw randomised diagnostic value (0\u2013100). patient_diagnosis = Encoded diagnosis category: 0 : Intracerebral haemorrhage (ICH); 1 : Ischaemic stroke (I); 2 : Transient ischaemic attack (TIA); 3 : Stroke mimic; 4 : Non-stroke. This is mapped from the diagnosis patient attribute, using thresholds defined in the global parameter class <code>g</code>. non_admission = a numerical score used to determine whether patients with a transient ischaemic attack (TIA) or stroke mimic symptoms are admitted. Tracking attributesVarious attributes are set as events occur in the model, allowing for post-hoc analysis of logs. advanced_ct_pathway: Whether the patient enters an advanced CT imaging pathway (elsewhere referred to as CT perfusion scanning).sdec_pathway: Whether the patient is routed through the Same Day Emergency Care (SDEC) pathway.thrombolysis: Whether the patient receives thrombolysis.admission_avoidance: Whether the patient avoids an admission by being seen in SDEC instead.q_time_nurse, q_time_ward: Time spent waiting for nursing assessment/consultation, and time spent waiting for an inpatient ward bed respectively.Unused attributesSeveral attributes are created but not currently used by the published version of the model. They may be used in future versions of the model. priority = a numerical triage priority level used for queue ordering. thrombectomy = whether the patient receives mechanical thrombectomy 2.5.2 Activities Nurse triage = generated entities undergo assessment by a nurse for a generated amount of time. Duration is generated using an exponential distribution parameterised from historical data. CT or CT perfusion scanning = after triage, entities leave the nurse and undergo either a CT or CT perfusion (advanced CT) scan for a generated amount of time. Duration is generated using an exponential distribution parameterised from historical data. Thrombolysis = if eligible, patients will undergo thrombolysis. The time taken for this is not modelled; it purely affects eventual LOS if patients are admitted to the stroke ward.Same Day Emergency Care (SDEC) = if SDEC is open and has capacity, all patients are admitted to the SDEC after scanning. Ward stay = if admission is not avoided (see 2.5.3), entities are admitted to the main stroke ward for a generated amount of time. Patients may go straight from the CT/CTP scanning step if the SDEC is not open or is at capacity, or may move from the SDEC to the main ward. LOS is generated using an exponential distribution parameterised from historical data, stratified by Modified Rankin Scale on admission and stroke type, and adjusted by a defined proportion if thrombolysis is administered. 2.5.3 Resources Key capacity-limited resources within the system are: NursesNurses are used during the assessment step, where the patients are triaged. This is the first step in the patient pathway after patients are generated.The nurse resource is released when the patient moves on to scanning. Same Day Emergency Care (SDEC) bedsAfter a patient has been seen by a nurse and received either a CT or CT perfusion (CTP) scan, they will be admitted to the same day emergency care ward if the ward is currently operating and if there is sufficient capacity. The number of SDEC beds available defaults to 5. Inpatient Ward bedsIf the SDEC is not operating at the time a patient finishes their CT/CTP scan, or if SDEC is operating but at capacity, patient will be admitted to an inpatient ward bed if available. Patients will also move to an inpatient ward bed after their SDEC stay if they are not a candidate for admission avoidance. Admission avoidance is considered to occur in the following situations: - patient diagnosis is 0 or 1 AND mrs type is 0 or 1 AND the patient is not thrombolysed AND therapy is NOT available within the SDEC- patient diagnosis is 0 or 1 AND mrs type is 0, 1 or 2 AND the patient is not thrombolysed AND therapy is available within the SDEC- patient diagnosis is 2 (transient ischaemic attack) AND the randomised patient non-admission chance is higher than the globally defined TIA admission chance- patient diagnosis is 3 or 4 (stroke mimic or non-stroke) AND the randomised patient non-admission chance is higher than the globally defined stroke mimic admission chanceIf a bed is unavailble, patients will wait for a bed to become available. It is assumed that during this time they will be admitted to an alternative ward in the wider hospital where space is available, before being moved to this more appropriate ward as soon as a bed becomes available, with beds being allocated purely in the order that patients arrive. Unused constrained resourcesThe model creates an attribute relating to the number of CT perfusion (CTP) scanners within the model. However, this attribute is not currently used within the model. Instead, standard CT scanning capacity is assumed to always be available. CTP scanning availability is controlled on a purely time-based basis rather than checking against the number of available units. 2.5.4 Queues First in first out (FIFO) queueing is used in all cases. No reneging, balking or jockeying occur in the model. If CT perfusion scanning is not available when required, entities will not wait for it to become available; they will proceed straight to a CT scanner instead. If the SDEC unit is not available when required, entities will not wait for it to become available; they will proceed straight to the main stroke unit.If a bed is not available in the main stroke unit when required, patients will queue for a bed in the stroke unit, with the delay in being allocated a stroke bed being recorded as one of the key metrics in the model. Patients will wait indefinitely for a bed to become available. The duration of their stay in the main stroke unit is only sampled after a bed becomes available, and is independent of the time they spend waiting for a bed. [TODO: determine if this is the optimum behaviour] 2.5.5 Entry/Exit Points The boundary of the model is the stroke pathway, with specific reference to how the stroke pathway is set up in 2025 in Maidstone and Tunbridge Wells hospital. The model only looks at patients who interact with this pathway in some capacity, encompassing triage, scanning, time in the same day emergency care stroke unit (SDEC), and time in the main stroke inpatient unit.Patients arrive into the model based on two stochastic patient generators, calling on inter-arrival times for high arrival hours (determined as 7am to 11.59pm) and low arrival hours (12am to 6.59am).The arrivals are modelled on a poisson process, with inter-arrival times sampled from two separate exponential distributions parameterised using the average inter-arrival times of the two periods above in the real stroke unit being modelled. This is the only arrival point for patients, and they will all follow broadly the same process, with minor variations in their journey as described in 2.3. Patients may exit the system at one of two points:- discharge from the SDEC (if conditions for admission avoidance are met - see section 2.5.3) - discharge from the stroke unit 3. \u00a0  Data Data sources 3.1 List and detail all data sources. Sources may include:\u00b7 \u00a0 \u00a0 \u00a0 \u00a0 Interviews with stakeholders,\u00b7 \u00a0 \u00a0 \u00a0 \u00a0 Samples of routinely collected data,\u00b7 \u00a0 \u00a0 \u00a0 \u00a0 Prospectively collected samples for the purpose of the simulation study,\u00b7 \u00a0 \u00a0 \u00a0 \u00a0 Public domain data published in either academic or organisational literature. \u00a0 Provide, where possible, the link and DOI to the data or reference to published literature.All data source descriptions should include details of the sample size, sample date ranges and use within the study. Pre-processing 3.2 Provide details of any data manipulation that has taken place before its use in the simulation, e.g. interpolation to account for missing data or the removal of outliers. Input parameters 3.3 List all input variables in the model. Provide a description of their use and include parameter values.\u00a0 For stochastic inputs provide details of any continuous, discrete or empirical distributions used along with all associated parameters.\u00a0 Give details of all time dependent parameters and correlation.Clearly state:Base case dataData use in experimentation, where different from the base case.Where optimisation or design of experiments has been used, state the range of values that parameters can take.Where theoretical distributions are used, state how these were selected and prioritised above other candidate distributions. Note that the time units used within the model are minutes; all values below relate to durations in minutes.  An asterisk is used to identify those parameters that can be easily altered using the web based front end. All listed parameters could bechanged within the model code. Patient inter-arrival timesInter-arrival times are drawn from an exponential distribution. Two different distributions are used for different times of day:  High arrival hours (7am to 11.59pm): \u03bb = 1 / 200.0 Low arrival hours (12am to 6.59am): \u03bb = 1 / 666.666666666667Activity durations All activity durations draw from an exponential distribution, where \u03bb is calculated as 1 divided by the relevant value from the list below (where all values relate to a number of minutes). mean_n_consult_time = 60; mean_n_ct_time = 20; mean_n_sdec_time = 240Time on the main wards is an exponential distribution parameterised in the same way, but the value depends on both the stroke type (intercranial haemhorragic [ich], ischaemic [i], transient ischaemic attack (tia), and stroke mimic or non-stroke. Ischaemic strokes: mrs_0 = 1440 * 6;  mrs_1 = 1440 * 4;  mrs_2 = 1440 * 8; mrs_3 = 1440 * 11;  mrs_4 = 1440 * 24;  mrs_5 = 1440 * 29Intercranial haemhorrhage: mrs_0 = 1440 * 5; mrs_1 = 1440 * 4;  mrs_2 = 1440 * 5; mrs_3 = 1440 * 17;  mrs_4 = 1440 * 36;  mrs_5 = 1440 * 36non_stroke = 4320tia = 1440Where patients undergo thrombolysis, the sampled duration is modified by the following parameter: thrombolysis_los_save = 0.75Opening/operating hours of resourcesVarious parameters are used to determine what percentage of time the SDEC and advanced CT scanning capabilities are available and from what time of day they are available, defaulting to no availability for either. These can be set independently of each other. The model is primarily built to support one single uninterruped period of availability per day. CostsThe cost of staffing the SDEC per minute is tracked with sdec_dr_cost_min = 0.50Per day overnight hyper-acute stroke unit bed costs are set as follows: inpatient_bed_cost = \u00a3876 and inpatient_bed_cost (thrombolysed patients) = \u00a3528.17 OtherThe average Modified Rankin Scale score is determined with the parameter: mean_mrs = 2Patients are allocated a diagnosis value using a uniform distribution randing from 0 to 100. They are then categoriesed using the following boundaries: &lt;= 10 = intercranial haemhorrhage (ich); &lt;= 60 = ischaemic stroke (i); &lt;= 70 = tia; &lt;= 80 = stroke mimic; &gt; 80 = non-stroke Assumptions 3.4 Where data or knowledge of the real system is unavailable what assumptions are included in the model?\u00a0 This might include parameter values, distributions or routing logic within the model. 4. \u00a0  Experimentation Initialisation 4.1 Report if the system modelled is terminating or non-terminating.\u00a0 State if a warm-up period has been used, its length and the analysis method used to select it.\u00a0 For terminating systems state the stopping condition.State what if any initial model conditions have been included, e.g., pre-loaded queues and activities.\u00a0 Report whether initialisation of these variables is deterministic or stochastic. The system is non-terminating. A warm-up period equivalent to one fifth of the specified model duration is included. [TODO: Add justification for warm-up duration]No pre-loaded queues or activities are included in the initialisation of the model. Run length 4.2 Detail the run length of the simulation model and time units. The model defaults to a run duration of one non-leap calendar year. The model uses minutes as its units of time, so this equates to 525,600 minutes. Estimation approach 4.3 State the method used to account for the stochasticity: For example, two common methods are multiple replications or batch means. Where multiple replications have been used, state the number of replications and for batch means, indicate the batch length and whether the batch means procedure is standard, spaced or overlapping. For both procedures provide a justification for \u00a0 the methods used and the number of replications/size of batches. Multiple replications are used to account for stochasticity. The model uses [x] runs. [TODO: determine final number of runs][TODO: add justification for run number] 5. \u00a0  Implementation Software or programming language 5.1 State the operating system and version and build number.State the name, version and build number of commercial or open source DES software that the model is implemented in.\u00a0State the name and version of general-purpose programming languages used (e.g. Python 3.5).Where frameworks and libraries have been used provide all details including version numbers. [TODO: Add OS and build number from windows \u2192 system settings \u2192 about]The model is written in the Python programming language. Results were obtained using Python 3.12.10.[TODO: this may change depending on exact version John is running]. Key libraries for the model itself aresimpy==4.1.1vidigi==1.1.0pandas==2.1.1numpy==1.26.4matplotlib==3.10.8sim-tools==1.0.0Additional libraries are used for the web application front end and documentation creationstreamlit-mermaid==0.3.0mkdocs-material==9.7.0mkdocstrings[python]streamlit-extras==0.7.8streamlit==1.52.1stlitepack==0.4.5 Random sampling 5.2 State the algorithm used to generate random samples in the software/programming language used e.g. Mersenne Twister.If common random numbers are used, state how seeds (or random number streams) are distributed among sampling processes. Seeds are generated using Numpy's seed sequence, which is itself primed by a user-provided seed (default 42) plus the run number. Generators for each random number stream (one per activity) are set up independently using the sampling classes of the sim_tools package (v1.0.0), which each provided with a seed from the seed sequence. Model execution 5.3 State the event processing mechanism used e.g. three phase, event, activity, process interaction.\u00a0Note that in some commercial software the event processing mechanism may not be published. In these cases authors should adhere to item 5.1 software recommendations.State all priority rules included if entities/activities compete for resources.If the model is parallel, distributed and/or use grid or cloud computing, etc., state and preferably reference the technology used.\u00a0 For parallel and distributed simulations the time management algorithms used.\u00a0 If the HLA is used then state the version of the standard, which run-time infrastructure (and version), and any supporting documents (FOMs, etc.) SimPy is described as a 'process-based discrete-event simulation framework'. It makes use of Python generators to describe these processes. No prioritisation is applied when allocating resources to beds, though the model has been set up with both CTP scanners and SDEC beds as priority resources, with generated patients also having a priority score, so future versions of the model may be enhanced to make use of prioritisation at these points in the model.  System Specification 5.4 State the model run time and specification of hardware used.\u00a0 This is particularly important for large scale models that require substantial computing power.\u00a0 For parallel, distributed and/or use grid or cloud computing, etc. state the details of all systems used in the implementation (processors, network, etc.) [TODO: get John's system specs from windows \u2192 system settings \u2192 about] 6. \u00a0  Code Access Computer Model Sharing Statement 6.1 Describe how someone could obtain the model described in the paper, the simulation software and any other associated software (or hardware) needed to reproduce the results.\u00a0 Provide, where possible, the link and DOIs to these. Model code, environment specifications, code for the associated web application frontend, and outputs associated with this paper can be accessed on GitHub: TODOA permanent archive of the version of the code and results relating to this paper can be accessed on Zenodo: TODOAll code is licenced under the MIT licence, a permissive licence allowing for use and adaptation of this work in both non-commercial and commercial settings."},{"location":"tests/","title":"Test Results","text":""},{"location":"trial/","title":"Reference","text":"<p>Orchestrator for running multiple simulation iterations (runs) and aggregating results.</p> <p>The Trial class manages the execution of multiple <code>Model</code> instances as defined in the global configuration. It collects performance metrics, financial data, and patient-level logs from each individual run into centralised DataFrames for cross-run analysis.</p> <p>Attributes:</p> Name Type Description <code>df_trial_results</code> <code>DataFrame</code> <p>A summary DataFrame where each row represents a single simulation run. Tracks metrics such as mean queue times, occupancy, and financial savings.</p> <code>model_objects</code> <code>list</code> <p>A collection of <code>Model</code> instances created during the trial, allowing for post-hoc inspection of specific run states.</p> <code>trial_patient_dataframes</code> <code>list</code> <p>A list of DataFrames, each containing detailed attribute data for every patient in a specific run.</p> <code>trial_patient_df</code> <code>DataFrame</code> <p>The master DataFrame created by concatenating all patient-level data across all runs in the trial.</p> <code>trial_info</code> <code>str</code> <p>A descriptive string containing the configuration settings used for the current trial (e.g., SDEC therapy status and resource availability).</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/trial.py</code> <pre><code>class Trial:\n    \"\"\"\n    Orchestrator for running multiple simulation iterations (runs) and\n    aggregating results.\n\n    The Trial class manages the execution of multiple `Model` instances as\n    defined in the global configuration. It collects performance metrics,\n    financial data, and patient-level logs from each individual run into\n    centralised DataFrames for cross-run analysis.\n\n    Attributes\n    ----------\n    df_trial_results : pd.DataFrame\n        A summary DataFrame where each row represents a single simulation run.\n        Tracks metrics such as mean queue times, occupancy, and financial\n        savings.\n    model_objects : list\n        A collection of `Model` instances created during the trial, allowing\n        for post-hoc inspection of specific run states.\n    trial_patient_dataframes : list\n        A list of DataFrames, each containing detailed attribute data for every\n        patient in a specific run.\n    trial_patient_df : pd.DataFrame\n        The master DataFrame created by concatenating all patient-level data\n        across all runs in the trial.\n    trial_info : str\n        A descriptive string containing the configuration settings used for\n        the current trial (e.g., SDEC therapy status and resource availability).\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run with run number as the index.\n\n    def __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse (Mins)\"] = [0.0]\n        self.df_trial_results[\"Max Q Time Nurse (Mins)\"] = [0.0]\n        self.df_trial_results[\"Number of Admissions Avoided In Run\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Ward (Hour)\"] = [0.0]\n        self.df_trial_results[\"Max Q Time Ward (Hour)\"] = [0.0]\n        self.df_trial_results[\"Mean Occupancy\"] = [0.0]\n        self.df_trial_results[\"Number of Admission Delays\"] = [0.0]\n        self.df_trial_results[\"Mean Length of Stay Ward (Hours)\"] = [0.0]\n        self.df_trial_results[\"Financial Savings of Admissions Avoidance (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"SDEC Medical Staff Cost (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"SDEC Savings (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"Thrombolysis Savings (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"Total Savings\"] = [0.0]\n        self.df_trial_results[\"Mean MRS Change\"] = [0.0]\n        self.df_trial_results[\"Mean Number of Patients Assessed\"] = [0.0]\n        self.df_trial_results[\"Number of Intracranial Haemhorrhage patients\"] = [0.0]\n        self.df_trial_results[\"Number of Ischaemic Stroke patients\"] = [0.0]\n        self.df_trial_results[\"Number of TIA patients\"] = [0.0]\n        self.df_trial_results[\"Number of Stroke Mimic patients\"] = [0.0]\n        self.df_trial_results[\"Number of Non-Stroke patients\"] = [0.0]\n        self.df_trial_results[\n            \"Mean Additional Thrombolysed Patients From CTP Running\"\n        ] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.ward_occupancy_audits = []\n        self.ward_occupancy_df = pd.DataFrame()\n\n        self.sdec_occupancy_audits = []\n        self.sdec_occupancy_df = pd.DataFrame()\n\n        self.model_objects = []\n        # self.patient_objects = {}\n\n        self.trial_patient_dataframes = []\n        self.trial_patient_df = pd.DataFrame()\n\n    # MARK: M: run_trial\n    # Method to run a trial\n\n    def run_trial(self):\n        \"\"\"\n        Executes the batch of simulation runs and aggregates the resulting data.\n\n        This method performs the following steps:\n\n        1. Loops through the number of runs specified in `g.number_of_runs`.\n\n        2. Instantiates and executes a `Model` for each run.\n\n        3. Collects summary metrics (e.g., queue times, savings) into `df_trial_results`.\n\n        4. Flattens patient-level data into a single master DataFrame.\n\n        5. Calculates trial-level means and updates the global `g` class attributes.\n\n        6. Optionally exports results to a CSV file if `g.write_to_csv` is True.\n\n        This method dynamically updates the global configuration class `g` by\n        calculating the mean of results across all runs and storing them in\n        dictionaries keyed by the trial counter.\n\n        See Also\n        --------\n        Model.run : The method called to execute an individual simulation iteration.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results\n        # and store it against the run number in the trial results dataframe.\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.model_objects.append(my_model)\n\n            self.df_trial_results.loc[run] = [\n                my_model.mean_q_time_nurse,\n                my_model.max_q_time_nurse,\n                my_model.number_of_admissions_avoided,\n                my_model.mean_q_time_ward,\n                my_model.max_q_time_ward,\n                my_model.mean_ward_occupancy,\n                my_model.admission_delays,\n                my_model.mean_los_ward,\n                my_model.sdec_financial_savings,\n                my_model.medical_staff_cost,\n                my_model.savings_sdec,\n                my_model.thrombolysis_savings,\n                my_model.total_savings,\n                my_model.mean_mrs_change,\n                my_model.patient_counter,\n                my_model.ich_patients_count,\n                my_model.i_patients_count,\n                my_model.tia_patients_count,\n                my_model.stroke_mimic_patient_count,\n                my_model.non_stroke_patient_count,\n                my_model.additional_thrombolysis_from_ctp,\n            ]\n\n            # self.patient_objects[run] = my_model.patient_objects\n            patient_dataframe = pd.DataFrame(\n                [p.__dict__ for p in my_model.patient_objects]\n            )\n            patient_dataframe[\"run\"] = run + 1\n            self.trial_patient_dataframes.append(patient_dataframe)\n\n            my_model.ward_occupancy_graph_df[\"run\"] = run + 1\n            self.ward_occupancy_audits.append(my_model.ward_occupancy_graph_df)\n\n            my_model.sdec_occupancy_graph_df[\"run\"] = run + 1\n            self.sdec_occupancy_audits.append(my_model.sdec_occupancy_graph_df)\n\n        self.trial_patient_df = pd.concat(self.trial_patient_dataframes)\n        self.ward_occupancy_df = pd.concat(self.ward_occupancy_audits)\n        self.sdec_occupancy_df = pd.concat(self.sdec_occupancy_audits)\n\n        if g.write_to_csv == True:\n            self.df_trial_results.to_csv(\n                f\"trial {g.trials_run_counter} trial results.csv\", index=False\n            )\n\n        # TODO: SR: FIX appending of per-run graphs to trial class\n        # if g.gen_graph:\n        #     self.graph_objects.append(my_model.plot_stroke_run_graphs(plot=False))\n\n        # This is new code that will store all averages to compare across\n        # the different trials. It does this by checking if the attribute\n        # exists in the global g class, and if it doesn't it creates it. It\n        # then stores the mean of each run against the attribute\n        # (eg \"trial_mean_q_time_nurse\")\n\n        # The mean is stored against the key of g.trials_run_counter.\n\n        for attr, col in [\n            (\"trial_mean_q_time_nurse\", \"Mean Q Time Nurse (Mins)\"),\n            (\"trial_max_q_time_nurse\", \"Max Q Time Nurse (Mins)\"),\n            (\n                \"trial_number_of_admissions_avoided\",\n                \"Number of Admissions Avoided In Run\",\n            ),\n            (\"trial_mean_q_time_ward\", \"Mean Q Time Ward (Hour)\"),\n            (\"trial_max_q_time_ward\", \"Max Q Time Ward (Hour)\"),\n            (\"trial_mean_occupancy\", \"Mean Occupancy\"),\n            (\"trial_number_of_admission_delays\", \"Number of Admission Delays\"),\n            (\n                \"trial_financial_savings_of_a_a\",\n                \"Financial Savings of Admissions Avoidance (\u00a3)\",\n            ),\n            (\"sdec_medical_cost\", \"SDEC Medical Staff Cost (\u00a3)\"),\n            (\"trial_sdec_financial_savings\", \"SDEC Savings (\u00a3)\"),\n            (\"trial_thrombolysis_savings\", \"Thrombolysis Savings (\u00a3)\"),\n            (\"trial_total_savings\", \"Total Savings\"),\n            (\"trial_mrs_change\", \"Mean MRS Change\"),\n            (\"trial_patient_count\", \"Mean Number of Patients Assessed\"),\n            (\n                \"trial_additional_thrombolysis_from_ctp\",\n                \"Mean Additional Thrombolysed Patients From CTP Running\",\n            ),\n        ]:\n            # Checks to see if the attribute already exists and if it doesn't\n            # create it. Creates a mean of each trial and creates a dictionary\n            # that can be read later.\n\n            if not hasattr(g, attr):\n                setattr(g, attr, {})\n            if \"max\" in attr:\n                getattr(g, attr)[g.trials_run_counter] = round(\n                    self.df_trial_results[col].max(), 2\n                )\n            else:\n                getattr(g, attr)[g.trials_run_counter] = round(\n                    self.df_trial_results[col].mean(), 2\n                )\n\n        # Code to store the configuration that was used for this trial.\n        self.trial_info = (\n            f\"Trial {g.trials_run_counter}, SDEC Therapy = {g.therapy_sdec},\"\n            f\" SDEC Open % = {g.sdec_value}, CTP Open % = {g.ctp_value}\"\n        )\n\n        print(\"---------------------------------------------------\")\n        print(f\"{self.trial_info}\")\n        print(f\"Trial {g.trials_run_counter} Results:\")\n        print(\" \")\n        print(\n            f\"Trial Mean Q Time Nurse (Mins):     \\\n              {g.trial_mean_q_time_nurse[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Max Q Time Nurse (Mins):     \\\n              {g.trial_max_q_time_nurse[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Number of Admissions Avoided: \\\n              {g.trial_number_of_admissions_avoided[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Mean Q Time Ward (Hours):     \\\n              {g.trial_mean_q_time_ward[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Max Q Time Ward (Hours):     \\\n              {g.trial_max_q_time_ward[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Mean Ward Occupancy:          \\\n              {g.trial_mean_occupancy[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Number of Admission Delays:   \\\n              {g.trial_number_of_admission_delays[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial SDEC Total Savings (\u00a3):       \\\n              {g.trial_financial_savings_of_a_a[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial SDEC Medical Cost (\u00a3):        \\\n              {g.sdec_medical_cost[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial SDEC Savings - Cost (\u00a3):      \\\n              {g.trial_sdec_financial_savings[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Thrombolysis Savings (\u00a3):     \\\n              {g.trial_thrombolysis_savings[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Total Savings (\u00a3):            \\\n              {g.trial_total_savings[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Mean MRS Change:                    \\\n              {g.trial_mrs_change[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Mean Assessed Patients:                    \\\n              {g.trial_patient_count[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Mean Additional Thrombolysed Patients From CTP Running:                    \\\n              {g.trial_additional_thrombolysis_from_ctp[g.trials_run_counter]}\"\n        )\n</code></pre>"},{"location":"trial/#stroke_ward_model.trial.Trial.run_trial","title":"<code>run_trial()</code>","text":"<p>Executes the batch of simulation runs and aggregates the resulting data.</p> <p>This method performs the following steps:</p> <ol> <li> <p>Loops through the number of runs specified in <code>g.number_of_runs</code>.</p> </li> <li> <p>Instantiates and executes a <code>Model</code> for each run.</p> </li> <li> <p>Collects summary metrics (e.g., queue times, savings) into <code>df_trial_results</code>.</p> </li> <li> <p>Flattens patient-level data into a single master DataFrame.</p> </li> <li> <p>Calculates trial-level means and updates the global <code>g</code> class attributes.</p> </li> <li> <p>Optionally exports results to a CSV file if <code>g.write_to_csv</code> is True.</p> </li> </ol> <p>This method dynamically updates the global configuration class <code>g</code> by calculating the mean of results across all runs and storing them in dictionaries keyed by the trial counter.</p> See Also <p>Model.run : The method called to execute an individual simulation iteration.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src/stroke_ward_model/trial.py</code> <pre><code>def run_trial(self):\n    \"\"\"\n    Executes the batch of simulation runs and aggregates the resulting data.\n\n    This method performs the following steps:\n\n    1. Loops through the number of runs specified in `g.number_of_runs`.\n\n    2. Instantiates and executes a `Model` for each run.\n\n    3. Collects summary metrics (e.g., queue times, savings) into `df_trial_results`.\n\n    4. Flattens patient-level data into a single master DataFrame.\n\n    5. Calculates trial-level means and updates the global `g` class attributes.\n\n    6. Optionally exports results to a CSV file if `g.write_to_csv` is True.\n\n    This method dynamically updates the global configuration class `g` by\n    calculating the mean of results across all runs and storing them in\n    dictionaries keyed by the trial counter.\n\n    See Also\n    --------\n    Model.run : The method called to execute an individual simulation iteration.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results\n    # and store it against the run number in the trial results dataframe.\n\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n        self.model_objects.append(my_model)\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_nurse,\n            my_model.max_q_time_nurse,\n            my_model.number_of_admissions_avoided,\n            my_model.mean_q_time_ward,\n            my_model.max_q_time_ward,\n            my_model.mean_ward_occupancy,\n            my_model.admission_delays,\n            my_model.mean_los_ward,\n            my_model.sdec_financial_savings,\n            my_model.medical_staff_cost,\n            my_model.savings_sdec,\n            my_model.thrombolysis_savings,\n            my_model.total_savings,\n            my_model.mean_mrs_change,\n            my_model.patient_counter,\n            my_model.ich_patients_count,\n            my_model.i_patients_count,\n            my_model.tia_patients_count,\n            my_model.stroke_mimic_patient_count,\n            my_model.non_stroke_patient_count,\n            my_model.additional_thrombolysis_from_ctp,\n        ]\n\n        # self.patient_objects[run] = my_model.patient_objects\n        patient_dataframe = pd.DataFrame(\n            [p.__dict__ for p in my_model.patient_objects]\n        )\n        patient_dataframe[\"run\"] = run + 1\n        self.trial_patient_dataframes.append(patient_dataframe)\n\n        my_model.ward_occupancy_graph_df[\"run\"] = run + 1\n        self.ward_occupancy_audits.append(my_model.ward_occupancy_graph_df)\n\n        my_model.sdec_occupancy_graph_df[\"run\"] = run + 1\n        self.sdec_occupancy_audits.append(my_model.sdec_occupancy_graph_df)\n\n    self.trial_patient_df = pd.concat(self.trial_patient_dataframes)\n    self.ward_occupancy_df = pd.concat(self.ward_occupancy_audits)\n    self.sdec_occupancy_df = pd.concat(self.sdec_occupancy_audits)\n\n    if g.write_to_csv == True:\n        self.df_trial_results.to_csv(\n            f\"trial {g.trials_run_counter} trial results.csv\", index=False\n        )\n\n    # TODO: SR: FIX appending of per-run graphs to trial class\n    # if g.gen_graph:\n    #     self.graph_objects.append(my_model.plot_stroke_run_graphs(plot=False))\n\n    # This is new code that will store all averages to compare across\n    # the different trials. It does this by checking if the attribute\n    # exists in the global g class, and if it doesn't it creates it. It\n    # then stores the mean of each run against the attribute\n    # (eg \"trial_mean_q_time_nurse\")\n\n    # The mean is stored against the key of g.trials_run_counter.\n\n    for attr, col in [\n        (\"trial_mean_q_time_nurse\", \"Mean Q Time Nurse (Mins)\"),\n        (\"trial_max_q_time_nurse\", \"Max Q Time Nurse (Mins)\"),\n        (\n            \"trial_number_of_admissions_avoided\",\n            \"Number of Admissions Avoided In Run\",\n        ),\n        (\"trial_mean_q_time_ward\", \"Mean Q Time Ward (Hour)\"),\n        (\"trial_max_q_time_ward\", \"Max Q Time Ward (Hour)\"),\n        (\"trial_mean_occupancy\", \"Mean Occupancy\"),\n        (\"trial_number_of_admission_delays\", \"Number of Admission Delays\"),\n        (\n            \"trial_financial_savings_of_a_a\",\n            \"Financial Savings of Admissions Avoidance (\u00a3)\",\n        ),\n        (\"sdec_medical_cost\", \"SDEC Medical Staff Cost (\u00a3)\"),\n        (\"trial_sdec_financial_savings\", \"SDEC Savings (\u00a3)\"),\n        (\"trial_thrombolysis_savings\", \"Thrombolysis Savings (\u00a3)\"),\n        (\"trial_total_savings\", \"Total Savings\"),\n        (\"trial_mrs_change\", \"Mean MRS Change\"),\n        (\"trial_patient_count\", \"Mean Number of Patients Assessed\"),\n        (\n            \"trial_additional_thrombolysis_from_ctp\",\n            \"Mean Additional Thrombolysed Patients From CTP Running\",\n        ),\n    ]:\n        # Checks to see if the attribute already exists and if it doesn't\n        # create it. Creates a mean of each trial and creates a dictionary\n        # that can be read later.\n\n        if not hasattr(g, attr):\n            setattr(g, attr, {})\n        if \"max\" in attr:\n            getattr(g, attr)[g.trials_run_counter] = round(\n                self.df_trial_results[col].max(), 2\n            )\n        else:\n            getattr(g, attr)[g.trials_run_counter] = round(\n                self.df_trial_results[col].mean(), 2\n            )\n\n    # Code to store the configuration that was used for this trial.\n    self.trial_info = (\n        f\"Trial {g.trials_run_counter}, SDEC Therapy = {g.therapy_sdec},\"\n        f\" SDEC Open % = {g.sdec_value}, CTP Open % = {g.ctp_value}\"\n    )\n\n    print(\"---------------------------------------------------\")\n    print(f\"{self.trial_info}\")\n    print(f\"Trial {g.trials_run_counter} Results:\")\n    print(\" \")\n    print(\n        f\"Trial Mean Q Time Nurse (Mins):     \\\n          {g.trial_mean_q_time_nurse[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Max Q Time Nurse (Mins):     \\\n          {g.trial_max_q_time_nurse[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Number of Admissions Avoided: \\\n          {g.trial_number_of_admissions_avoided[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Mean Q Time Ward (Hours):     \\\n          {g.trial_mean_q_time_ward[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Max Q Time Ward (Hours):     \\\n          {g.trial_max_q_time_ward[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Mean Ward Occupancy:          \\\n          {g.trial_mean_occupancy[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Number of Admission Delays:   \\\n          {g.trial_number_of_admission_delays[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial SDEC Total Savings (\u00a3):       \\\n          {g.trial_financial_savings_of_a_a[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial SDEC Medical Cost (\u00a3):        \\\n          {g.sdec_medical_cost[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial SDEC Savings - Cost (\u00a3):      \\\n          {g.trial_sdec_financial_savings[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Thrombolysis Savings (\u00a3):     \\\n          {g.trial_thrombolysis_savings[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Total Savings (\u00a3):            \\\n          {g.trial_total_savings[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Mean MRS Change:                    \\\n          {g.trial_mrs_change[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Mean Assessed Patients:                    \\\n          {g.trial_patient_count[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Mean Additional Thrombolysed Patients From CTP Running:                    \\\n          {g.trial_additional_thrombolysis_from_ctp[g.trials_run_counter]}\"\n    )\n</code></pre>"}]}