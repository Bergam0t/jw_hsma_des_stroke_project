import simpy
import random
import pandas as pd
import simpy.resources
import numpy as np
import matplotlib.pyplot as plt
from sim_tools.trace import trace
from stroke_ward_model.utils import minutes_to_ampm


# MARK: g
# Global class to store parameters for the model.
class g:
    """
    Global simulation configuration parameters.

    This class stores all model-wide constants used in the discrete-event
    simulation, including runtime settings, resource capacities, operational
    constraints, diagnosis-based length-of-stay (LOS) values, cost parameters,
    and state flags modified during execution. All attributes are class
    variables and are intended to be accessed without instantiation.

    Attributes
    ----------
    sim_duration : int
        Total simulated time in minutes (default: 525600, one year).
    number_of_runs : int
        Number of simulation replications.
    warm_up_period : float
        Number of minutes considered warm-up (not included in statistics),
        defined as one-fifth of the total simulation time.
    patient_inter_day : int
        Interarrival time (minutes) for daytime patient generation.
        NOTE that this is not used in entirely the way that you might expect.
        This may be changed in future.
    patient_inter_night : int
        Interarrival time (minutes) for nighttime patient generation.
        NOTE that this is not used in entirely the way that you might expect.
        This may be changed in future.
    number_of_nurses : int
        Number of nurses available in the system.
    mean_n_consult_time : int
        Mean consultation time in minutes.
    mean_n_ct_time : int
        Mean CT processing time in minutes.
    number_of_ctp : int
        Number of CT processing units available.
    sdec_beds : int
        Number of SDEC (Same Day Emergency Care) beds.
    mean_n_sdec_time : int
        Mean SDEC stay duration in minutes.
    number_of_ward_beds : int
        Number of inpatient ward beds.
    mean_n_i_ward_time_mrs_0 : int
        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (0).
    mean_n_i_ward_time_mrs_1 : int
        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (1).
    mean_n_i_ward_time_mrs_2 : int
        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (2).
    mean_n_i_ward_time_mrs_3 : int
        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (3).
    mean_n_i_ward_time_mrs_4 : int
        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (4).
    mean_n_i_ward_time_mrs_5 : int
        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (5).
    mean_n_ich_ward_time_mrs_0 : int
        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (0).
    mean_n_ich_ward_time_mrs_1 : int
        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (1).
    mean_n_ich_ward_time_mrs_2 : int
        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (2).
    mean_n_ich_ward_time_mrs_3 : int
        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (3).
    mean_n_ich_ward_time_mrs_4 : int
        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (4).
    mean_n_ich_ward_time_mrs_5 : int
        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (5).
    mean_n_non_stroke_ward_time : int
        LOS (minutes) for non-stroke patients (TODO: CHECK INTERPRETATION).
    mean_n_tia_ward_time : int
        LOS (minutes) for TIA patients.
    thrombolysis_los_save : float
        Proportional reduction in LOS for thrombolysed patients.
        This is used as a multiplier with the sampled length of stay.
        For example, if a patient has a LOS of 10 days, and the value of `thrombolysis_los_save`
        was 0.75, the calculation would be 10 * 0.75, resulting in a LOS of 7.5 days.
    mean_mrs : int
        Default/mean modified Rankin Scale score used in the model.
    ich : int
        Percentage likelihood of intracerebral hemorrhage diagnosis (TODO: CHECK INTERPRETATION).
    i : int
        Percentage likelihood of ischemic stroke diagnosis.
    tia : int
        Percentage likelihood of TIA diagnosis.
    stroke_mimic : int
        Percentage likelihood of stroke mimic diagnosis.
    tia_admission : int
        Percentage chance that a TIA requires admission.
    stroke_mimic_admission : int
        Percentage chance that a stroke mimic requires admission.
    sdec_dr_cost_min : float
        Cost per minute for SDEC doctor time.
    inpatient_bed_cost : float
        Cost of a standard inpatient bed stay.
    inpatient_bed_cost_thrombolysis : float
        Cost of an inpatient stay following thrombolysis.
    sdec_unav_time : int
        Operational unavailability duration of SDEC
    sdec_unav_freq : int
        How often SDEC unavailability duration occurs
    ctp_unav_time : int
        Operational unavailability duration of CT perfusion scanner
    ctp_unav_freq : int
        How often CT perfusion unavailability duration occurs
    sdec_unav : bool
        Indicates whether SDEC is unavailable.
    ctp_unav : bool
        Indicates whether CT processing is unavailable.
    write_to_csv : bool
        Whether the simulation should write results to CSV.
    gen_graph : bool
        Whether visualisation graphs should be generated.
    therapy_sdec : bool
        Whether therapy is delivered through SDEC.
    trials_run_counter : int
        Internal counter tracking completed simulation replications.
    patient_arrival_gen_1 : bool
        Flag used by the simulation to control one patient arrival stream.
    patient_arrival_gen_2 : bool
        Flag used by the simulation to control a second patient arrival stream.

    Notes
    -----
    GENAI declaration (SR): this docstring has been generated with the aid of
    ChatGPT 5.1.
    All generated content has been thoroughly reviewed.
    """

    # 525600 (Year of Minutes)
    sim_duration = 525600
    number_of_runs = 10
    warm_up_period = sim_duration / 5
    patient_inter_day = 5
    patient_inter_night = 5
    number_of_nurses = 2
    number_of_ctp = 1
    sdec_beds = 5
    number_of_ward_beds = 1

    mean_n_consult_time = 60
    mean_n_ct_time = 20
    mean_n_sdec_time = 240

    # Different variables for ward stay based on diagnosis, thrombolysis and MRS
    mean_n_i_ward_time_mrs_0 = 1440 * 6
    mean_n_i_ward_time_mrs_1 = 1440 * 4
    mean_n_i_ward_time_mrs_2 = 1440 * 8
    mean_n_i_ward_time_mrs_3 = 1440 * 11
    mean_n_i_ward_time_mrs_4 = 1440 * 24
    mean_n_i_ward_time_mrs_5 = 1440 * 29

    mean_n_ich_ward_time_mrs_0 = 1440 * 5
    mean_n_ich_ward_time_mrs_1 = 1440 * 4
    mean_n_ich_ward_time_mrs_2 = 1440 * 5
    mean_n_ich_ward_time_mrs_3 = 1440 * 17
    mean_n_ich_ward_time_mrs_4 = 1440 * 36
    mean_n_ich_ward_time_mrs_5 = 1440 * 36

    mean_n_non_stroke_ward_time = 4320
    mean_n_tia_ward_time = 1440
    thrombolysis_los_save = 0.75

    sdec_dr_cost_min = 0.50
    inpatient_bed_cost = 876
    inpatient_bed_cost_thrombolysis = 528.17
    mean_mrs = 2

    # Diagnosis % range
    ich = 10
    i = 60
    tia = 70
    stroke_mimic = 80

    # Admission Range (% Chance of Admission) for TIA and Stroke Mimic, non
    # stroke shares the range with stroke mimic in this model. (This is
    # reflected in our real data mainly because most non strokes are often
    #  mimics that are not classified under the stroke mimic criteria in our
    #  data collection)
    tia_admission = 10
    stroke_mimic_admission = 30

    # Operational hours of SDEC and CTP are set by the user and stored in the
    # variables below.

    sdec_unav_time = 0
    sdec_unav_freq = 0
    ctp_unav_time = 0
    ctp_unav_freq = 0

    sdec_value = 0
    ctp_value = 0

    sdec_opening_hour = 0
    ctp_opening_hour = 0

    in_hours_start = 8
    ooh_start = 20

    in_hours_start_mins = in_hours_start * 60
    ooh_start_mins = ooh_start * 60

    # These values are changed by the model itself

    sdec_unav = False
    ctp_unav = False
    write_to_csv = False
    gen_graph = False
    therapy_sdec = False
    trials_run_counter = 1
    patient_arrival_gen_1 = False
    patient_arrival_gen_2 = False

    show_trace = True
    tracked_cases = list(range(1, 1000))
    trace_config = {"tracked": tracked_cases}


# MARK: Patient
# Patient class to store patient attributes
class Patient:
    """
    Representation of an individual patient within the simulation.

    A `Patient` object stores all clinical, pathway, and state-related
    attributes required for modelling flow through the stroke/TIA care
    process. Several characteristics (onset type, MRS score, diagnosis
    category, admission likelihood) are randomly generated on creation
    using parameters defined in the global configuration class `g`.

    Parameters
    ----------
    p_id : int or str
        Unique identifier for the patient.

    Attributes
    ----------
    id : int or str
        Patient identifier.
    q_time_nurse : float
        Time spent waiting for nursing assessment or consultation.
    q_time_ward : float
        Time spent waiting for an inpatient ward bed.
    onset_type : int
        Categorisation of onset information:
        - 0 : Known onset
        - 1 : Unknown onset but within CTP window
        - 2 : Unknown onset and outside CTP window
    mrs_type : int
        Modified Rankin Scale score at presentation (0â€“5).
        Drawn from an exponential distribution and capped at 5.
    mrs_discharge : int
        Modified Rankin Scale score at discharge (set later by the model).
    diagnosis : int
        Raw randomised diagnostic value (0â€“100). Used to map to a clinical
        category based on thresholds defined in `g`.
    patient_diagnosis : int
        Encoded diagnosis category:
        - 0 : Intracerebral haemorrhage (ICH)
        - 1 : Ischaemic stroke (I)
        - 2 : Transient ischaemic attack (TIA)
        - 3 : Stroke mimic
        - 4 : Non-stroke
    priority : int
        Triage priority level (used for queue ordering).
    non_admission : int
        Randomised admission likelihood score (0â€“100).
    advanced_ct_pathway : bool
        Whether the patient enters an advanced CT imaging pathway.
    sdec_pathway : bool
        Whether the patient is routed through SDEC.
    thrombolysis : bool
        Whether the patient receives thrombolysis.
    thrombectomy : bool
        Whether the patient receives thrombectomy.
    admission_avoidance : bool
        Whether the patient avoids an admission by being seen in SDEC instead.

    Notes
    -----
    GENAI declaration (SR): this docstring has been generated with the aid
    of ChatGPT 5.1.
    All generated content has been thoroughly reviewed.
    """

    def __init__(self, p_id):
        self.id = p_id
        self.q_time_nurse = np.NaN  # SR NOTE - changed this to NaN by default
        self.q_time_ward = np.NaN  # SR NOTE - changed this to NaN by default
        # 0 = known onset, 1 = unknown onset (in ctp range), 2 = unknown (out of
        # ctp range)
        self.onset_type = random.randint(0, 2)
        # Max MRS is set to 5
        self.mrs_type = min(round(random.expovariate(1.0 / g.mean_mrs)), 5)
        self.mrs_discharge = np.NaN  # SR NOTE - changed this to NaN by default
        # <=5 is ICH, <=55 is I, <= 70 is TIA, <=85 is Stroke Mimic, >85 is non\
        # stroke, this set in g class
        self.diagnosis = random.randint(0, 100)
        # 0 = ICH, 1 = I, 2 = TIA, 3 = Stroke Mimic, 4 = non stroke
        self.patient_diagnosis = np.NaN  # SR NOTE - changed this to NaN by default
        self.priority = 1
        self.non_admission = random.randint(0, 100)
        self.advanced_ct_pathway = False
        self.sdec_pathway = False
        self.thrombolysis = False
        self.thrombectomy = False
        self.admission_avoidance = False

        # NOTE: Additional items added by SR
        self.ward_los = np.NaN
        self.ward_los_thrombolysis = np.NaN
        self.sdec_los = np.NaN
        self.ctp_duration = np.NaN
        self.ct_duration = np.NaN
        self.arrived_ooh = False
        self.generated_during_warm_up = False
        self.patient_diagnosis_type = None


# MARK: Model
# Class representing the model of the stroke assessment / treatment process
class Model:
    """
    A SimPy simulation model representing a stroke patient pathway.

    This class coordinates the simulation environment, manages clinical resources
    (nurses, scanners, and beds), and tracks performance metrics throughout
    the duration of a simulation run.

    Parameters
    ----------
    run_number : int
        The unique identifier for the specific simulation run.

    Attributes
    ----------
    env : simpy.core.Environment
        The SimPy environment in which the simulation is executed.
    patient_counter : int
        A running count of patients who have entered the system, used as a unique ID.
        This is shared across in-hours and out-of-hours arrivals.
    nurse : simpy.resources.resource.Resource
        A SimPy resource representing stroke nurses available for assessment.
    ctp_scanner : simpy.resources.resource.PriorityResource
        A priority resource representing CTP scanners.
    sdec_bed : simpy.resources.resource.PriorityResource
        A priority resource representing Same Day Emergency Care (SDEC) beds.
    ward_bed : simpy.resources.resource.Resource
        A SimPy resource representing standard ward beds.
    run_number : int
        The identifier for the current simulation iteration.
    results_df : pd.DataFrame
        A central data repository for patient-level results, including queue times,
        lengths of stay, and diagnostic statuses.
    sdec_freeze_counter : int
        Counter tracking the frequency of SDEC capacity freezes.
    mean_q_time_nurse : float
        The calculated average time patients spent queuing for a nurse.
    mean_q_time_ward : float
        The calculated average time patients spent queuing for a ward bed.
    mean_los_ward : float
        The average length of stay for patients admitted to the ward.
    thrombolysis_savings : float
        Aggregated metric representing the savings or benefits derived from thrombolysis.
    q_for_assessment : list
        A list tracking patients currently waiting in the assessment queue.
    nurse_q_graph_df : pd.DataFrame
        Time-series data for monitoring nurse queue lengths over time.
    sdec_occupancy : list
        Historical record of SDEC bed utilization.
    admission_avoidance : list
        Historical record of patients who avoided inpatient admission.
    ward_occupancy : list
        Historical record of ward bed utilization.
    non_admissions : list
        Record of patients classified as non-admissions.
    occupancy_graph_df : pd.DataFrame
        Time-series data for monitoring ward occupancy levels.
    patient_objects : list
        A collection of all `Patient` class instances created during the simulation.

    Notes
    -----
    GENAI declaration (SR): this docstring has been generated with the aid
    of Google Gemini Flash.
    All generated content has been thoroughly reviewed.
    """

    # Constructor to set up the model for a run. We pass in a run number when
    # we create a new model.
    def __init__(self, run_number):
        # Create a SimPy environment
        self.env = simpy.Environment()

        # Create a patient counter for the first patient Generator
        self.patient_counter = 0

        # Create a SimPy resources to represent stroke nurses, ctp scanners,
        # sdec beds, and ward beds. Set in class g
        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)

        self.ctp_scanner = simpy.PriorityResource(self.env, capacity=g.number_of_ctp)

        self.sdec_bed = simpy.PriorityResource(self.env, capacity=g.sdec_beds)

        self.ward_bed = simpy.Resource(self.env, capacity=g.number_of_ward_beds)

        # Store the passed in run number
        self.run_number = run_number

        # Create a Pandas DataFrame that will store a majority of the results
        # with the patient ID as the index.
        self.results_df = pd.DataFrame()
        self.results_df["Patient ID"] = [1]
        self.results_df["Q Time Nurse"] = [0.0]
        self.results_df["Time with Nurse"] = [0.0]
        self.results_df["Q Time Ward"] = [0.0]
        self.results_df["Ward LOS"] = [0.0]
        self.results_df["Time with CTP"] = [0.0]
        self.results_df["Time with CT"] = [0.0]
        self.results_df["Time in SDEC"] = [0.0]
        self.results_df["CTP Status"] = [""]
        self.results_df["SDEC Status"] = [""]
        self.results_df["Thrombolysis"] = [""]
        self.results_df["SDEC Occupancy"] = [0.0]
        self.results_df["Admission Avoidance"] = [""]
        self.results_df["SDEC Savings"] = [0.0]
        self.results_df["MRS Type"] = [0.0]
        self.results_df["MRS DC"] = [0.0]
        self.results_df["MRS Change"] = [0.0]
        self.results_df["Onset Type"] = [0.0]
        self.results_df["Diagnosis Type"] = [""]
        self.results_df["Thrombolysis Savings"] = [0.0]
        self.results_df["Ward Occupancy"] = [0.0]
        self.results_df["Arrival Time"] = [0.0]
        self.results_df["Patient Gen 1 Status"] = [""]
        self.results_df["Patient Gen 2 Status"] = [""]
        self.results_df.set_index("Patient ID", inplace=True)

        # A variable to count the number of SDEC freezes
        self.sdec_freeze_counter = 0

        # Create a variable to store the mean queuing time for the nurse
        self.mean_q_time_nurse = 0

        # Create a variable to store the mean time waiting for a ward bed
        self.mean_q_time_ward = 0

        # Create a variable to store the mean length of stay in the ward
        self.mean_los_ward = 0

        # Create a variable to store the mean number of thrombolysis savings
        self.thrombolysis_savings = 0

        # set up a list to store the queue for stroke nurse assessment
        self.q_for_assessment = []

        # a PD dataframe for the assessment queue graph
        self.nurse_q_graph_df = pd.DataFrame()
        self.nurse_q_graph_df["Time"] = [0.0]
        self.nurse_q_graph_df["Patients in Assessment Queue"] = [0.0]

        # a list that will store the number of patients in the SDEC
        self.sdec_occupancy = []

        # A list that will store the number of admissions avoided
        self.admission_avoidance = []

        # A list that will store the number of patients in the ward
        self.ward_occupancy = []

        # A list to store the number of patients avoiding admission
        self.non_admissions = []

        self.occupancy_graph_df = pd.DataFrame()
        self.occupancy_graph_df["Time"] = [0.0]
        self.occupancy_graph_df["Ward Occupancy"] = [0.0]

        # A list to store the patient objects
        self.patient_objects = []

    def is_in_hours(self, time_of_day):
        start = g.in_hours_start_mins
        end = g.ooh_start_mins

        if start < end:
            # Normal case (does not cross midnight)
            return start <= time_of_day < end
        else:
            # Wraps over midnight
            return time_of_day >= start or time_of_day < end

    def is_out_of_hours(self, time_of_day):
        return not self.is_in_hours(time_of_day)

    # MARK: M: in-hours arrivals
    # A generator function for the patient arrivals in hours.
    def generator_patient_arrivals(self):
        """
        A SimPy process generator that handles "in-hours" patient arrivals.

        This function runs as a continuous loop. It checks if the current
        simulation time is within daytime operating hours (0-960 minutes
        relative to the start of a 1440-minute day).

        If in-hours, it:

        1. Updates global arrival flags.

        2. Instantiates a new Patient object.

        3. Records trace information.

        4. Triggers the `stroke_assessment` process for the patient.

        5. Samples an inter-arrival time and yields a timeout.

        If out-of-hours, it yields a small timeout before checking again.

        Arrival rates are determined by `random.expovariate` using the
        `g.patient_inter_day` parameter. NOTE that this does not use the
        `g.patient_inter_day` parameter directly, and instead uses it alongside
        a rate modifier - careful inspection of the code to understand the impacts
        of changing `g.patient_inter_day` is recommended, and this may be adjusted
        in a future version of the model.

        Patients generated here have their `arrived_ooh` attribute set to False.

        This process triggers the `stroke_assessment` process for every
        newly created patient.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.
        """
        while True:
            # if 0 <= self.env.now % 1440 < 960
            time_of_day = self.env.now % 1440
            if self.is_in_hours(time_of_day):
                # Change the Global Class variable for the generator to TRUE
                g.patient_arrival_gen_1 = True
                g.patient_arrival_gen_2 = False

                # Increment the patient counter by 1 for each new patient
                self.patient_counter += 1

                # Create a new patient - an instance of the Patient Class we
                # defined above. patient counter ID passed from above to patient
                # class.
                p = Patient(self.patient_counter)
                self.patient_objects.append(p)

                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"â˜€ï¸ IN-HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.",
                    identifier=p.id,
                    config=g.trace_config,
                )

                p.arrived_ooh = False
                if self.env.now < g.warm_up_period:
                    p.generated_during_warm_up = True

                # Tell SimPy to start the stroke assessment function with
                # this patient (the generator function that will model the
                # patient's journey through the system)
                self.env.process(self.stroke_assessment(p))

                # TODO: SR query: explore whether this is the most intuitive/easily managed way to
                # handle interarrival rate. I think this means arrivals average
                # every 200 minutes.
                sampled_inter = random.expovariate(0.025 / g.patient_inter_day)
                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"â²ï¸ Next patient arriving in {sampled_inter:.1f} minutes",
                    config=g.trace_config,
                    identifier=p.id,
                )

                # Freeze this instance of this function in place until the
                # inter-arrival time has elapsed.
                yield self.env.timeout(sampled_inter)

            else:
                yield self.env.timeout(1)

    # MARK: M: OOH arrivals
    # A generator function for the patient arrivals out of hours.
    def generator_patient_arrivals_ooh(self):
        """
        A SimPy process generator that handles out-of-hours (OOH) patient arrivals.

        This function runs as a continuous loop, monitoring the simulation time
        to identify the "night" window (960 to 1440 minutes in a 24-hour cycle).
        When active, it instantiates patients and schedules their journey
        through the clinical pathway.

        If out-of-hours, it:

        1. Updates global arrival flags.

        2. Instantiates a new Patient object.

        3. Records trace information.

        4. Triggers the `stroke_assessment` process for the patient.

        5. Samples an inter-arrival time and yields a timeout.

        If in-hours, it yields a small timeout before checking again.

        Arrival rates are determined by `random.expovariate` using the
        `g.patient_inter_night` parameter. NOTE that this does not use the
        `g.patient_inter_night` parameter directly, and instead uses it alongside
        a rate modifier - careful inspection of the code to understand the impacts
        of changing `g.patient_inter_night` is recommended, and this may be adjusted
        in a future version of the model.

        Patients generated here have their `arrived_ooh` attribute set to True.

        This process triggers the `stroke_assessment` process for every
        newly created patient.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.

        """
        while True:
            # if 960 <= self.env.now % 1440 < 1440:
            time_of_day = self.env.now % 1440
            if self.is_out_of_hours(time_of_day):
                # Change the Global Class variable for the generator to TRUE
                g.patient_arrival_gen_1 = False
                g.patient_arrival_gen_2 = True

                # Increment the patient counter by 1 for each new patient
                self.patient_counter += 1

                # Create a new patient - an instance of the Patient Class we
                # defined above. patient counter ID passed from above to patient
                # class.
                p = Patient(self.patient_counter)
                self.patient_objects.append(p)

                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"ðŸŒ™ OUT OF HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.",
                    identifier=p.id,
                    config=g.trace_config,
                )

                p.arrived_ooh = True
                if self.env.now < g.warm_up_period:
                    p.generated_during_warm_up = True

                # Tell SimPy to start the stroke assessment function with
                # this patient (the generator function that will model the
                # patient's journey through the system)
                self.env.process(self.stroke_assessment(p))

                # TODO: SR query: explore whether this is the most intuitive/easily managed way to
                # handle interarrival rate. I think this means arrivals average
                # every 666.6 minutes.
                sampled_inter = random.expovariate(0.0075 / g.patient_inter_night)
                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"â²ï¸ Next OOH patient arriving in {sampled_inter:.1f} minutes",
                    identifier=p.id,
                    config=g.trace_config,
                )

                # Freeze this instance of this function in place until the
                # inter-arrival time has elapsed.
                yield self.env.timeout(sampled_inter)

            else:
                yield self.env.timeout(1)

    # MARK: M: Obstruct CTP
    def obstruct_ctp(self):
        """
        Simulates periodic CTP scanner unavailability (off time).

        This process acts as a "blocker" by requesting the CTP scanner resource
        with a priority of -1. Since patients typically have a priority of 1,
        this process effectively preempts the queue, preventing patients from
        using the scanners during this period.

        The scanner will not stop a scan that is already in progress;
        it waits for the current user to finish before taking the
        resource offline.

        Frequencies and durations are governed by `g.ctp_unav_freq`
        and `g.ctp_unav_time`.

        Yields
        ------
        simpy.events.Timeout
            Initial offset for opening hours and subsequent intervals
            between downtime events.
        simpy.events.ResourceRequest
            A high-priority request to seize the CTP scanner and take
            it "offline."

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.

        """
        # TODO SR: Confirm this is ok with John
        # SR: Add initial offset
        # SR: Patient generators have also been updated
        # to match with how this is working
        yield self.env.timeout(g.ctp_opening_hour * 60)

        while True:
            yield self.env.timeout(g.ctp_unav_freq)
            # Once elapsed, this generator requests the ctp scanner with
            # a priority of -1. As the patient priority is set at 1
            # the scanner will take priority over any patients waiting.
            # This method also means that the scanner won't stop mid scan.
            g.ctp_unav = True
            with self.ctp_scanner.request(priority=-1) as req:
                yield req
                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"ðŸ”¬ CTP scanner OFFLINE at {minutes_to_ampm(int(self.env.now % 1440))}",
                    identifier=self.patient_counter,
                    config=g.trace_config,
                )
                # Freeze with the scanners held in place for the unavailability
                # time, in the model this means patients admitted in this time
                # will not have a ctp scan.
                # freq and unav times are set in the g class
                yield self.env.timeout(g.ctp_unav_time)
                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"ðŸ”¬ CTP scanner back ONLINE at {minutes_to_ampm(int(self.env.now % 1440))}",
                    identifier=self.patient_counter,
                    config=g.trace_config,
                )
                g.ctp_unav = False

    # MARK: M: Obstruct SDEC
    def obstruct_sdec(self):
        """
        Simulates the scheduled closure or unavailability of the SDEC unit.

        Similar to the CTP obstruction, this process seizes an SDEC bed
        at a high priority (-1) for a defined duration. This models the
        real-world scenario where the SDEC unit closes at night or
        during specific hours, forcing patients to bypass this pathway.

        If a closure occurs after the simulation warm-up period, the
        `sdec_freeze_counter` is incremented.

        Patients arriving while the SDEC is "obstructed" will be
        unable to access SDEC resources.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.
        """
        # TODO SR: Confirm this is ok with John
        #  SR: Add initial offset
        # SR: Patient generators have also been updated
        # to match with how this is working
        yield self.env.timeout(g.sdec_opening_hour * 60)

        while True:
            yield self.env.timeout(g.sdec_unav_freq)
            # Once elapsed, this generator requests the SDEC with
            # a priority of -1. As the patient priority is set at 1
            # the SDEC will take priority over any patients waiting.
            g.sdec_unav = True
            with self.sdec_bed.request(priority=-1) as req:
                yield req
                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"ðŸ¥ SDEC CLOSES at {minutes_to_ampm(int(self.env.now % 1440))}",
                    identifier=self.patient_counter,
                    config=g.trace_config,
                )

                # Freeze with the SDEC held in place for the unavailability
                # time, in the model this means patients admitted in this time
                # will not have passed through the SDEC.
                # freq and unav times are set in the g class
                yield self.env.timeout(g.sdec_unav_time)
                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"ðŸ¥ SDEC OPENS at {minutes_to_ampm(int(self.env.now % 1440))}",
                    identifier=self.patient_counter,
                    config=g.trace_config,
                )
                g.sdec_unav = False
                if self.env.now > g.warm_up_period:
                    self.sdec_freeze_counter += 1

    # MARK: M: Stroke assessment
    # A generator function that represents the pathway for a patient going
    # through the stroke assessment process.
    # The patient object is passed in to the generator function so we can
    # extract information from / record information to it
    def stroke_assessment(self, patient):
        """
        Simulates the full assessment and treatment pathway for patients
        in a stroke pathway.

        Parameters
        ----------
        patient : Instance of class `Patient`
            One single unique patient object.
        """
        # This code introduces a slight element of randomness into the patient's
        # diagnosis.

        self.ich_range = random.normalvariate(g.ich, 1)
        self.i_range = max(random.normalvariate(g.i, 1), self.ich_range)
        self.tia_range = max(random.normalvariate(g.tia, 1), self.i_range)
        self.stroke_mimic_range = max(
            random.normalvariate(g.stroke_mimic, 1), self.tia_range
        )
        self.non_stroke_range = max(
            random.normalvariate(g.stroke_mimic, 1), self.stroke_mimic_range
        )

        if patient.diagnosis <= self.ich_range:
            patient.patient_diagnosis = 0
        elif patient.diagnosis <= self.i_range:
            patient.patient_diagnosis = 1
        elif patient.diagnosis <= self.tia_range:
            patient.patient_diagnosis = 2
        elif patient.diagnosis <= self.stroke_mimic_range:
            patient.patient_diagnosis = 3
        elif patient.diagnosis > self.non_stroke_range:
            patient.patient_diagnosis = 4
        # TODO: SR have added this else clause but need to confirm this is correct
        # TODO: SR patients were occasionally not getting allocated a diagnosis and
        # TODO: SR this would then cause issues with generating LOS etc
        else:
            patient.patient_diagnosis = 4

        trace(
            time=self.env.now,
            debug=g.show_trace,
            msg=f"Patient {patient.id} Patient Diagnosis (category 1-4): {patient.patient_diagnosis}.",
            identifier=patient.id,
            config=g.trace_config,
        )

        # Record the time the patient started queuing for a nurse
        start_q_nurse = self.env.now

        self.q_for_assessment.append(patient)

        # Add the arrival time to the main DF, this is mainly to test if the
        # patinet arrival times mirror the real world data

        patient.clock_start = self.env.now

        if self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Arrival Time"] = patient.clock_start

            self.results_df.at[patient.id, "Patient Gen 1 Status"] = (
                g.patient_arrival_gen_1
            )

            self.results_df.at[patient.id, "Patient Gen 2 Status"] = (
                g.patient_arrival_gen_2
            )

        # This code says request a nurse resource, and do all of the following
        # block of code with that nurse resource held in place (and therefore
        # not usable by another patient)
        with self.nurse.request() as req:
            # Freeze the function until the request for a nurse can be met.
            # The patient is currently queuing.
            yield req

            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"ðŸ‘©â€âš•ï¸ Patient {patient.id} is being seen by a nurse at {minutes_to_ampm(int(self.env.now % 1440))}.",
                identifier=patient.id,
                config=g.trace_config,
            )

            # Control is passed back to the generator function once the request
            # is met for a nurse. As the queue for the nurse is finished
            # the patient then leaves the assessment queue list.

            end_q_nurse = self.env.now

            self.q_for_assessment.remove(patient)

            # The code below checks if the warm up period has passed before
            # entering data into the df, this code exists when ever data is
            # recorded

            if self.env.now > g.warm_up_period:
                self.nurse_q_graph_df.loc[len(self.nurse_q_graph_df)] = [
                    self.env.now,
                    len(self.q_for_assessment),
                ]

            # Calculate the time this patient was queuing for the nurse, and
            # record it in the patient's attribute
            patient.q_time_nurse = end_q_nurse - start_q_nurse

            # The below code creates a random action time for the nurse based
            # on the mean in g class, and assigns it ot a variable. Currently
            # using a Exponential distribution but might need to switch to
            # a Log normal one (though the intense variation in the real life
            # consult time might mean a exponetial distribution is better)
            sampled_nurse_act_time = random.expovariate(1.0 / g.mean_n_consult_time)

            # Freeze this function in place for the activity time we sampled
            # above.  This is the patient spending time with the nurse.
            yield self.env.timeout(sampled_nurse_act_time)

            # In the .at function below, the first value is the row, the second
            # value is the column in which to add data. The final value is the
            # the data that is to be added to the DF, in this case the Nurse
            # Q time

            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "Q Time Nurse"] = patient.q_time_nurse
                self.results_df.at[patient.id, "Time with Nurse"] = (
                    sampled_nurse_act_time
                )

        # MARK: CT Perfusion Scanner Use
        # The if formula below checks to see if the CTP scanner is active
        # and if it is the following code is followed including updating the
        # patient advanced CT pathway attribute

        if g.ctp_unav == False:
            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"âž¡ï¸ Patient {patient.id} sent on CTP scanner pathway at {minutes_to_ampm(int(self.env.now % 1440))}.",
                identifier=patient.id,
                config=g.trace_config,
            )

            patient.advanced_ct_pathway = True

            # Randomly sample the mean ct time, as with above this may need to
            # be updated to a log normal distribution

            sampled_ctp_act_time = random.expovariate(1.0 / g.mean_n_ct_time)
            patient.ctp_duration = sampled_ctp_act_time
            # Freeze this function in place for the activity time that was
            # sampled above.
            yield self.env.timeout(sampled_ctp_act_time)
            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"âž¡ï¸ Patient {patient.id} finishes CTP scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ctp_act_time:.1f} minutes.",
                identifier=patient.id,
                config=g.trace_config,
            )

            # Add data to the DF afer the warm up period.

            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "Time with CTP"] = sampled_ctp_act_time

        # If the CTP pathway is not active the below code runs, it is the same
        # as the above however adds data to a different column and the patient
        # advanced CT pathway remains False.

        else:
            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"ðŸš« Patient {patient.id} NOT sent on CTP scanner pathway - normal CT scan commencing at {minutes_to_ampm(int(self.env.now % 1440))}.",
                identifier=patient.id,
                config=g.trace_config,
            )

            # TODO: SR: Confirm if ct act time should still pass in this instance
            # TODO: SR: Is a standard CT scan performed when CT perfusion scanner not available?
            sampled_ct_act_time = random.expovariate(1.0 / g.mean_n_ct_time)
            patient.ct_duration = sampled_ct_act_time

            yield self.env.timeout(sampled_ct_act_time)

            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"ðŸš« Patient {patient.id} finishes normal CT scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ct_act_time:.1f} minutes.",
                identifier=patient.id,
                config=g.trace_config,
            )

            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "Time with CT"] = sampled_ct_act_time

        # The below code records the status of both the CTP pathway.
        # Both exist as generators and this data is record to ensure they are
        # operating as expected.

        if self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "CTP Status"] = g.ctp_unav

        # The below code checks the patient's attributes to see if the
        # thrombolysis attribute should be changed to True, this is based off
        # the patient diagnosis, onset type and mrs type. There are different
        # conditions depending on if CTP is available or not.

        if (
            patient.patient_diagnosis == 1
            and patient.onset_type == 0
            and patient.mrs_type > 0
        ):
            patient.thrombolysis = True

        if (
            patient.patient_diagnosis == 1
            and patient.onset_type == 1
            and patient.advanced_ct_pathway == True
            and patient.mrs_type > 0
        ):
            patient.thrombolysis = True

        # Thrombolysis status is added to the DF, this is mainly used to check
        # if it is being applied correctly.

        if self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Thrombolysis"] = patient.thrombolysis

        # The below code records the status of both the SDEC pathway.
        # Both exist as generators and this data is recorded to ensure they are
        # operating as expected.

        if self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "SDEC Status"] = g.sdec_unav

        # MARK: SDEC Admission
        # The if statement below checks if the SDEC pathway is active at this
        # given time and if there is space in the SDEC itself.

        if g.sdec_unav == False and len(self.sdec_occupancy) <= g.sdec_beds:
            # If the conditions above are met the patient attribute for the SDEC
            # are changed to True and the patient is added to the SDEC occupancy
            # list.
            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"ðŸ›ï¸ðŸŽï¸ Patient {patient.id} admitted to SDEC (occupancy before admission: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds) at {minutes_to_ampm(int(self.env.now % 1440))}.",
                identifier=patient.id,
                config=g.trace_config,
            )

            self.sdec_occupancy.append(patient)

            # The below code record the SDEC Occupancy as the patient passes
            # this point to ensure it is working as expected.

            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "SDEC Occupancy"] = len(
                    self.sdec_occupancy
                )

            patient.sdec_pathway = True

            # This code checks if the patient is eligible for admission
            # avoidance depending on if therapy support is enabled.

            if g.therapy_sdec == False:
                if (
                    patient.patient_diagnosis < 2
                    and patient.mrs_type < 2
                    and patient.thrombolysis == False
                ):
                    patient.admission_avoidance = True

            elif g.therapy_sdec == True:
                if (
                    patient.patient_diagnosis < 2
                    and patient.mrs_type <= 3
                    and patient.thrombolysis == False
                ):
                    patient.admission_avoidance = True

            # This code applies a non stroke admission avoidance variable to the
            # patient.

            self.tia_admission_chance = random.normalvariate(g.tia_admission, 1)
            self.stroke_mimic_admission_chance = random.normalvariate(
                g.stroke_mimic_admission, 1
            )

            if (
                patient.non_admission >= self.tia_admission_chance
                and patient.patient_diagnosis == 2
            ):
                patient.admission_avoidance = True

            elif (
                patient.non_admission >= self.stroke_mimic_admission_chance
                and patient.patient_diagnosis > 2
            ):
                patient.admission_avoidance = True

            # Calculate SDEC stay time from exponential
            sampled_sdec_stay_time = random.expovariate(1.0 / g.mean_n_sdec_time)

            # Add patient SDEC LOS to their patient object
            patient.sdec_los = sampled_sdec_stay_time
            # Freeze this function in place for the activity time we sampled
            # above.
            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in SDEC for {sampled_sdec_stay_time:.1f} minutes ({(sampled_sdec_stay_time / 60 / 24):.1f} days).",
                identifier=patient.id,
                config=g.trace_config,
            )
            yield self.env.timeout(sampled_sdec_stay_time)

            # This code checks if the ward is full, if this is the case the
            # patient will not be released from the SDEC, thus impeding it use

            if patient.admission_avoidance != True:
                while len(self.ward_occupancy) >= g.number_of_ward_beds:
                    yield self.env.timeout(1)

            # Once the above code is complete the patient is removed from the
            # SDEC occupancy list.

            self.sdec_occupancy.remove(patient)

            # Code to record the SDEC stay time in the results DataFrame.

            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "Time in SDEC"] = sampled_sdec_stay_time

            # MARK: Discharged from SDEC
            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"ðŸŽï¸ Patient {patient.id} discharged from SDEC at {minutes_to_ampm(int(self.env.now % 1440))} after {patient.sdec_los:.1f} minutes ({(patient.sdec_los / 60 / 24):.1f} days). Occupancy after discharge: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds",
                identifier=patient.id,
                config=g.trace_config,
            )

        # The below code records the patients diagnosis attribute, this is added
        # to the DF to check the diagnosis code is working correctly.

        if patient.patient_diagnosis == 0 and self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Diagnosis Type"] = "ICH"
            patient.patient_diagnosis_type = "ICH"
        elif patient.patient_diagnosis == 1 and self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Diagnosis Type"] = "I"
            patient.patient_diagnosis_type = "I"
        elif patient.patient_diagnosis == 2 and self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Diagnosis Type"] = "TIA"
            patient.patient_diagnosis_type = "TIA"
        elif patient.patient_diagnosis == 3 and self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Diagnosis Type"] = "Stroke Mimic"
            patient.patient_diagnosis_type = "Stroke Mimic"
        elif patient.patient_diagnosis == 4 and self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Diagnosis Type"] = "Non Stroke"
            patient.patient_diagnosis_type = "Non Stroke"

        if self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "Onset Type"] = patient.onset_type

        # This code add information regarding the patients admission avoidance.

        if patient.admission_avoidance == True and patient.patient_diagnosis < 2:
            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "Admission Avoidance"] = (
                    patient.sdec_pathway
                )

                last_index = self.results_df["SDEC Savings"].last_valid_index()
                last_value = self.results_df.loc[last_index, "SDEC Savings"]
                if last_index > 0 and pd.notnull:
                    self.results_df.at[patient.id, "SDEC Savings"] = (
                        last_value + g.inpatient_bed_cost
                    )

                else:
                    self.results_df.at[patient.id, "SDEC Savings"] = (
                        g.inpatient_bed_cost
                    )

        # This code adds the Patient's MRS to the DF, this can be used to check
        # all code that interacts with this runs correctly.

        if self.env.now > g.warm_up_period:
            self.results_df.at[patient.id, "MRS Type"] = patient.mrs_type

        # Patients with a True admission avoidance are added to a list that is
        # used to calculate the savings from the avoided admissions.

        if (
            patient.admission_avoidance == True
            and patient.patient_diagnosis < 2
            and self.env.now > g.warm_up_period
        ):
            self.admission_avoidance.append(patient)

        # This code introduces a small element of randomness into the admission
        # rates for the non stroke, tia and stroke mimic patients.

        self.tia_admission_chance = random.normalvariate(g.tia_admission, 1)
        self.stroke_mimic_admission_chance = random.normalvariate(
            g.stroke_mimic_admission, 1
        )

        # This code exists after the admission avoidance code so they are not
        # added to the admission avoidance list, as that should only be for
        # SDEC patients who avoid admission. This code checks if TIA, non stroke
        # and stroke mimic patients should be admitted based on the values
        # established in the previous code and g class.

        if (
            patient.non_admission >= self.tia_admission_chance
            and patient.patient_diagnosis == 2
        ):
            patient.admission_avoidance = True

        elif (
            patient.non_admission >= self.stroke_mimic_admission_chance
            and patient.patient_diagnosis > 2
        ):
            patient.admission_avoidance = True

        # MARK: Ward Admission
        # once all the above code has been run all patients who will not admit
        # have a True admission avoidance attribute. For all the patients that
        # remain false, the below code will run simulating the admission to the
        # ward.

        if patient.admission_avoidance != True:
            # These code assigns a time to the start q variable. In stroke care
            # delays can have serious consequence so modeling this is very
            # important as flow disruption are a common issue.

            start_q_ward = self.env.now

            # Request the ward bed and hold the patient in a queue until this
            # is met.

            with self.ward_bed.request() as req:
                yield req
                # Add patient to the ward list

                self.ward_occupancy.append(patient)
                trace(
                    time=self.env.now,
                    debug=g.show_trace,
                    msg=f"ðŸ›ï¸ Patient {patient.id} admitted to main ward at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy after admission: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds",
                    identifier=patient.id,
                    config=g.trace_config,
                )

                if self.env.now > g.warm_up_period:
                    self.results_df.at[patient.id, "Ward Occupancy"] = len(
                        self.ward_occupancy
                    )

                if self.env.now > g.warm_up_period:
                    self.occupancy_graph_df.loc[len(self.occupancy_graph_df)] = [
                        self.env.now,
                        len(self.ward_occupancy),
                    ]

                # The patient attribute for the queuing time in the ward is
                # assigned here.

                end_q_ward = self.env.now

                patient.q_time_ward = end_q_ward - start_q_ward

                # The below code checks the patients diagnosis and MRS,
                # adjusting MRS change and LOS baised on these. This code is
                # for ICH patients.

                ###############################
                # MARK: Patient diagnosis = 0 #
                # Intracerebral haemorrhage   #
                # Unsuitable for thrombolysis #
                ###############################

                if patient.patient_diagnosis == 0 and patient.mrs_type == 0:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_ich_ward_time_mrs_0
                    )
                    patient.mrs_discharge = patient.mrs_type
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 0 and patient.mrs_type == 1:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_ich_ward_time_mrs_1
                    )
                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 0 and patient.mrs_type == 2:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_ich_ward_time_mrs_2
                    )
                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 0 and patient.mrs_type == 3:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_ich_ward_time_mrs_3
                    )
                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 0 and patient.mrs_type == 4:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_ich_ward_time_mrs_4
                    )
                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 0 and patient.mrs_type == 5:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_ich_ward_time_mrs_5
                    )
                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                ###############################
                # MARK: Patient diagnosis = 1 #
                # Ischaemic Stroke            #
                # Some may be suitable for    #
                # thrombolysis                #
                ###############################

                # The below code checks the patients diagnosis and MRS,
                # adjusting MRS change and LOS baised on these. This code is
                # for I patients amd also checks for thrombolysis and adjusts
                # LOS and associated savings accordingly.

                if patient.patient_diagnosis == 1 and patient.mrs_type == 0:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_i_ward_time_mrs_0
                    )
                    patient.mrs_discharge = patient.mrs_type
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 1 and patient.mrs_type == 1:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_i_ward_time_mrs_1
                    )
                    if patient.thrombolysis == True:
                        sampled_ward_act_time_thrombolysis = (
                            sampled_ward_act_time * g.thrombolysis_los_save
                        )
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"ðŸ’‰ Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los_thrombolysis = (
                            sampled_ward_act_time_thrombolysis
                        )
                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)
                        if (
                            self.env.now > g.warm_up_period
                            and patient.advanced_ct_pathway == True
                        ):
                            self.results_df.at[patient.id, "Thrombolysis Savings"] = (
                                (
                                    (
                                        sampled_ward_act_time
                                        - sampled_ward_act_time_thrombolysis
                                    )
                                    / 60
                                )
                                / 24
                            ) * g.inpatient_bed_cost_thrombolysis
                        self.ward_occupancy.remove(patient)
                    else:
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los = sampled_ward_act_time
                        yield self.env.timeout(sampled_ward_act_time)
                        self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 1 and patient.mrs_type == 2:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_i_ward_time_mrs_2
                    )
                    if patient.thrombolysis == True:
                        sampled_ward_act_time_thrombolysis = (
                            sampled_ward_act_time * g.thrombolysis_los_save
                        )
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"ðŸ’‰ Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los_thrombolysis = (
                            sampled_ward_act_time_thrombolysis
                        )
                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)
                        if (
                            self.env.now > g.warm_up_period
                            and patient.advanced_ct_pathway == True
                        ):
                            self.results_df.at[patient.id, "Thrombolysis Savings"] = (
                                (
                                    (
                                        sampled_ward_act_time
                                        - sampled_ward_act_time_thrombolysis
                                    )
                                    / 60
                                )
                                / 24
                            ) * g.inpatient_bed_cost_thrombolysis
                        self.ward_occupancy.remove(patient)
                    else:
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los = sampled_ward_act_time
                        yield self.env.timeout(sampled_ward_act_time)
                        self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 1 and patient.mrs_type == 3:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_i_ward_time_mrs_3
                    )
                    if patient.thrombolysis == True:
                        sampled_ward_act_time_thrombolysis = (
                            sampled_ward_act_time * g.thrombolysis_los_save
                        )
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"ðŸ’‰ Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los_thrombolysis = (
                            sampled_ward_act_time_thrombolysis
                        )
                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)
                        if (
                            self.env.now > g.warm_up_period
                            and patient.advanced_ct_pathway == True
                        ):
                            self.results_df.at[patient.id, "Thrombolysis Savings"] = (
                                (
                                    (
                                        sampled_ward_act_time
                                        - sampled_ward_act_time_thrombolysis
                                    )
                                    / 60
                                )
                                / 24
                            ) * g.inpatient_bed_cost_thrombolysis
                        self.ward_occupancy.remove(patient)
                    else:
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los = sampled_ward_act_time
                        yield self.env.timeout(sampled_ward_act_time)
                        self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 1 and patient.mrs_type == 4:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_i_ward_time_mrs_4
                    )
                    if patient.thrombolysis == True:
                        sampled_ward_act_time_thrombolysis = (
                            sampled_ward_act_time * g.thrombolysis_los_save
                        )
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"ðŸ’‰ Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los_thrombolysis = (
                            sampled_ward_act_time_thrombolysis
                        )
                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)
                        if (
                            self.env.now > g.warm_up_period
                            and patient.advanced_ct_pathway == True
                        ):
                            self.results_df.at[patient.id, "Thrombolysis Savings"] = (
                                (
                                    (
                                        sampled_ward_act_time
                                        - sampled_ward_act_time_thrombolysis
                                    )
                                    / 60
                                )
                                / 24
                            ) * g.inpatient_bed_cost_thrombolysis
                        self.ward_occupancy.remove(patient)
                    else:
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        patient.ward_los = sampled_ward_act_time
                        yield self.env.timeout(sampled_ward_act_time)
                        self.ward_occupancy.remove(patient)

                elif patient.patient_diagnosis == 1 and patient.mrs_type == 5:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_i_ward_time_mrs_5
                    )
                    if patient.thrombolysis == True:
                        sampled_ward_act_time_thrombolysis = (
                            sampled_ward_act_time * g.thrombolysis_los_save
                        )
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"ðŸ’‰ Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        # Record generated LOS in patient object
                        patient.ward_los_thrombolysis = (
                            sampled_ward_act_time_thrombolysis
                        )
                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)
                        if (
                            self.env.now > g.warm_up_period
                            and patient.advanced_ct_pathway == True
                        ):
                            self.results_df.at[patient.id, "Thrombolysis Savings"] = (
                                (
                                    (
                                        sampled_ward_act_time
                                        - sampled_ward_act_time_thrombolysis
                                    )
                                    / 60
                                )
                                / 24
                            ) * g.inpatient_bed_cost_thrombolysis
                        self.ward_occupancy.remove(patient)
                    else:
                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)
                        trace(
                            time=self.env.now,
                            debug=g.show_trace,
                            msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                            identifier=patient.id,
                            config=g.trace_config,
                        )
                        # Record generated LOS in patient object
                        patient.ward_los = sampled_ward_act_time
                        yield self.env.timeout(sampled_ward_act_time)
                        self.ward_occupancy.remove(patient)

                #################################
                # MARK: Patient diagnosis = 2   #
                # Transient Ischaemic Attack    #
                # Not suitable for thrombolysis #
                #################################
                # The below code is for the non stroke diagnosis.

                if patient.patient_diagnosis == 2:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_tia_ward_time
                    )
                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )
                    # Record generated LOS in patient object
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

                ###############################
                # MARK: Patient diagnosis > 2 #
                # Stroke mimic OR non-stroke  #
                ###############################
                if patient.patient_diagnosis > 2:
                    sampled_ward_act_time = random.expovariate(
                        1.0 / g.mean_n_non_stroke_ward_time
                    )

                    trace(
                        time=self.env.now,
                        debug=g.show_trace,
                        msg=f"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).",
                        identifier=patient.id,
                        config=g.trace_config,
                    )

                    # Record generated LOS in patient object
                    patient.ward_los = sampled_ward_act_time
                    yield self.env.timeout(sampled_ward_act_time)
                    self.ward_occupancy.remove(patient)

            # Relevent information is recorded in the results DataFrame.
            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "Q Time Ward"] = patient.q_time_ward

            # TODO: SR: Confirm this is expected
            # SR: This triggered an error in a patient with a diagnosis of 1 and MRS of 0
            # who didn't seem to have a ward stay
            # TODO: SR: I've tweaked this to take whichever of the ward_los or thrombolysis los is generated
            # TODO SR: It would be better to take a more robust approach to this step.
            try:
                final_ward_los = sampled_ward_act_time
            except:
                final_ward_los = sampled_ward_act_time_thrombolysis

            if self.env.now > g.warm_up_period:
                self.results_df.at[patient.id, "Ward LOS"] = final_ward_los

                self.results_df.at[patient.id, "MRS DC"] = patient.mrs_discharge

                self.results_df.at[patient.id, "MRS Change"] = (
                    patient.mrs_type - patient.mrs_discharge
                )

            # MARK: Discharged from main ward
            trace(
                time=self.env.now,
                debug=g.show_trace,
                msg=f"ðŸš— Patient {patient.id} discharged from main ward at {minutes_to_ampm(int(self.env.now % 1440))} after {final_ward_los:.1f} minutes ({(final_ward_los / 24 / 60):.1f} days). Occupancy after discharge: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds",
                identifier=patient.id,
                config=g.trace_config,
            )

    # MARK: M: Run result calculation
    # This method calculates results over a single run.
    def calculate_run_results(self):
        """
        Calculate summary statistics and financial metrics for a single simulation run.

        This method aggregates raw data collected throughout the simulation,
        performs unit conversions, and computes Key Performance Indicators (KPIs)
        related to clinical flow and financial impact. It cleans the results
        dataframe and updates class-level attributes for use in trial-level reporting.

        - **Data Cleaning**: Removes the initial dummy row (index label 1) used
          to initialize the `results_df`.
        - **Unit Conversions**: Automatically converts ward-related timings
          (Queue Time and Length of Stay) from minutes to hours for reporting.
        - **SDEC Logic**: Financial staff costs for SDEC are adjusted based on
          the `sdec_freeze_counter` to ensure costs are only incurred during
          active operational periods.
        - **Precision**:
            - Financial and time-based KPIs are rounded to 0 decimal places.
            - Clinical outcomes (MRS Change) are rounded to 2 decimal places.

        Calculated Attributes
        ---------------------
        mean_q_time_nurse : float
            Average wait time for a nurse in minutes.
        number_of_admissions_avoided : int
            Total count of patients diverted from inpatient wards via SDEC.
        mean_q_time_ward : float
            Average wait time for a ward bed in hours.
        mean_ward_occupancy : float
            The average number of beds occupied during the run.
        admission_delays : int
            Total number of patients who experienced any wait time for a ward bed.
        mean_los_ward : float
            Average inpatient length of stay in hours.
        sdec_financial_savings : float
            Gross savings based on avoided bed days.
        medical_staff_cost : float
            The net operational cost of SDEC staffing.
        savings_sdec : float
            Net financial impact (Savings - Costs) of the SDEC unit.
        total_savings : float
            Combined net impact of SDEC and thrombolysis-related savings.
        mean_mrs_change : float
            Average change in Modified Rankin Scale for the patient cohort.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.
        """
        # Drop the first row of the results DataFrame, as this is just a dummy
        # and will take on the value of zero.
        self.results_df.drop([1], inplace=True)

        # The below code calculates the average or cumulative values the model
        # is concerned with.

        self.mean_q_time_nurse = round(self.results_df["Q Time Nurse"].mean(), 0)

        self.number_of_admissions_avoided = len(self.admission_avoidance)

        self.mean_q_time_ward = round(self.results_df["Q Time Ward"].mean() / 60, 0)

        self.mean_ward_occupancy = round(self.results_df["Ward Occupancy"].mean())

        self.admission_delays = len(self.results_df[self.results_df["Q Time Ward"] > 0])

        self.mean_los_ward = round(self.results_df["Ward LOS"].mean() / 60, 0)

        self.sdec_financial_savings = (
            len(self.admission_avoidance) * g.inpatient_bed_cost
        )

        # The below code ensures that the SDEC incurs no cost if it is not
        # running at all in the model. This was introduced as a bug was causing
        # it to return small values even if the SDEC was not running. This is
        # now fixed, but the code works so I have left it in place.

        if g.sdec_unav_freq == 0:
            self.medical_staff_cost = 0
        else:
            self.medical_staff_cost = round(
                g.sdec_dr_cost_min * (g.sim_duration)
                - g.sdec_dr_cost_min * self.sdec_freeze_counter * g.sdec_unav_time,
                0,
            )

        self.savings_sdec = round(
            self.sdec_financial_savings - self.medical_staff_cost, 0
        )

        self.thrombolysis_savings = round(
            self.results_df["Thrombolysis Savings"].sum(), 0
        )
        self.total_savings = self.thrombolysis_savings + self.savings_sdec

        self.mean_mrs_change = round(self.results_df["MRS Change"].mean(), 2)

    # MARK: M: per-run plotting
    # This method plots the stroke nurse assessment queue graph, as it is after
    # the run method it will appear after the run has completed in the output.
    # Might need to change this...

    def plot_stroke_run_graphs(self, plot=True):
        """
        Generate and display time-series visualizations for the simulation run.

        This method creates a line plot of the Stroke Ward occupancy over the
        duration of the simulation. It includes both the raw occupancy data
        and a linear trend line to help identify long-term capacity issues.
        Execution is dependent on the global `g.gen_graph` toggle.

        - **Data Cleaning**: Automatically drops the first row (index 0) of
          `occupancy_graph_df`, which is typically used as a placeholder.
        - **Trend Analysis**: Uses a first-order polynomial fit (`numpy.polyfit`)
          to calculate and display a linear trend line over the occupancy data.
        - **Extensibility**: Contains placeholder (commented-out) logic for
          an additional "Nurse Assessment Queue" graph.
        - **Dependencies**: Requires `matplotlib.pyplot` as `plt` and
          `numpy` as `np`.

        Parameters
        ----------
        plot : bool, default True
            If True, the generated figure is displayed immediately using
            `plt.show()`. If False, the figure object is returned to the
            caller for further processing (e.g., aggregation in a Trial report).

        Returns
        -------
        matplotlib.figure.Figure or None
            Returns a Matplotlib Figure object if `plot` is False.
            Returns None if `plot` is True or if `g.gen_graph` is False.


        See Also
        --------
        Trial.run_trial : The method that may collect these figures for batch reporting.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.
        """
        if g.gen_graph == True:
            # Queue for Nurse Assessment Graph (Currently Commented Out)

            # self.nurse_q_graph_df.drop([0], inplace=True)

            # fig, ax = plt.subplots()

            # ax.set_xlabel("Time")
            # ax.set_ylabel("Number of patients in Q for Assessment")
            # ax.set_title(f"Number of Patients in Nurse Assessment Queue \
            # Over Time "f"{self.run_number}")

            # ax.plot(self.nurse_q_graph_df["Time"],
            # self.nurse_q_graph_df["Patients in Assessment Queue"],
            # color="m",
            # linestyle="-",
            # label="Q for Stroke Nurse Assessment")

            # ax.legend(loc="upper right")

            # fig.show()

            # Ward Occupancy Graph

            self.occupancy_graph_df.drop([0], inplace=True)

            fig, ax = plt.subplots()

            ax.set_xlabel("Time")
            ax.set_ylabel("Stroke Ward Occupancy")
            ax.set_title(
                f"Trial "
                f"{g.trials_run_counter}\
                         Ward Occupancy Over Time "
                f"{self.run_number}"
            )

            ax.plot(
                self.occupancy_graph_df["Time"],
                self.occupancy_graph_df["Ward Occupancy"],
                color="b",
                linestyle="-",
                label="Ward Occupancy",
            )

            # Add trend line
            x = self.occupancy_graph_df["Time"]
            y = self.occupancy_graph_df["Ward Occupancy"]
            z = np.polyfit(x, y, 1)  # 1 = linear fit
            p = np.poly1d(z)
            ax.plot(x, p(x), color="b", linestyle="--", label="Trend Line")

            ax.legend(loc="upper right")

            if plot:
                fig.show()
            else:
                return fig

    def track_days(self):
        """
        A SimPy process that logs the progression of simulation days.

        This generator functions as a background 'clock' process. It wakes up
        at the start of every 1440-minute interval (24 hours) to output a
        formatted debug message indicating the current day of the simulation
        run. This helps track progress in the console during long-running
        simulations.

        - The day calculation is performed using floor division:
          `self.env.now // 1440`.
        - The trace message visibility depends on the `g.show_trace` flag and
          the `g.tracked_cases` configuration.
        - This process runs concurrently with patient arrivals and clinical
          obstructions without interfering with their logic.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.
        """
        # Print a debugging message every day
        while self.env.now <= g.sim_duration:
            # TODO: this doesn't always reliably appear depending on number of tracked cases
            trace(
                msg=f"========= DAY {(self.env.now // 1440):.0f} ===============",
                time=self.env.now,
                debug=g.show_trace,
                identifier=max(g.tracked_cases),
                config=g.trace_config,
            )
            yield self.env.timeout(1440)

    # MARK: M: run model
    # The run method starts up the DES entity generators, runs the simulation,
    # and in turns calls anything we need to generate results for the run
    def run(self):
        """
        Execute the simulation run lifecycle.

        This method initializes the simulation by registering background
        processes, executes the SimPy event loop for a specified duration,
        and performs post-simulation data processing and export tasks.

        The execution sequence is as follows:
        1. Register time-tracking, patient arrival, and resource obstruction
           generators as SimPy processes.
        2. Execute the simulation engine until the combined limit of the
           warm-up period and active simulation duration is reached.
        3. Trigger final calculation of run-level results.
        4. (Optional) Export patient-level results to a CSV file.

        - **Warm-up Period**: The total runtime includes `g.warm_up_period`. This
          is crucial for allowing the model to reach a 'steady state' before
          results are recorded as valid.
        - **Concurrency**: All methods passed to `self.env.process()` run
          pseudo-parallelly, managed by the SimPy event scheduler.
        - **Post-Processing**: This method must be called for `results_df`
          and other KPIs to be populated with final values.

        See Also
        --------
        track_days : The background process that logs day transitions.

        generator_patient_arrivals: generates in-hours patients and sends them through the
            assessment pathway

        generator_patient_arrivals_ooh: generates out-of-hours patients and sends them through the
            assessment pathway

        obstruct_ctp: ensures the ctp scanner is only available for the specified times

        obstruct_sdec: ensures the sdec is only available for the specified times

        calculate_run_results : The method called to process data after the
            event loop finishes.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.
        """
        # starts up the generators in the model, of which there are three.

        self.env.process(self.track_days())
        self.env.process(self.generator_patient_arrivals())
        self.env.process(self.generator_patient_arrivals_ooh())
        self.env.process(self.obstruct_ctp())
        self.env.process(self.obstruct_sdec())

        # Run the model for the duration specified in g class
        self.env.run(until=(g.sim_duration + g.warm_up_period))

        # Now the simulation run has finished, call the method that calculates
        # run results
        self.calculate_run_results()

        # Print the run number with the patient-level results from this run of
        # the model, this is commented out at the moment.

        # print (f"Run Number {self.run_number}")
        # print (self.results_df)

        if g.write_to_csv == True:
            self.results_df.to_csv(
                f"trial {g.trials_run_counter} output {self.run_number}.csv",
                index=False,
            )

        # TODO: SR: I have commented this out for now
        # self.plot_stroke_run_graphs()


# Class representing a Trial for our simulation - a batch of simulation runs.


# MARK: Trial class
class Trial:
    """
    Orchestrator for running multiple simulation iterations (runs) and aggregating results.

    The Trial class manages the execution of multiple `Model` instances as defined
    in the global configuration. It collects performance metrics, financial data,
    and patient-level logs from each individual run into centralized DataFrames
    for cross-run analysis.

    Attributes
    ----------
    df_trial_results : pd.DataFrame
        A summary DataFrame where each row represents a single simulation run.
        Tracks metrics such as mean queue times, occupancy, and financial savings.
    graph_objects : list
        Storage for visualization objects generated during each simulation run.
    model_objects : list
        A collection of `Model` instances created during the trial, allowing
        for post-hoc inspection of specific run states.
    trial_patient_dataframes : list
        A list of DataFrames, each containing detailed attribute data for every
        patient in a specific run.
    trial_patient_df : pd.DataFrame
        The master DataFrame created by concatenating all patient-level data
        across all runs in the trial.
    trial_info : str
        A descriptive string containing the configuration settings used for
        the current trial (e.g., SDEC therapy status and resource availability).

    Notes
    -----
    GENAI declaration (SR): this docstring has been generated with the aid
    of Google Gemini Flash.
    All generated content has been thoroughly reviewed.
    """

    # The constructor sets up a pandas dataframe that will store the key
    # results from each run with run number as the index.

    def __init__(self):
        self.df_trial_results = pd.DataFrame()
        self.df_trial_results["Run Number"] = [0]
        self.df_trial_results["Mean Q Time Nurse (Mins)"] = [0.0]
        self.df_trial_results["Number of Admissions Avoided In Run"] = [0.0]
        self.df_trial_results["Mean Q Time Ward (Hour)"] = [0.0]
        self.df_trial_results["Mean Occupancy"] = [0.0]
        self.df_trial_results["Number of Admission Delays"] = [0.0]
        self.df_trial_results["Mean Length of Stay Ward (Hours)"] = [0.0]
        self.df_trial_results["Financial Savings of Admissions Avoidance (Â£)"] = [0.0]
        self.df_trial_results["SDEC Medical Staff Cost (Â£)"] = [0.0]
        self.df_trial_results["SDEC Savings (Â£)"] = [0.0]
        self.df_trial_results["Thrombolysis Savings (Â£)"] = [0.0]
        self.df_trial_results["Total Savings"] = [0.0]
        self.df_trial_results["Mean MRS Change"] = [0.0]
        self.df_trial_results.set_index("Run Number", inplace=True)

        self.graph_objects = []
        self.model_objects = []
        # self.patient_objects = {}
        self.trial_patient_dataframes = []
        self.trial_patient_df = pd.DataFrame()

    # MARK: M: run_trial
    # Method to run a trial

    def run_trial(self):
        """
        Executes the batch of simulation runs and aggregates the resulting data.

        This method performs the following steps:

        1. Loops through the number of runs specified in `g.number_of_runs`.

        2. Instantiates and executes a `Model` for each run.

        3. Collects summary metrics (e.g., queue times, savings) into `df_trial_results`.

        4. Flattens patient-level data into a single master DataFrame.

        5. Calculates trial-level means and updates the global `g` class attributes.

        6. Optionally exports results to a CSV file if `g.write_to_csv` is True.

        This method dynamically updates the global configuration class `g` by
        calculating the mean of results across all runs and storing them in
        dictionaries keyed by the trial counter.

        See Also
        --------
        Model.run : The method called to execute an individual simulation iteration.

        Notes
        -----
        GENAI declaration (SR): this docstring has been generated with the aid
        of Google Gemini Flash.
        All generated content has been thoroughly reviewed.
        """
        # Run the simulation for the number of runs specified in g class.
        # For each run, we create a new instance of the Model class and call its
        # run method, which sets everything else in motion.  Once the run has
        # completed, we grab out the stored run results
        # and store it against the run number in the trial results dataframe.

        for run in range(g.number_of_runs):
            my_model = Model(run)
            my_model.run()

            self.model_objects.append(my_model)

            self.df_trial_results.loc[run] = [
                my_model.mean_q_time_nurse,
                my_model.number_of_admissions_avoided,
                my_model.mean_q_time_ward,
                my_model.mean_ward_occupancy,
                my_model.admission_delays,
                my_model.mean_los_ward,
                my_model.sdec_financial_savings,
                my_model.medical_staff_cost,
                my_model.savings_sdec,
                my_model.thrombolysis_savings,
                my_model.total_savings,
                my_model.mean_mrs_change,
            ]

            # self.patient_objects[run] = my_model.patient_objects
            patient_dataframe = pd.DataFrame(
                [p.__dict__ for p in my_model.patient_objects]
            )
            patient_dataframe["run"] = run + 1
            self.trial_patient_dataframes.append(patient_dataframe)

        self.trial_patient_df = pd.concat(self.trial_patient_dataframes)

        if g.write_to_csv == True:
            self.df_trial_results.to_csv(
                f"trial {g.trials_run_counter} trial results.csv", index=False
            )

        # TODO: SR: FIX appending of per-run graphs to trial class
        # if g.gen_graph:
        #     self.graph_objects.append(my_model.plot_stroke_run_graphs(plot=False))

        # This is new code that will store all averages to compare across
        # the different trials. It does this by checking if the attribute
        # exists in the global g class, and if it doesn't it creates it. It
        # then stores the mean of each run against the attribute
        # (eg "trial_mean_q_time_nurse")

        # The mean is stored against the key of g.trials_run_counter.

        for attr, col in [
            ("trial_mean_q_time_nurse", "Mean Q Time Nurse (Mins)"),
            (
                "trial_number_of_admissions_avoided",
                "Number of Admissions Avoided In Run",
            ),
            ("trial_mean_q_time_ward", "Mean Q Time Ward (Hour)"),
            ("trial_mean_occupancy", "Mean Occupancy"),
            ("trial_number_of_admission_delays", "Number of Admission Delays"),
            (
                "trial_financial_savings_of_a_a",
                "Financial Savings of Admissions Avoidance (Â£)",
            ),
            ("sdec_medical_cost", "SDEC Medical Staff Cost (Â£)"),
            ("trial_sdec_financial_savings", "SDEC Savings (Â£)"),
            ("trial_thrombolysis_savings", "Thrombolysis Savings (Â£)"),
            ("trial_total_savings", "Total Savings"),
            ("trial_mrs_change", "Mean MRS Change"),
        ]:
            # Checks to see if the attribute already exists and if it doesn't
            # create it. Creates a mean of each trial and creates a dictionary
            # that can be read later.

            if not hasattr(g, attr):
                setattr(g, attr, {})
            getattr(g, attr)[g.trials_run_counter] = round(
                self.df_trial_results[col].mean(), 2
            )

        # Code to store the configuration that was used for this trial.
        self.trial_info = (
            f"Trial {g.trials_run_counter}, SDEC Therapy = {g.therapy_sdec},"
            f" SDEC Open % = {g.sdec_value}, CTP Open % = {g.ctp_value}"
        )

        print("---------------------------------------------------")
        print(f"{self.trial_info}")
        print(f"Trial {g.trials_run_counter} Results:")
        print(" ")
        print(
            f"Trial Mean Q Time Nurse (Mins):     \
              {g.trial_mean_q_time_nurse[g.trials_run_counter]}"
        )
        print(
            f"Trial Number of Admissions Avoided: \
              {g.trial_number_of_admissions_avoided[g.trials_run_counter]}"
        )
        print(
            f"Trial Mean Q Time Ward (Hours):     \
              {g.trial_mean_q_time_ward[g.trials_run_counter]}"
        )
        print(
            f"Trial Mean Ward Occupancy:          \
              {g.trial_mean_occupancy[g.trials_run_counter]}"
        )
        print(
            f"Trial Number of Admission Delays:   \
              {g.trial_number_of_admission_delays[g.trials_run_counter]}"
        )
        print(
            f"Trial SDEC Total Savings (Â£):       \
              {g.trial_financial_savings_of_a_a[g.trials_run_counter]}"
        )
        print(
            f"Trial SDEC Medical Cost (Â£):        \
              {g.sdec_medical_cost[g.trials_run_counter]}"
        )
        print(
            f"Trial SDEC Savings - Cost (Â£):      \
              {g.trial_sdec_financial_savings[g.trials_run_counter]}"
        )
        print(
            f"Trial Thrombolysis Savings (Â£):     \
              {g.trial_thrombolysis_savings[g.trials_run_counter]}"
        )
        print(
            f"Trial Total Savings (Â£):            \
              {g.trial_total_savings[g.trials_run_counter]}"
        )
        print(
            f"Mean MRS Change:                    \
              {g.trial_mrs_change[g.trials_run_counter]}"
        )
