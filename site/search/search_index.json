{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Discrete Event Simulation of a Stroke Unit","text":""},{"location":"#what-impact-do-specialised-stroke-same-day-emergency-care-sdec-units-and-ct-perfusion-scanning-have-on-stroke-patient-flow","title":"What impact do specialised stroke same day emergency care (SDEC) units and CT perfusion scanning have on stroke patient flow?","text":"<p>Welcome to the documentation for this discrete event simulation.</p> <p>This model is designed to help answer questions about the impact of CT perfusion scanner availability and the use of a specialised stroke SDEC on stroke ward capacity, the suitable number of beds, and potential cost-savings from increased use of these approaches.</p> <p></p>"},{"location":"#where-can-i-find-out-more","title":"Where can I find out more?","text":"<p>This documentation contains technical details of the modelling code.</p> <p>For a higher-level overview, you can find details in the Streamlit app.</p> <p>Details of how to run the Streamlit app locally can be found in the repository readme.</p>"},{"location":"CHANGELOG/","title":"v0.2.0","text":""},{"location":"CHANGELOG/#new-features","title":"New features","text":"<ul> <li>Built first draft of web app in Streamlit </li> <li>Built model flow diagram with Mermaid<ul> <li>this is available to view in the 'About' page of the Streamlit app</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#enhancements","title":"Enhancements","text":"<ul> <li>Recorded additional attributes in patient object</li> <li>Added patient objects to a list in the model, allowing for easy individual post-hoc querying of all recorded patient attributes</li> <li>Added logging of model steps using the sim-tools trace function<ul> <li>rich logging of individual steps enhances debugging and understanding of the model for those who are less familiar with its structure</li> </ul> </li> <li>Adjusted how ctp_value and sdec_value are set up and used across the model, making it consistent across the script running and app methods and more consistent with how other variables are managed (i.e. using g class)</li> </ul>"},{"location":"CHANGELOG/#bugfixes","title":"Bugfixes","text":"<ul> <li>fixed typo in conditional check where it was accidentally looking at the sdec_value in the case where sdec_value was 100, where instead it should have been checking for ctp_value == 100 in that branch (Click here to view commit, though note it's not showing the original code properly)</li> </ul>"},{"location":"CHANGELOG/#repository-admin-and-structure","title":"Repository Admin and Structure","text":"<ul> <li>Added markers to enable richer code minimap in core classes</li> <li>Set up documentation site using mkdocs, mkdocs-material and mkdocstrings<ul> <li>Set up automatic building and publishing of site with GitHub action</li> <li>Added .nojekyll file to ensure GitHub doesn't try to post-process the built site</li> </ul> </li> <li>Updated gitignore with wildcards to make matching of additional results files more robust</li> <li>Added a minimal requirements file<ul> <li>Added new requirements including streamlit, mkdocs, mkdocs-material, mkdocstrings,</li> </ul> </li> <li>Updated structure of code to package structure<ul> <li>Model classes split into separate file to model running code</li> <li>All code moved into src/stroke_ward_model</li> <li>Added pyproject.toml file</li> </ul> </li> </ul>"},{"location":"CHANGELOG/#v010","title":"v0.1.0","text":"<p>Initial model release.</p>"},{"location":"g/","title":"Reference","text":"<p>Global simulation configuration parameters.</p> <p>This class stores all model-wide constants used in the discrete-event simulation, including runtime settings, resource capacities, operational constraints, diagnosis-based length-of-stay (LOS) values, cost parameters, and state flags modified during execution. All attributes are class variables and are intended to be accessed without instantiation.</p> <p>Attributes:</p> Name Type Description <code>sim_duration</code> <code>int</code> <p>Total simulated time in minutes (default: 525600, one year).</p> <code>number_of_runs</code> <code>int</code> <p>Number of simulation replications.</p> <code>warm_up_period</code> <code>float</code> <p>Number of minutes considered warm-up (not included in statistics), defined as one-fifth of the total simulation time.</p> <code>patient_inter_day</code> <code>int</code> <p>Interarrival time (minutes) for daytime patient generation. NOTE that this is not used in entirely the way that you might expect. This may be changed in future.</p> <code>patient_inter_night</code> <code>int</code> <p>Interarrival time (minutes) for nighttime patient generation. NOTE that this is not used in entirely the way that you might expect. This may be changed in future.</p> <code>number_of_nurses</code> <code>int</code> <p>Number of nurses available in the system.</p> <code>mean_n_consult_time</code> <code>int</code> <p>Mean consultation time in minutes.</p> <code>mean_n_ct_time</code> <code>int</code> <p>Mean CT processing time in minutes.</p> <code>number_of_ctp</code> <code>int</code> <p>Number of CT processing units available.</p> <code>sdec_beds</code> <code>int</code> <p>Number of SDEC (Same Day Emergency Care) beds.</p> <code>mean_n_sdec_time</code> <code>int</code> <p>Mean SDEC stay duration in minutes.</p> <code>number_of_ward_beds</code> <code>int</code> <p>Number of inpatient ward beds.</p> <code>mean_n_i_ward_time_mrs_0</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (0).</p> <code>mean_n_i_ward_time_mrs_1</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (1).</p> <code>mean_n_i_ward_time_mrs_2</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (2).</p> <code>mean_n_i_ward_time_mrs_3</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (3).</p> <code>mean_n_i_ward_time_mrs_4</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (4).</p> <code>mean_n_i_ward_time_mrs_5</code> <code>int</code> <p>Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (5).</p> <code>mean_n_ich_ward_time_mrs_0</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (0).</p> <code>mean_n_ich_ward_time_mrs_1</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (1).</p> <code>mean_n_ich_ward_time_mrs_2</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (2).</p> <code>mean_n_ich_ward_time_mrs_3</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (3).</p> <code>mean_n_ich_ward_time_mrs_4</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (4).</p> <code>mean_n_ich_ward_time_mrs_5</code> <code>int</code> <p>Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (5).</p> <code>mean_n_non_stroke_ward_time</code> <code>int</code> <p>LOS (minutes) for non-stroke patients (TODO: CHECK INTERPRETATION).</p> <code>mean_n_tia_ward_time</code> <code>int</code> <p>LOS (minutes) for TIA patients.</p> <code>thrombolysis_los_save</code> <code>float</code> <p>Proportional reduction in LOS for thrombolysed patients. This is used as a multiplier with the sampled length of stay. For example, if a patient has a LOS of 10 days, and the value of <code>thrombolysis_los_save</code> was 0.75, the calculation would be 10 * 0.75, resulting in a LOS of 7.5 days.</p> <code>mean_mrs</code> <code>int</code> <p>Default/mean modified Rankin Scale score used in the model.</p> <code>ich</code> <code>int</code> <p>Percentage likelihood of intracerebral hemorrhage diagnosis (TODO: CHECK INTERPRETATION).</p> <code>i</code> <code>int</code> <p>Percentage likelihood of ischemic stroke diagnosis.</p> <code>tia</code> <code>int</code> <p>Percentage likelihood of TIA diagnosis.</p> <code>stroke_mimic</code> <code>int</code> <p>Percentage likelihood of stroke mimic diagnosis.</p> <code>tia_admission</code> <code>int</code> <p>Percentage chance that a TIA requires admission.</p> <code>stroke_mimic_admission</code> <code>int</code> <p>Percentage chance that a stroke mimic requires admission.</p> <code>sdec_dr_cost_min</code> <code>float</code> <p>Cost per minute for SDEC doctor time.</p> <code>inpatient_bed_cost</code> <code>float</code> <p>Cost of a standard inpatient bed stay.</p> <code>inpatient_bed_cost_thrombolysis</code> <code>float</code> <p>Cost of an inpatient stay following thrombolysis.</p> <code>sdec_unav_time</code> <code>int</code> <p>Operational unavailability duration of SDEC</p> <code>sdec_unav_freq</code> <code>int</code> <p>How often SDEC unavailability duration occurs</p> <code>ctp_unav_time</code> <code>int</code> <p>Operational unavailability duration of CT perfusion scanner</p> <code>ctp_unav_freq</code> <code>int</code> <p>How often CT perfusion unavailability duration occurs</p> <code>sdec_unav</code> <code>bool</code> <p>Indicates whether SDEC is unavailable.</p> <code>ctp_unav</code> <code>bool</code> <p>Indicates whether CT processing is unavailable.</p> <code>write_to_csv</code> <code>bool</code> <p>Whether the simulation should write results to CSV.</p> <code>gen_graph</code> <code>bool</code> <p>Whether visualisation graphs should be generated.</p> <code>therapy_sdec</code> <code>bool</code> <p>Whether therapy is delivered through SDEC.</p> <code>trials_run_counter</code> <code>int</code> <p>Internal counter tracking completed simulation replications.</p> <code>patient_arrival_gen_1</code> <code>bool</code> <p>Flag used by the simulation to control one patient arrival stream.</p> <code>patient_arrival_gen_2</code> <code>bool</code> <p>Flag used by the simulation to control a second patient arrival stream.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of ChatGPT 5.1. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>class g:\n    \"\"\"\n    Global simulation configuration parameters.\n\n    This class stores all model-wide constants used in the discrete-event\n    simulation, including runtime settings, resource capacities, operational\n    constraints, diagnosis-based length-of-stay (LOS) values, cost parameters,\n    and state flags modified during execution. All attributes are class\n    variables and are intended to be accessed without instantiation.\n\n    Attributes\n    ----------\n    sim_duration : int\n        Total simulated time in minutes (default: 525600, one year).\n    number_of_runs : int\n        Number of simulation replications.\n    warm_up_period : float\n        Number of minutes considered warm-up (not included in statistics),\n        defined as one-fifth of the total simulation time.\n    patient_inter_day : int\n        Interarrival time (minutes) for daytime patient generation.\n        NOTE that this is not used in entirely the way that you might expect.\n        This may be changed in future.\n    patient_inter_night : int\n        Interarrival time (minutes) for nighttime patient generation.\n        NOTE that this is not used in entirely the way that you might expect.\n        This may be changed in future.\n    number_of_nurses : int\n        Number of nurses available in the system.\n    mean_n_consult_time : int\n        Mean consultation time in minutes.\n    mean_n_ct_time : int\n        Mean CT processing time in minutes.\n    number_of_ctp : int\n        Number of CT processing units available.\n    sdec_beds : int\n        Number of SDEC (Same Day Emergency Care) beds.\n    mean_n_sdec_time : int\n        Mean SDEC stay duration in minutes.\n    number_of_ward_beds : int\n        Number of inpatient ward beds.\n    mean_n_i_ward_time_mrs_0 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (0).\n    mean_n_i_ward_time_mrs_1 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (1).\n    mean_n_i_ward_time_mrs_2 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (2).\n    mean_n_i_ward_time_mrs_3 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (3).\n    mean_n_i_ward_time_mrs_4 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (4).\n    mean_n_i_ward_time_mrs_5 : int\n        Inpatient LOS (minutes) for ischemic stroke by modified Rankin Scale (5).\n    mean_n_ich_ward_time_mrs_0 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (0).\n    mean_n_ich_ward_time_mrs_1 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (1).\n    mean_n_ich_ward_time_mrs_2 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (2).\n    mean_n_ich_ward_time_mrs_3 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (3).\n    mean_n_ich_ward_time_mrs_4 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (4).\n    mean_n_ich_ward_time_mrs_5 : int\n        Inpatient LOS (minutes) for intracerebral hemorrhage by MRS score (5).\n    mean_n_non_stroke_ward_time : int\n        LOS (minutes) for non-stroke patients (TODO: CHECK INTERPRETATION).\n    mean_n_tia_ward_time : int\n        LOS (minutes) for TIA patients.\n    thrombolysis_los_save : float\n        Proportional reduction in LOS for thrombolysed patients.\n        This is used as a multiplier with the sampled length of stay.\n        For example, if a patient has a LOS of 10 days, and the value of `thrombolysis_los_save`\n        was 0.75, the calculation would be 10 * 0.75, resulting in a LOS of 7.5 days.\n    mean_mrs : int\n        Default/mean modified Rankin Scale score used in the model.\n    ich : int\n        Percentage likelihood of intracerebral hemorrhage diagnosis (TODO: CHECK INTERPRETATION).\n    i : int\n        Percentage likelihood of ischemic stroke diagnosis.\n    tia : int\n        Percentage likelihood of TIA diagnosis.\n    stroke_mimic : int\n        Percentage likelihood of stroke mimic diagnosis.\n    tia_admission : int\n        Percentage chance that a TIA requires admission.\n    stroke_mimic_admission : int\n        Percentage chance that a stroke mimic requires admission.\n    sdec_dr_cost_min : float\n        Cost per minute for SDEC doctor time.\n    inpatient_bed_cost : float\n        Cost of a standard inpatient bed stay.\n    inpatient_bed_cost_thrombolysis : float\n        Cost of an inpatient stay following thrombolysis.\n    sdec_unav_time : int\n        Operational unavailability duration of SDEC\n    sdec_unav_freq : int\n        How often SDEC unavailability duration occurs\n    ctp_unav_time : int\n        Operational unavailability duration of CT perfusion scanner\n    ctp_unav_freq : int\n        How often CT perfusion unavailability duration occurs\n    sdec_unav : bool\n        Indicates whether SDEC is unavailable.\n    ctp_unav : bool\n        Indicates whether CT processing is unavailable.\n    write_to_csv : bool\n        Whether the simulation should write results to CSV.\n    gen_graph : bool\n        Whether visualisation graphs should be generated.\n    therapy_sdec : bool\n        Whether therapy is delivered through SDEC.\n    trials_run_counter : int\n        Internal counter tracking completed simulation replications.\n    patient_arrival_gen_1 : bool\n        Flag used by the simulation to control one patient arrival stream.\n    patient_arrival_gen_2 : bool\n        Flag used by the simulation to control a second patient arrival stream.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid of\n    ChatGPT 5.1.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    # 525600 (Year of Minutes)\n    sim_duration = 525600\n    number_of_runs = 10\n    warm_up_period = sim_duration / 5\n    patient_inter_day = 5\n    patient_inter_night = 5\n    number_of_nurses = 2\n    number_of_ctp = 1\n    sdec_beds = 5\n    number_of_ward_beds = 1\n\n    mean_n_consult_time = 60\n    mean_n_ct_time = 20\n    mean_n_sdec_time = 240\n\n    # Different variables for ward stay based on diagnosis, thrombolysis and MRS\n    mean_n_i_ward_time_mrs_0 = 1440 * 6\n    mean_n_i_ward_time_mrs_1 = 1440 * 4\n    mean_n_i_ward_time_mrs_2 = 1440 * 8\n    mean_n_i_ward_time_mrs_3 = 1440 * 11\n    mean_n_i_ward_time_mrs_4 = 1440 * 24\n    mean_n_i_ward_time_mrs_5 = 1440 * 29\n\n    mean_n_ich_ward_time_mrs_0 = 1440 * 5\n    mean_n_ich_ward_time_mrs_1 = 1440 * 4\n    mean_n_ich_ward_time_mrs_2 = 1440 * 5\n    mean_n_ich_ward_time_mrs_3 = 1440 * 17\n    mean_n_ich_ward_time_mrs_4 = 1440 * 36\n    mean_n_ich_ward_time_mrs_5 = 1440 * 36\n\n    mean_n_non_stroke_ward_time = 4320\n    mean_n_tia_ward_time = 1440\n    thrombolysis_los_save = 0.75\n\n    sdec_dr_cost_min = 0.50\n    inpatient_bed_cost = 876\n    inpatient_bed_cost_thrombolysis = 528.17\n    mean_mrs = 2\n\n    # Diagnosis % range\n    ich = 10\n    i = 60\n    tia = 70\n    stroke_mimic = 80\n\n    # Admission Range (% Chance of Admission) for TIA and Stroke Mimic, non\n    # stroke shares the range with stroke mimic in this model. (This is\n    # reflected in our real data mainly because most non strokes are often\n    #  mimics that are not classified under the stroke mimic criteria in our\n    #  data collection)\n    tia_admission = 10\n    stroke_mimic_admission = 30\n\n    # Operational hours of SDEC and CTP are set by the user and stored in the\n    # variables below.\n\n    sdec_unav_time = 0\n    sdec_unav_freq = 0\n    ctp_unav_time = 0\n    ctp_unav_freq = 0\n\n    sdec_value = 0\n    ctp_value = 0\n\n    sdec_opening_hour = 0\n    ctp_opening_hour = 0\n\n    in_hours_start = 8\n    ooh_start = 20\n\n    in_hours_start_mins = in_hours_start * 60\n    ooh_start_mins = ooh_start * 60\n\n    # These values are changed by the model itself\n\n    sdec_unav = False\n    ctp_unav = False\n    write_to_csv = False\n    gen_graph = False\n    therapy_sdec = False\n    trials_run_counter = 1\n    patient_arrival_gen_1 = False\n    patient_arrival_gen_2 = False\n\n    show_trace = True\n    tracked_cases = list(range(1, 50))\n    trace_config = {\"tracked\": tracked_cases}\n</code></pre>"},{"location":"model/","title":"Reference","text":"<p>A SimPy simulation model representing a stroke patient pathway.</p> <p>This class coordinates the simulation environment, manages clinical resources (nurses, scanners, and beds), and tracks performance metrics throughout the duration of a simulation run.</p> <p>Parameters:</p> Name Type Description Default <code>run_number</code> <code>int</code> <p>The unique identifier for the specific simulation run.</p> required <p>Attributes:</p> Name Type Description <code>env</code> <code>Environment</code> <p>The SimPy environment in which the simulation is executed.</p> <code>patient_counter</code> <code>int</code> <p>A running count of patients who have entered the system, used as a unique ID. This is shared across in-hours and out-of-hours arrivals.</p> <code>nurse</code> <code>Resource</code> <p>A SimPy resource representing stroke nurses available for assessment.</p> <code>ctp_scanner</code> <code>PriorityResource</code> <p>A priority resource representing CTP scanners.</p> <code>sdec_bed</code> <code>PriorityResource</code> <p>A priority resource representing Same Day Emergency Care (SDEC) beds.</p> <code>ward_bed</code> <code>Resource</code> <p>A SimPy resource representing standard ward beds.</p> <code>run_number</code> <code>int</code> <p>The identifier for the current simulation iteration.</p> <code>results_df</code> <code>DataFrame</code> <p>A central data repository for patient-level results, including queue times, lengths of stay, and diagnostic statuses.</p> <code>sdec_freeze_counter</code> <code>int</code> <p>Counter tracking the frequency of SDEC capacity freezes.</p> <code>mean_q_time_nurse</code> <code>float</code> <p>The calculated average time patients spent queuing for a nurse.</p> <code>mean_q_time_ward</code> <code>float</code> <p>The calculated average time patients spent queuing for a ward bed.</p> <code>mean_los_ward</code> <code>float</code> <p>The average length of stay for patients admitted to the ward.</p> <code>thrombolysis_savings</code> <code>float</code> <p>Aggregated metric representing the savings or benefits derived from thrombolysis.</p> <code>q_for_assessment</code> <code>list</code> <p>A list tracking patients currently waiting in the assessment queue.</p> <code>nurse_q_graph_df</code> <code>DataFrame</code> <p>Time-series data for monitoring nurse queue lengths over time.</p> <code>sdec_occupancy</code> <code>list</code> <p>Historical record of SDEC bed utilization.</p> <code>admission_avoidance</code> <code>list</code> <p>Historical record of patients who avoided inpatient admission.</p> <code>ward_occupancy</code> <code>list</code> <p>Historical record of ward bed utilization.</p> <code>non_admissions</code> <code>list</code> <p>Record of patients classified as non-admissions.</p> <code>occupancy_graph_df</code> <code>DataFrame</code> <p>Time-series data for monitoring ward occupancy levels.</p> <code>patient_objects</code> <code>list</code> <p>A collection of all <code>Patient</code> class instances created during the simulation.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>class Model:\n    \"\"\"\n    A SimPy simulation model representing a stroke patient pathway.\n\n    This class coordinates the simulation environment, manages clinical resources\n    (nurses, scanners, and beds), and tracks performance metrics throughout\n    the duration of a simulation run.\n\n    Parameters\n    ----------\n    run_number : int\n        The unique identifier for the specific simulation run.\n\n    Attributes\n    ----------\n    env : simpy.core.Environment\n        The SimPy environment in which the simulation is executed.\n    patient_counter : int\n        A running count of patients who have entered the system, used as a unique ID.\n        This is shared across in-hours and out-of-hours arrivals.\n    nurse : simpy.resources.resource.Resource\n        A SimPy resource representing stroke nurses available for assessment.\n    ctp_scanner : simpy.resources.resource.PriorityResource\n        A priority resource representing CTP scanners.\n    sdec_bed : simpy.resources.resource.PriorityResource\n        A priority resource representing Same Day Emergency Care (SDEC) beds.\n    ward_bed : simpy.resources.resource.Resource\n        A SimPy resource representing standard ward beds.\n    run_number : int\n        The identifier for the current simulation iteration.\n    results_df : pd.DataFrame\n        A central data repository for patient-level results, including queue times,\n        lengths of stay, and diagnostic statuses.\n    sdec_freeze_counter : int\n        Counter tracking the frequency of SDEC capacity freezes.\n    mean_q_time_nurse : float\n        The calculated average time patients spent queuing for a nurse.\n    mean_q_time_ward : float\n        The calculated average time patients spent queuing for a ward bed.\n    mean_los_ward : float\n        The average length of stay for patients admitted to the ward.\n    thrombolysis_savings : float\n        Aggregated metric representing the savings or benefits derived from thrombolysis.\n    q_for_assessment : list\n        A list tracking patients currently waiting in the assessment queue.\n    nurse_q_graph_df : pd.DataFrame\n        Time-series data for monitoring nurse queue lengths over time.\n    sdec_occupancy : list\n        Historical record of SDEC bed utilization.\n    admission_avoidance : list\n        Historical record of patients who avoided inpatient admission.\n    ward_occupancy : list\n        Historical record of ward bed utilization.\n    non_admissions : list\n        Record of patients classified as non-admissions.\n    occupancy_graph_df : pd.DataFrame\n        Time-series data for monitoring ward occupancy levels.\n    patient_objects : list\n        A collection of all `Patient` class instances created during the simulation.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    # Constructor to set up the model for a run. We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment\n        self.env = simpy.Environment()\n\n        # Create a patient counter for the first patient Generator\n        self.patient_counter = 0\n\n        # Create a SimPy resources to represent stroke nurses, ctp scanners,\n        # sdec beds, and ward beds. Set in class g\n        self.nurse = simpy.Resource(self.env, capacity=g.number_of_nurses)\n\n        self.ctp_scanner = simpy.PriorityResource(self.env, capacity=g.number_of_ctp)\n\n        self.sdec_bed = simpy.PriorityResource(self.env, capacity=g.sdec_beds)\n\n        self.ward_bed = simpy.Resource(self.env, capacity=g.number_of_ward_beds)\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a Pandas DataFrame that will store a majority of the results\n        # with the patient ID as the index.\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Q Time Nurse\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df[\"Q Time Ward\"] = [0.0]\n        self.results_df[\"Ward LOS\"] = [0.0]\n        self.results_df[\"Time with CTP\"] = [0.0]\n        self.results_df[\"Time with CT\"] = [0.0]\n        self.results_df[\"Time in SDEC\"] = [0.0]\n        self.results_df[\"CTP Status\"] = [\"\"]\n        self.results_df[\"SDEC Status\"] = [\"\"]\n        self.results_df[\"Thrombolysis\"] = [\"\"]\n        self.results_df[\"SDEC Occupancy\"] = [0.0]\n        self.results_df[\"Admission Avoidance\"] = [\"\"]\n        self.results_df[\"SDEC Savings\"] = [0.0]\n        self.results_df[\"MRS Type\"] = [0.0]\n        self.results_df[\"MRS DC\"] = [0.0]\n        self.results_df[\"MRS Change\"] = [0.0]\n        self.results_df[\"Onset Type\"] = [0.0]\n        self.results_df[\"Diagnosis Type\"] = [\"\"]\n        self.results_df[\"Thrombolysis Savings\"] = [0.0]\n        self.results_df[\"Ward Occupancy\"] = [0.0]\n        self.results_df[\"Arrival Time\"] = [0.0]\n        self.results_df[\"Patient Gen 1 Status\"] = [\"\"]\n        self.results_df[\"Patient Gen 2 Status\"] = [\"\"]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # A variable to count the number of SDEC freezes\n        self.sdec_freeze_counter = 0\n\n        # Create a variable to store the mean queuing time for the nurse\n        self.mean_q_time_nurse = 0\n\n        # Create a variable to store the mean time waiting for a ward bed\n        self.mean_q_time_ward = 0\n\n        # Create a variable to store the mean length of stay in the ward\n        self.mean_los_ward = 0\n\n        # Create a variable to store the mean number of thrombolysis savings\n        self.thrombolysis_savings = 0\n\n        # set up a list to store the queue for stroke nurse assessment\n        self.q_for_assessment = []\n\n        # a PD dataframe for the assessment queue graph\n        self.nurse_q_graph_df = pd.DataFrame()\n        self.nurse_q_graph_df[\"Time\"] = [0.0]\n        self.nurse_q_graph_df[\"Patients in Assessment Queue\"] = [0.0]\n\n        # a list that will store the number of patients in the SDEC\n        self.sdec_occupancy = []\n\n        # A list that will store the number of admissions avoided\n        self.admission_avoidance = []\n\n        # A list that will store the number of patients in the ward\n        self.ward_occupancy = []\n\n        # A list to store the number of patients avoiding admission\n        self.non_admissions = []\n\n        self.occupancy_graph_df = pd.DataFrame()\n        self.occupancy_graph_df[\"Time\"] = [0.0]\n        self.occupancy_graph_df[\"Ward Occupancy\"] = [0.0]\n\n        # A list to store the patient objects\n        self.patient_objects = []\n\n    def is_in_hours(self, time_of_day):\n        start = g.in_hours_start_mins\n        end = g.ooh_start_mins\n\n        if start &lt; end:\n            # Normal case (does not cross midnight)\n            return start &lt;= time_of_day &lt; end\n        else:\n            # Wraps over midnight\n            return time_of_day &gt;= start or time_of_day &lt; end\n\n    def is_out_of_hours(self, time_of_day):\n        return not self.is_in_hours(time_of_day)\n\n    # MARK: M: in-hours arrivals\n    # A generator function for the patient arrivals in hours.\n    def generator_patient_arrivals(self):\n        \"\"\"\n        A SimPy process generator that handles \"in-hours\" patient arrivals.\n\n        This function runs as a continuous loop. It checks if the current\n        simulation time is within daytime operating hours (0-960 minutes\n        relative to the start of a 1440-minute day).\n\n        If in-hours, it:\n\n        1. Updates global arrival flags.\n\n        2. Instantiates a new Patient object.\n\n        3. Records trace information.\n\n        4. Triggers the `stroke_assessment` process for the patient.\n\n        5. Samples an inter-arrival time and yields a timeout.\n\n        If out-of-hours, it yields a small timeout before checking again.\n\n        Arrival rates are determined by `random.expovariate` using the\n        `g.patient_inter_day` parameter. NOTE that this does not use the\n        `g.patient_inter_day` parameter directly, and instead uses it alongside\n        a rate modifier - careful inspection of the code to understand the impacts\n        of changing `g.patient_inter_day` is recommended, and this may be adjusted\n        in a future version of the model.\n\n        Patients generated here have their `arrived_ooh` attribute set to False.\n\n        This process triggers the `stroke_assessment` process for every\n        newly created patient.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        while True:\n            # if 0 &lt;= self.env.now % 1440 &lt; 960\n            time_of_day = self.env.now % 1440\n            if self.is_in_hours(time_of_day):\n                # Change the Global Class variable for the generator to TRUE\n                g.patient_arrival_gen_1 = True\n                g.patient_arrival_gen_2 = False\n\n                # Increment the patient counter by 1 for each new patient\n                self.patient_counter += 1\n\n                # Create a new patient - an instance of the Patient Class we\n                # defined above. patient counter ID passed from above to patient\n                # class.\n                p = Patient(self.patient_counter)\n                self.patient_objects.append(p)\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u2600\ufe0f IN-HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                    identifier=p.id,\n                    config=g.trace_config,\n                )\n\n                p.arrived_ooh = False\n                if self.env.now &lt; g.warm_up_period:\n                    p.generated_during_warm_up = True\n\n                # Tell SimPy to start the stroke assessment function with\n                # this patient (the generator function that will model the\n                # patient's journey through the system)\n                self.env.process(self.stroke_assessment(p))\n\n                # TODO: SR query: explore whether this is the most intuitive/easily managed way to\n                # handle interarrival rate. I think this means arrivals average\n                # every 200 minutes.\n                sampled_inter = random.expovariate(0.025 / g.patient_inter_day)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u23f2\ufe0f Next patient arriving in {sampled_inter:.1f} minutes\",\n                    config=g.trace_config,\n                    identifier=p.id,\n                )\n\n                # Freeze this instance of this function in place until the\n                # inter-arrival time has elapsed.\n                yield self.env.timeout(sampled_inter)\n\n            else:\n                yield self.env.timeout(1)\n\n    # MARK: M: OOH arrivals\n    # A generator function for the patient arrivals out of hours.\n    def generator_patient_arrivals_ooh(self):\n        \"\"\"\n        A SimPy process generator that handles out-of-hours (OOH) patient arrivals.\n\n        This function runs as a continuous loop, monitoring the simulation time\n        to identify the \"night\" window (960 to 1440 minutes in a 24-hour cycle).\n        When active, it instantiates patients and schedules their journey\n        through the clinical pathway.\n\n        If out-of-hours, it:\n\n        1. Updates global arrival flags.\n\n        2. Instantiates a new Patient object.\n\n        3. Records trace information.\n\n        4. Triggers the `stroke_assessment` process for the patient.\n\n        5. Samples an inter-arrival time and yields a timeout.\n\n        If in-hours, it yields a small timeout before checking again.\n\n        Arrival rates are determined by `random.expovariate` using the\n        `g.patient_inter_night` parameter. NOTE that this does not use the\n        `g.patient_inter_night` parameter directly, and instead uses it alongside\n        a rate modifier - careful inspection of the code to understand the impacts\n        of changing `g.patient_inter_night` is recommended, and this may be adjusted\n        in a future version of the model.\n\n        Patients generated here have their `arrived_ooh` attribute set to True.\n\n        This process triggers the `stroke_assessment` process for every\n        newly created patient.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n\n        \"\"\"\n        while True:\n            # if 960 &lt;= self.env.now % 1440 &lt; 1440:\n            time_of_day = self.env.now % 1440\n            if self.is_out_of_hours(time_of_day):\n                # Change the Global Class variable for the generator to TRUE\n                g.patient_arrival_gen_1 = False\n                g.patient_arrival_gen_2 = True\n\n                # Increment the patient counter by 1 for each new patient\n                self.patient_counter += 1\n\n                # Create a new patient - an instance of the Patient Class we\n                # defined above. patient counter ID passed from above to patient\n                # class.\n                p = Patient(self.patient_counter)\n                self.patient_objects.append(p)\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83c\udf19 OUT OF HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                    identifier=p.id,\n                    config=g.trace_config,\n                )\n\n                p.arrived_ooh = True\n                if self.env.now &lt; g.warm_up_period:\n                    p.generated_during_warm_up = True\n\n                # Tell SimPy to start the stroke assessment function with\n                # this patient (the generator function that will model the\n                # patient's journey through the system)\n                self.env.process(self.stroke_assessment(p))\n\n                # TODO: SR query: explore whether this is the most intuitive/easily managed way to\n                # handle interarrival rate. I think this means arrivals average\n                # every 666.6 minutes.\n                sampled_inter = random.expovariate(0.0075 / g.patient_inter_night)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\u23f2\ufe0f Next OOH patient arriving in {sampled_inter:.1f} minutes\",\n                    identifier=p.id,\n                    config=g.trace_config,\n                )\n\n                # Freeze this instance of this function in place until the\n                # inter-arrival time has elapsed.\n                yield self.env.timeout(sampled_inter)\n\n            else:\n                yield self.env.timeout(1)\n\n    # MARK: M: Obstruct CTP\n    def obstruct_ctp(self):\n        \"\"\"\n        Simulates periodic CTP scanner unavailability (off time).\n\n        This process acts as a \"blocker\" by requesting the CTP scanner resource\n        with a priority of -1. Since patients typically have a priority of 1,\n        this process effectively preempts the queue, preventing patients from\n        using the scanners during this period.\n\n        The scanner will not stop a scan that is already in progress;\n        it waits for the current user to finish before taking the\n        resource offline.\n\n        Frequencies and durations are governed by `g.ctp_unav_freq`\n        and `g.ctp_unav_time`.\n\n        Yields\n        ------\n        simpy.events.Timeout\n            Initial offset for opening hours and subsequent intervals\n            between downtime events.\n        simpy.events.ResourceRequest\n            A high-priority request to seize the CTP scanner and take\n            it \"offline.\"\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n\n        \"\"\"\n        # TODO SR: Confirm this is ok with John\n        # SR: Add initial offset\n        # SR: Patient generators have also been updated\n        # to match with how this is working\n        yield self.env.timeout(g.ctp_opening_hour * 60)\n\n        while True:\n            yield self.env.timeout(g.ctp_unav_freq)\n            # Once elapsed, this generator requests the ctp scanner with\n            # a priority of -1. As the patient priority is set at 1\n            # the scanner will take priority over any patients waiting.\n            # This method also means that the scanner won't stop mid scan.\n            g.ctp_unav = True\n            with self.ctp_scanner.request(priority=-1) as req:\n                yield req\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83d\udd2c CTP scanner OFFLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                    identifier=self.patient_counter,\n                    config=g.trace_config,\n                )\n                # Freeze with the scanners held in place for the unavailability\n                # time, in the model this means patients admitted in this time\n                # will not have a ctp scan.\n                # freq and unav times are set in the g class\n                yield self.env.timeout(g.ctp_unav_time)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83d\udd2c CTP scanner back ONLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                    identifier=self.patient_counter,\n                    config=g.trace_config,\n                )\n                g.ctp_unav = False\n\n    # MARK: M: Obstruct SDEC\n    def obstruct_sdec(self):\n        \"\"\"\n        Simulates the scheduled closure or unavailability of the SDEC unit.\n\n        Similar to the CTP obstruction, this process seizes an SDEC bed\n        at a high priority (-1) for a defined duration. This models the\n        real-world scenario where the SDEC unit closes at night or\n        during specific hours, forcing patients to bypass this pathway.\n\n        If a closure occurs after the simulation warm-up period, the\n        `sdec_freeze_counter` is incremented.\n\n        Patients arriving while the SDEC is \"obstructed\" will be\n        unable to access SDEC resources.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # TODO SR: Confirm this is ok with John\n        #  SR: Add initial offset\n        # SR: Patient generators have also been updated\n        # to match with how this is working\n        yield self.env.timeout(g.sdec_opening_hour * 60)\n\n        while True:\n            yield self.env.timeout(g.sdec_unav_freq)\n            # Once elapsed, this generator requests the SDEC with\n            # a priority of -1. As the patient priority is set at 1\n            # the SDEC will take priority over any patients waiting.\n            g.sdec_unav = True\n            with self.sdec_bed.request(priority=-1) as req:\n                yield req\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83c\udfe5 SDEC CLOSES at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                    identifier=self.patient_counter,\n                    config=g.trace_config,\n                )\n\n                # Freeze with the SDEC held in place for the unavailability\n                # time, in the model this means patients admitted in this time\n                # will not have passed through the SDEC.\n                # freq and unav times are set in the g class\n                yield self.env.timeout(g.sdec_unav_time)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83c\udfe5 SDEC OPENS at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                    identifier=self.patient_counter,\n                    config=g.trace_config,\n                )\n                g.sdec_unav = False\n                if self.env.now &gt; g.warm_up_period:\n                    self.sdec_freeze_counter += 1\n\n    # MARK: M: Stroke assessment\n    # A generator function that represents the pathway for a patient going\n    # through the stroke assessment process.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def stroke_assessment(self, patient):\n        \"\"\"\n        Simulates the full assessment and treatment pathway for patients\n        in a stroke pathway.\n\n        Parameters\n        ----------\n        patient : Instance of class `Patient`\n            One single unique patient object.\n        \"\"\"\n        # This code introduces a slight element of randomness into the patient's\n        # diagnosis.\n\n        self.ich_range = random.normalvariate(g.ich, 1)\n        self.i_range = max(random.normalvariate(g.i, 1), self.ich_range)\n        self.tia_range = max(random.normalvariate(g.tia, 1), self.i_range)\n        self.stroke_mimic_range = max(\n            random.normalvariate(g.stroke_mimic, 1), self.tia_range\n        )\n        self.non_stroke_range = max(\n            random.normalvariate(g.stroke_mimic, 1), self.stroke_mimic_range\n        )\n\n        if patient.diagnosis &lt;= self.ich_range:\n            patient.patient_diagnosis = 0\n        elif patient.diagnosis &lt;= self.i_range:\n            patient.patient_diagnosis = 1\n        elif patient.diagnosis &lt;= self.tia_range:\n            patient.patient_diagnosis = 2\n        elif patient.diagnosis &lt;= self.stroke_mimic_range:\n            patient.patient_diagnosis = 3\n        elif patient.diagnosis &gt; self.non_stroke_range:\n            patient.patient_diagnosis = 4\n        # TODO: SR have added this else clause but need to confirm this is correct\n        # TODO: SR patients were occasionally not getting allocated a diagnosis and\n        # TODO: SR this would then cause issues with generating LOS etc\n        else:\n            patient.patient_diagnosis = 4\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"Patient {patient.id} Patient Diagnosis (category 1-4): {patient.patient_diagnosis}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        # Record the time the patient started queuing for a nurse\n        start_q_nurse = self.env.now\n\n        self.q_for_assessment.append(patient)\n\n        # Add the arrival time to the main DF, this is mainly to test if the\n        # patinet arrival times mirror the real world data\n\n        patient.clock_start = self.env.now\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Arrival Time\"] = patient.clock_start\n\n            self.results_df.at[patient.id, \"Patient Gen 1 Status\"] = (\n                g.patient_arrival_gen_1\n            )\n\n            self.results_df.at[patient.id, \"Patient Gen 2 Status\"] = (\n                g.patient_arrival_gen_2\n            )\n\n        # This code says request a nurse resource, and do all of the following\n        # block of code with that nurse resource held in place (and therefore\n        # not usable by another patient)\n        with self.nurse.request() as req:\n            # Freeze the function until the request for a nurse can be met.\n            # The patient is currently queuing.\n            yield req\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udc69\u200d\u2695\ufe0f Patient {patient.id} is being seen by a nurse at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            # Control is passed back to the generator function once the request\n            # is met for a nurse. As the queue for the nurse is finished\n            # the patient then leaves the assessment queue list.\n\n            end_q_nurse = self.env.now\n\n            self.q_for_assessment.remove(patient)\n\n            # The code below checks if the warm up period has passed before\n            # entering data into the df, this code exists when ever data is\n            # recorded\n\n            if self.env.now &gt; g.warm_up_period:\n                self.nurse_q_graph_df.loc[len(self.nurse_q_graph_df)] = [\n                    self.env.now,\n                    len(self.q_for_assessment),\n                ]\n\n            # Calculate the time this patient was queuing for the nurse, and\n            # record it in the patient's attribute\n            patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n            # The below code creates a random action time for the nurse based\n            # on the mean in g class, and assigns it ot a variable. Currently\n            # using a Exponential distribution but might need to switch to\n            # a Log normal one (though the intense variation in the real life\n            # consult time might mean a exponetial distribution is better)\n            sampled_nurse_act_time = random.expovariate(1.0 / g.mean_n_consult_time)\n\n            # Freeze this function in place for the activity time we sampled\n            # above.  This is the patient spending time with the nurse.\n            yield self.env.timeout(sampled_nurse_act_time)\n\n            # In the .at function below, the first value is the row, the second\n            # value is the column in which to add data. The final value is the\n            # the data that is to be added to the DF, in this case the Nurse\n            # Q time\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Nurse\"] = patient.q_time_nurse\n                self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                    sampled_nurse_act_time\n                )\n\n        # MARK: CT Perfusion Scanner Use\n        # The if formula below checks to see if the CTP scanner is active\n        # and if it is the following code is followed including updating the\n        # patient advanced CT pathway attribute\n\n        if g.ctp_unav == False:\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u27a1\ufe0f Patient {patient.id} sent on CTP scanner pathway at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            patient.advanced_ct_pathway = True\n\n            # Randomly sample the mean ct time, as with above this may need to\n            # be updated to a log normal distribution\n\n            sampled_ctp_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n            patient.ctp_duration = sampled_ctp_act_time\n            # Freeze this function in place for the activity time that was\n            # sampled above.\n            yield self.env.timeout(sampled_ctp_act_time)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u27a1\ufe0f Patient {patient.id} finishes CTP scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ctp_act_time:.1f} minutes.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            # Add data to the DF afer the warm up period.\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Time with CTP\"] = sampled_ctp_act_time\n\n        # If the CTP pathway is not active the below code runs, it is the same\n        # as the above however adds data to a different column and the patient\n        # advanced CT pathway remains False.\n\n        else:\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udeab Patient {patient.id} NOT sent on CTP scanner pathway - normal CT scan commencing at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            # TODO: SR: Confirm if ct act time should still pass in this instance\n            # TODO: SR: Is a standard CT scan performed when CT perfusion scanner not available?\n            sampled_ct_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n            patient.ct_duration = sampled_ct_act_time\n\n            yield self.env.timeout(sampled_ct_act_time)\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udeab Patient {patient.id} finishes normal CT scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ct_act_time:.1f} minutes.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Time with CT\"] = sampled_ct_act_time\n\n        # The below code records the status of both the CTP pathway.\n        # Both exist as generators and this data is record to ensure they are\n        # operating as expected.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"CTP Status\"] = g.ctp_unav\n\n        # The below code checks the patient's attributes to see if the\n        # thrombolysis attribute should be changed to True, this is based off\n        # the patient diagnosis, onset type and mrs type. There are different\n        # conditions depending on if CTP is available or not.\n\n        if (\n            patient.patient_diagnosis == 1\n            and patient.onset_type == 0\n            and patient.mrs_type &gt; 0\n        ):\n            patient.thrombolysis = True\n\n        if (\n            patient.patient_diagnosis == 1\n            and patient.onset_type == 1\n            and patient.advanced_ct_pathway == True\n            and patient.mrs_type &gt; 0\n        ):\n            patient.thrombolysis = True\n\n        # Thrombolysis status is added to the DF, this is mainly used to check\n        # if it is being applied correctly.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Thrombolysis\"] = patient.thrombolysis\n\n        # The below code records the status of both the SDEC pathway.\n        # Both exist as generators and this data is recorded to ensure they are\n        # operating as expected.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"SDEC Status\"] = g.sdec_unav\n\n        # MARK: SDEC Admission\n        # The if statement below checks if the SDEC pathway is active at this\n        # given time and if there is space in the SDEC itself.\n\n        if g.sdec_unav == False and len(self.sdec_occupancy) &lt;= g.sdec_beds:\n            # If the conditions above are met the patient attribute for the SDEC\n            # are changed to True and the patient is added to the SDEC occupancy\n            # list.\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udecf\ufe0f\ud83c\udfce\ufe0f Patient {patient.id} admitted to SDEC (occupancy before admission: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds) at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            self.sdec_occupancy.append(patient)\n\n            # The below code record the SDEC Occupancy as the patient passes\n            # this point to ensure it is working as expected.\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"SDEC Occupancy\"] = len(\n                    self.sdec_occupancy\n                )\n\n            patient.sdec_pathway = True\n\n            # This code checks if the patient is eligible for admission\n            # avoidance depending on if therapy support is enabled.\n\n            if g.therapy_sdec == False:\n                if (\n                    patient.patient_diagnosis &lt; 2\n                    and patient.mrs_type &lt; 2\n                    and patient.thrombolysis == False\n                ):\n                    patient.admission_avoidance = True\n\n            elif g.therapy_sdec == True:\n                if (\n                    patient.patient_diagnosis &lt; 2\n                    and patient.mrs_type &lt;= 3\n                    and patient.thrombolysis == False\n                ):\n                    patient.admission_avoidance = True\n\n            # This code applies a non stroke admission avoidance variable to the\n            # patient.\n\n            self.tia_admission_chance = random.normalvariate(g.tia_admission, 1)\n            self.stroke_mimic_admission_chance = random.normalvariate(\n                g.stroke_mimic_admission, 1\n            )\n\n            if (\n                patient.non_admission &gt;= self.tia_admission_chance\n                and patient.patient_diagnosis == 2\n            ):\n                patient.admission_avoidance = True\n\n            elif (\n                patient.non_admission &gt;= self.stroke_mimic_admission_chance\n                and patient.patient_diagnosis &gt; 2\n            ):\n                patient.admission_avoidance = True\n\n            # Calculate SDEC stay time from exponential\n            sampled_sdec_stay_time = random.expovariate(1.0 / g.mean_n_sdec_time)\n\n            # Add patient SDEC LOS to their patient object\n            patient.sdec_los = sampled_sdec_stay_time\n            # Freeze this function in place for the activity time we sampled\n            # above.\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in SDEC for {sampled_sdec_stay_time:.1f} minutes ({(sampled_sdec_stay_time / 60 / 24):.1f} days).\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n            yield self.env.timeout(sampled_sdec_stay_time)\n\n            # This code checks if the ward is full, if this is the case the\n            # patient will not be released from the SDEC, thus impeding it use\n\n            if patient.admission_avoidance != True:\n                while len(self.ward_occupancy) &gt;= g.number_of_ward_beds:\n                    yield self.env.timeout(1)\n\n            # Once the above code is complete the patient is removed from the\n            # SDEC occupancy list.\n\n            self.sdec_occupancy.remove(patient)\n\n            # Code to record the SDEC stay time in the results DataFrame.\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Time in SDEC\"] = sampled_sdec_stay_time\n\n            # MARK: Discharged from SDEC\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udfce\ufe0f Patient {patient.id} discharged from SDEC at {minutes_to_ampm(int(self.env.now % 1440))} after {patient.sdec_los:.1f} minutes ({(patient.sdec_los / 60 / 24):.1f} days). Occupancy after discharge: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n        # The below code records the patients diagnosis attribute, this is added\n        # to the DF to check the diagnosis code is working correctly.\n\n        if patient.patient_diagnosis == 0 and self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Diagnosis Type\"] = \"ICH\"\n            patient.patient_diagnosis_type = \"ICH\"\n        elif patient.patient_diagnosis == 1 and self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Diagnosis Type\"] = \"I\"\n            patient.patient_diagnosis_type = \"I\"\n        elif patient.patient_diagnosis == 2 and self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Diagnosis Type\"] = \"TIA\"\n            patient.patient_diagnosis_type = \"TIA\"\n        elif patient.patient_diagnosis == 3 and self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Diagnosis Type\"] = \"Stroke Mimic\"\n            patient.patient_diagnosis_type = \"Stroke Mimic\"\n        elif patient.patient_diagnosis == 4 and self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Diagnosis Type\"] = \"Non Stroke\"\n            patient.patient_diagnosis_type = \"Non Stroke\"\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Onset Type\"] = patient.onset_type\n\n        # This code add information regarding the patients admission avoidance.\n\n        if patient.admission_avoidance == True and patient.patient_diagnosis &lt; 2:\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Admission Avoidance\"] = (\n                    patient.sdec_pathway\n                )\n\n                last_index = self.results_df[\"SDEC Savings\"].last_valid_index()\n                last_value = self.results_df.loc[last_index, \"SDEC Savings\"]\n                if last_index &gt; 0 and pd.notnull:\n                    self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                        last_value + g.inpatient_bed_cost\n                    )\n\n                else:\n                    self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                        g.inpatient_bed_cost\n                    )\n\n        # This code adds the Patient's MRS to the DF, this can be used to check\n        # all code that interacts with this runs correctly.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"MRS Type\"] = patient.mrs_type\n\n        # Patients with a True admission avoidance are added to a list that is\n        # used to calculate the savings from the avoided admissions.\n\n        if (\n            patient.admission_avoidance == True\n            and patient.patient_diagnosis &lt; 2\n            and self.env.now &gt; g.warm_up_period\n        ):\n            self.admission_avoidance.append(patient)\n\n        # This code introduces a small element of randomness into the admission\n        # rates for the non stroke, tia and stroke mimic patients.\n\n        self.tia_admission_chance = random.normalvariate(g.tia_admission, 1)\n        self.stroke_mimic_admission_chance = random.normalvariate(\n            g.stroke_mimic_admission, 1\n        )\n\n        # This code exists after the admission avoidance code so they are not\n        # added to the admission avoidance list, as that should only be for\n        # SDEC patients who avoid admission. This code checks if TIA, non stroke\n        # and stroke mimic patients should be admitted based on the values\n        # established in the previous code and g class.\n\n        if (\n            patient.non_admission &gt;= self.tia_admission_chance\n            and patient.patient_diagnosis == 2\n        ):\n            patient.admission_avoidance = True\n\n        elif (\n            patient.non_admission &gt;= self.stroke_mimic_admission_chance\n            and patient.patient_diagnosis &gt; 2\n        ):\n            patient.admission_avoidance = True\n\n        # MARK: Ward Admission\n        # once all the above code has been run all patients who will not admit\n        # have a True admission avoidance attribute. For all the patients that\n        # remain false, the below code will run simulating the admission to the\n        # ward.\n\n        if patient.admission_avoidance != True:\n            # These code assigns a time to the start q variable. In stroke care\n            # delays can have serious consequence so modeling this is very\n            # important as flow disruption are a common issue.\n\n            start_q_ward = self.env.now\n\n            # Request the ward bed and hold the patient in a queue until this\n            # is met.\n\n            with self.ward_bed.request() as req:\n                yield req\n                # Add patient to the ward list\n\n                self.ward_occupancy.append(patient)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"\ud83d\udecf\ufe0f Patient {patient.id} admitted to main ward at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy after admission: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.results_df.at[patient.id, \"Ward Occupancy\"] = len(\n                        self.ward_occupancy\n                    )\n\n                if self.env.now &gt; g.warm_up_period:\n                    self.occupancy_graph_df.loc[len(self.occupancy_graph_df)] = [\n                        self.env.now,\n                        len(self.ward_occupancy),\n                    ]\n\n                # The patient attribute for the queuing time in the ward is\n                # assigned here.\n\n                end_q_ward = self.env.now\n\n                patient.q_time_ward = end_q_ward - start_q_ward\n\n                # The below code checks the patients diagnosis and MRS,\n                # adjusting MRS change and LOS baised on these. This code is\n                # for ICH patients.\n\n                ###############################\n                # MARK: Patient diagnosis = 0 #\n                # Intracerebral haemorrhage   #\n                # Unsuitable for thrombolysis #\n                ###############################\n\n                if patient.patient_diagnosis == 0 and patient.mrs_type == 0:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_ich_ward_time_mrs_0\n                    )\n                    patient.mrs_discharge = patient.mrs_type\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 1:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_ich_ward_time_mrs_1\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 2:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_ich_ward_time_mrs_2\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 3:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_ich_ward_time_mrs_3\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 4:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_ich_ward_time_mrs_4\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 0 and patient.mrs_type == 5:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_ich_ward_time_mrs_5\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                ###############################\n                # MARK: Patient diagnosis = 1 #\n                # Ischaemic Stroke            #\n                # Some may be suitable for    #\n                # thrombolysis                #\n                ###############################\n\n                # The below code checks the patients diagnosis and MRS,\n                # adjusting MRS change and LOS baised on these. This code is\n                # for I patients amd also checks for thrombolysis and adjusts\n                # LOS and associated savings accordingly.\n\n                if patient.patient_diagnosis == 1 and patient.mrs_type == 0:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_i_ward_time_mrs_0\n                    )\n                    patient.mrs_discharge = patient.mrs_type\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 1:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_i_ward_time_mrs_1\n                    )\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 2:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_i_ward_time_mrs_2\n                    )\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 3:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_i_ward_time_mrs_3\n                    )\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 4:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_i_ward_time_mrs_4\n                    )\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        self.ward_occupancy.remove(patient)\n\n                elif patient.patient_diagnosis == 1 and patient.mrs_type == 5:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_i_ward_time_mrs_5\n                    )\n                    if patient.thrombolysis == True:\n                        sampled_ward_act_time_thrombolysis = (\n                            sampled_ward_act_time * g.thrombolysis_los_save\n                        )\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        # Record generated LOS in patient object\n                        patient.ward_los_thrombolysis = (\n                            sampled_ward_act_time_thrombolysis\n                        )\n                        yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                        if (\n                            self.env.now &gt; g.warm_up_period\n                            and patient.advanced_ct_pathway == True\n                        ):\n                            self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                                (\n                                    (\n                                        sampled_ward_act_time\n                                        - sampled_ward_act_time_thrombolysis\n                                    )\n                                    / 60\n                                )\n                                / 24\n                            ) * g.inpatient_bed_cost_thrombolysis\n                        self.ward_occupancy.remove(patient)\n                    else:\n                        patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                        trace(\n                            time=self.env.now,\n                            debug=g.show_trace,\n                            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                            identifier=patient.id,\n                            config=g.trace_config,\n                        )\n                        # Record generated LOS in patient object\n                        patient.ward_los = sampled_ward_act_time\n                        yield self.env.timeout(sampled_ward_act_time)\n                        self.ward_occupancy.remove(patient)\n\n                #################################\n                # MARK: Patient diagnosis = 2   #\n                # Transient Ischaemic Attack    #\n                # Not suitable for thrombolysis #\n                #################################\n                # The below code is for the non stroke diagnosis.\n\n                if patient.patient_diagnosis == 2:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_tia_ward_time\n                    )\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    # Record generated LOS in patient object\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n                ###############################\n                # MARK: Patient diagnosis &gt; 2 #\n                # Stroke mimic OR non-stroke  #\n                ###############################\n                if patient.patient_diagnosis &gt; 2:\n                    sampled_ward_act_time = random.expovariate(\n                        1.0 / g.mean_n_non_stroke_ward_time\n                    )\n\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n\n                    # Record generated LOS in patient object\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n            # Relevent information is recorded in the results DataFrame.\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Q Time Ward\"] = patient.q_time_ward\n\n            # TODO: SR: Confirm this is expected\n            # SR: This triggered an error in a patient with a diagnosis of 1 and MRS of 0\n            # who didn't seem to have a ward stay\n            # TODO: SR: I've tweaked this to take whichever of the ward_los or thrombolysis los is generated\n            # TODO SR: It would be better to take a more robust approach to this step.\n            try:\n                final_ward_los = sampled_ward_act_time\n            except:\n                final_ward_los = sampled_ward_act_time_thrombolysis\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Ward LOS\"] = final_ward_los\n\n                self.results_df.at[patient.id, \"MRS DC\"] = patient.mrs_discharge\n\n                self.results_df.at[patient.id, \"MRS Change\"] = (\n                    patient.mrs_type - patient.mrs_discharge\n                )\n\n            # MARK: Discharged from main ward\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\ude97 Patient {patient.id} discharged from main ward at {minutes_to_ampm(int(self.env.now % 1440))} after {final_ward_los:.1f} minutes ({(final_ward_los / 24 / 60):.1f} days). Occupancy after discharge: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n    # MARK: M: Run result calculation\n    # This method calculates results over a single run.\n    def calculate_run_results(self):\n        \"\"\"\n        Calculate summary statistics and financial metrics for a single simulation run.\n\n        This method aggregates raw data collected throughout the simulation,\n        performs unit conversions, and computes Key Performance Indicators (KPIs)\n        related to clinical flow and financial impact. It cleans the results\n        dataframe and updates class-level attributes for use in trial-level reporting.\n\n        - **Data Cleaning**: Removes the initial dummy row (index label 1) used\n          to initialize the `results_df`.\n        - **Unit Conversions**: Automatically converts ward-related timings\n          (Queue Time and Length of Stay) from minutes to hours for reporting.\n        - **SDEC Logic**: Financial staff costs for SDEC are adjusted based on\n          the `sdec_freeze_counter` to ensure costs are only incurred during\n          active operational periods.\n        - **Precision**:\n            - Financial and time-based KPIs are rounded to 0 decimal places.\n            - Clinical outcomes (MRS Change) are rounded to 2 decimal places.\n\n        Calculated Attributes\n        ---------------------\n        mean_q_time_nurse : float\n            Average wait time for a nurse in minutes.\n        number_of_admissions_avoided : int\n            Total count of patients diverted from inpatient wards via SDEC.\n        mean_q_time_ward : float\n            Average wait time for a ward bed in hours.\n        mean_ward_occupancy : float\n            The average number of beds occupied during the run.\n        admission_delays : int\n            Total number of patients who experienced any wait time for a ward bed.\n        mean_los_ward : float\n            Average inpatient length of stay in hours.\n        sdec_financial_savings : float\n            Gross savings based on avoided bed days.\n        medical_staff_cost : float\n            The net operational cost of SDEC staffing.\n        savings_sdec : float\n            Net financial impact (Savings - Costs) of the SDEC unit.\n        total_savings : float\n            Combined net impact of SDEC and thrombolysis-related savings.\n        mean_mrs_change : float\n            Average change in Modified Rankin Scale for the patient cohort.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # Drop the first row of the results DataFrame, as this is just a dummy\n        # and will take on the value of zero.\n        self.results_df.drop([1], inplace=True)\n\n        # The below code calculates the average or cumulative values the model\n        # is concerned with.\n\n        self.mean_q_time_nurse = round(self.results_df[\"Q Time Nurse\"].mean(), 0)\n\n        self.number_of_admissions_avoided = len(self.admission_avoidance)\n\n        self.mean_q_time_ward = round(self.results_df[\"Q Time Ward\"].mean() / 60, 0)\n\n        self.mean_ward_occupancy = round(self.results_df[\"Ward Occupancy\"].mean())\n\n        self.admission_delays = len(self.results_df[self.results_df[\"Q Time Ward\"] &gt; 0])\n\n        self.mean_los_ward = round(self.results_df[\"Ward LOS\"].mean() / 60, 0)\n\n        self.sdec_financial_savings = (\n            len(self.admission_avoidance) * g.inpatient_bed_cost\n        )\n\n        # The below code ensures that the SDEC incurs no cost if it is not\n        # running at all in the model. This was introduced as a bug was causing\n        # it to return small values even if the SDEC was not running. This is\n        # now fixed, but the code works so I have left it in place.\n\n        if g.sdec_unav_freq == 0:\n            self.medical_staff_cost = 0\n        else:\n            self.medical_staff_cost = round(\n                g.sdec_dr_cost_min * (g.sim_duration)\n                - g.sdec_dr_cost_min * self.sdec_freeze_counter * g.sdec_unav_time,\n                0,\n            )\n\n        self.savings_sdec = round(\n            self.sdec_financial_savings - self.medical_staff_cost, 0\n        )\n\n        self.thrombolysis_savings = round(\n            self.results_df[\"Thrombolysis Savings\"].sum(), 0\n        )\n        self.total_savings = self.thrombolysis_savings + self.savings_sdec\n\n        self.mean_mrs_change = round(self.results_df[\"MRS Change\"].mean(), 2)\n\n    # MARK: M: per-run plotting\n    # This method plots the stroke nurse assessment queue graph, as it is after\n    # the run method it will appear after the run has completed in the output.\n    # Might need to change this...\n\n    def plot_stroke_run_graphs(self, plot=True):\n        \"\"\"\n        Generate and display time-series visualizations for the simulation run.\n\n        This method creates a line plot of the Stroke Ward occupancy over the\n        duration of the simulation. It includes both the raw occupancy data\n        and a linear trend line to help identify long-term capacity issues.\n        Execution is dependent on the global `g.gen_graph` toggle.\n\n        - **Data Cleaning**: Automatically drops the first row (index 0) of\n          `occupancy_graph_df`, which is typically used as a placeholder.\n        - **Trend Analysis**: Uses a first-order polynomial fit (`numpy.polyfit`)\n          to calculate and display a linear trend line over the occupancy data.\n        - **Extensibility**: Contains placeholder (commented-out) logic for\n          an additional \"Nurse Assessment Queue\" graph.\n        - **Dependencies**: Requires `matplotlib.pyplot` as `plt` and\n          `numpy` as `np`.\n\n        Parameters\n        ----------\n        plot : bool, default True\n            If True, the generated figure is displayed immediately using\n            `plt.show()`. If False, the figure object is returned to the\n            caller for further processing (e.g., aggregation in a Trial report).\n\n        Returns\n        -------\n        matplotlib.figure.Figure or None\n            Returns a Matplotlib Figure object if `plot` is False.\n            Returns None if `plot` is True or if `g.gen_graph` is False.\n\n\n        See Also\n        --------\n        Trial.run_trial : The method that may collect these figures for batch reporting.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        if g.gen_graph == True:\n            # Queue for Nurse Assessment Graph (Currently Commented Out)\n\n            # self.nurse_q_graph_df.drop([0], inplace=True)\n\n            # fig, ax = plt.subplots()\n\n            # ax.set_xlabel(\"Time\")\n            # ax.set_ylabel(\"Number of patients in Q for Assessment\")\n            # ax.set_title(f\"Number of Patients in Nurse Assessment Queue \\\n            # Over Time \"f\"{self.run_number}\")\n\n            # ax.plot(self.nurse_q_graph_df[\"Time\"],\n            # self.nurse_q_graph_df[\"Patients in Assessment Queue\"],\n            # color=\"m\",\n            # linestyle=\"-\",\n            # label=\"Q for Stroke Nurse Assessment\")\n\n            # ax.legend(loc=\"upper right\")\n\n            # fig.show()\n\n            # Ward Occupancy Graph\n\n            self.occupancy_graph_df.drop([0], inplace=True)\n\n            fig, ax = plt.subplots()\n\n            ax.set_xlabel(\"Time\")\n            ax.set_ylabel(\"Stroke Ward Occupancy\")\n            ax.set_title(\n                f\"Trial \"\n                f\"{g.trials_run_counter}\\\n                         Ward Occupancy Over Time \"\n                f\"{self.run_number}\"\n            )\n\n            ax.plot(\n                self.occupancy_graph_df[\"Time\"],\n                self.occupancy_graph_df[\"Ward Occupancy\"],\n                color=\"b\",\n                linestyle=\"-\",\n                label=\"Ward Occupancy\",\n            )\n\n            # Add trend line\n            x = self.occupancy_graph_df[\"Time\"]\n            y = self.occupancy_graph_df[\"Ward Occupancy\"]\n            z = np.polyfit(x, y, 1)  # 1 = linear fit\n            p = np.poly1d(z)\n            ax.plot(x, p(x), color=\"b\", linestyle=\"--\", label=\"Trend Line\")\n\n            ax.legend(loc=\"upper right\")\n\n            if plot:\n                fig.show()\n            else:\n                return fig\n\n    def track_days(self):\n        \"\"\"\n        A SimPy process that logs the progression of simulation days.\n\n        This generator functions as a background 'clock' process. It wakes up\n        at the start of every 1440-minute interval (24 hours) to output a\n        formatted debug message indicating the current day of the simulation\n        run. This helps track progress in the console during long-running\n        simulations.\n\n        - The day calculation is performed using floor division:\n          `self.env.now // 1440`.\n        - The trace message visibility depends on the `g.show_trace` flag and\n          the `g.tracked_cases` configuration.\n        - This process runs concurrently with patient arrivals and clinical\n          obstructions without interfering with their logic.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # Print a debugging message every day\n        while self.env.now &lt;= g.sim_duration:\n            # TODO: this doesn't always reliably appear depending on number of tracked cases\n            trace(\n                msg=f\"========= DAY {(self.env.now // 1440):.0f} ===============\",\n                time=self.env.now,\n                debug=g.show_trace,\n                identifier=max(g.tracked_cases),\n                config=g.trace_config,\n            )\n            yield self.env.timeout(1440)\n\n    # MARK: M: run model\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        \"\"\"\n        Execute the simulation run lifecycle.\n\n        This method initializes the simulation by registering background\n        processes, executes the SimPy event loop for a specified duration,\n        and performs post-simulation data processing and export tasks.\n\n        The execution sequence is as follows:\n        1. Register time-tracking, patient arrival, and resource obstruction\n           generators as SimPy processes.\n        2. Execute the simulation engine until the combined limit of the\n           warm-up period and active simulation duration is reached.\n        3. Trigger final calculation of run-level results.\n        4. (Optional) Export patient-level results to a CSV file.\n\n        - **Warm-up Period**: The total runtime includes `g.warm_up_period`. This\n          is crucial for allowing the model to reach a 'steady state' before\n          results are recorded as valid.\n        - **Concurrency**: All methods passed to `self.env.process()` run\n          pseudo-parallelly, managed by the SimPy event scheduler.\n        - **Post-Processing**: This method must be called for `results_df`\n          and other KPIs to be populated with final values.\n\n        See Also\n        --------\n        track_days : The background process that logs day transitions.\n\n        generator_patient_arrivals: generates in-hours patients and sends them through the\n            assessment pathway\n\n        generator_patient_arrivals_ooh: generates out-of-hours patients and sends them through the\n            assessment pathway\n\n        obstruct_ctp: ensures the ctp scanner is only available for the specified times\n\n        obstruct_sdec: ensures the sdec is only available for the specified times\n\n        calculate_run_results : The method called to process data after the\n            event loop finishes.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # starts up the generators in the model, of which there are three.\n\n        self.env.process(self.track_days())\n        self.env.process(self.generator_patient_arrivals())\n        self.env.process(self.generator_patient_arrivals_ooh())\n        self.env.process(self.obstruct_ctp())\n        self.env.process(self.obstruct_sdec())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        # Print the run number with the patient-level results from this run of\n        # the model, this is commented out at the moment.\n\n        # print (f\"Run Number {self.run_number}\")\n        # print (self.results_df)\n\n        if g.write_to_csv == True:\n            self.results_df.to_csv(\n                f\"trial {g.trials_run_counter} output {self.run_number}.csv\",\n                index=False,\n            )\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.calculate_run_results","title":"<code>calculate_run_results()</code>","text":"<p>Calculate summary statistics and financial metrics for a single simulation run.</p> <p>This method aggregates raw data collected throughout the simulation, performs unit conversions, and computes Key Performance Indicators (KPIs) related to clinical flow and financial impact. It cleans the results dataframe and updates class-level attributes for use in trial-level reporting.</p> <ul> <li>Data Cleaning: Removes the initial dummy row (index label 1) used   to initialize the <code>results_df</code>.</li> <li>Unit Conversions: Automatically converts ward-related timings   (Queue Time and Length of Stay) from minutes to hours for reporting.</li> <li>SDEC Logic: Financial staff costs for SDEC are adjusted based on   the <code>sdec_freeze_counter</code> to ensure costs are only incurred during   active operational periods.</li> <li>Precision:<ul> <li>Financial and time-based KPIs are rounded to 0 decimal places.</li> <li>Clinical outcomes (MRS Change) are rounded to 2 decimal places.</li> </ul> </li> </ul> Calculated Attributes <p>mean_q_time_nurse : float     Average wait time for a nurse in minutes. number_of_admissions_avoided : int     Total count of patients diverted from inpatient wards via SDEC. mean_q_time_ward : float     Average wait time for a ward bed in hours. mean_ward_occupancy : float     The average number of beds occupied during the run. admission_delays : int     Total number of patients who experienced any wait time for a ward bed. mean_los_ward : float     Average inpatient length of stay in hours. sdec_financial_savings : float     Gross savings based on avoided bed days. medical_staff_cost : float     The net operational cost of SDEC staffing. savings_sdec : float     Net financial impact (Savings - Costs) of the SDEC unit. total_savings : float     Combined net impact of SDEC and thrombolysis-related savings. mean_mrs_change : float     Average change in Modified Rankin Scale for the patient cohort.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def calculate_run_results(self):\n    \"\"\"\n    Calculate summary statistics and financial metrics for a single simulation run.\n\n    This method aggregates raw data collected throughout the simulation,\n    performs unit conversions, and computes Key Performance Indicators (KPIs)\n    related to clinical flow and financial impact. It cleans the results\n    dataframe and updates class-level attributes for use in trial-level reporting.\n\n    - **Data Cleaning**: Removes the initial dummy row (index label 1) used\n      to initialize the `results_df`.\n    - **Unit Conversions**: Automatically converts ward-related timings\n      (Queue Time and Length of Stay) from minutes to hours for reporting.\n    - **SDEC Logic**: Financial staff costs for SDEC are adjusted based on\n      the `sdec_freeze_counter` to ensure costs are only incurred during\n      active operational periods.\n    - **Precision**:\n        - Financial and time-based KPIs are rounded to 0 decimal places.\n        - Clinical outcomes (MRS Change) are rounded to 2 decimal places.\n\n    Calculated Attributes\n    ---------------------\n    mean_q_time_nurse : float\n        Average wait time for a nurse in minutes.\n    number_of_admissions_avoided : int\n        Total count of patients diverted from inpatient wards via SDEC.\n    mean_q_time_ward : float\n        Average wait time for a ward bed in hours.\n    mean_ward_occupancy : float\n        The average number of beds occupied during the run.\n    admission_delays : int\n        Total number of patients who experienced any wait time for a ward bed.\n    mean_los_ward : float\n        Average inpatient length of stay in hours.\n    sdec_financial_savings : float\n        Gross savings based on avoided bed days.\n    medical_staff_cost : float\n        The net operational cost of SDEC staffing.\n    savings_sdec : float\n        Net financial impact (Savings - Costs) of the SDEC unit.\n    total_savings : float\n        Combined net impact of SDEC and thrombolysis-related savings.\n    mean_mrs_change : float\n        Average change in Modified Rankin Scale for the patient cohort.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # Drop the first row of the results DataFrame, as this is just a dummy\n    # and will take on the value of zero.\n    self.results_df.drop([1], inplace=True)\n\n    # The below code calculates the average or cumulative values the model\n    # is concerned with.\n\n    self.mean_q_time_nurse = round(self.results_df[\"Q Time Nurse\"].mean(), 0)\n\n    self.number_of_admissions_avoided = len(self.admission_avoidance)\n\n    self.mean_q_time_ward = round(self.results_df[\"Q Time Ward\"].mean() / 60, 0)\n\n    self.mean_ward_occupancy = round(self.results_df[\"Ward Occupancy\"].mean())\n\n    self.admission_delays = len(self.results_df[self.results_df[\"Q Time Ward\"] &gt; 0])\n\n    self.mean_los_ward = round(self.results_df[\"Ward LOS\"].mean() / 60, 0)\n\n    self.sdec_financial_savings = (\n        len(self.admission_avoidance) * g.inpatient_bed_cost\n    )\n\n    # The below code ensures that the SDEC incurs no cost if it is not\n    # running at all in the model. This was introduced as a bug was causing\n    # it to return small values even if the SDEC was not running. This is\n    # now fixed, but the code works so I have left it in place.\n\n    if g.sdec_unav_freq == 0:\n        self.medical_staff_cost = 0\n    else:\n        self.medical_staff_cost = round(\n            g.sdec_dr_cost_min * (g.sim_duration)\n            - g.sdec_dr_cost_min * self.sdec_freeze_counter * g.sdec_unav_time,\n            0,\n        )\n\n    self.savings_sdec = round(\n        self.sdec_financial_savings - self.medical_staff_cost, 0\n    )\n\n    self.thrombolysis_savings = round(\n        self.results_df[\"Thrombolysis Savings\"].sum(), 0\n    )\n    self.total_savings = self.thrombolysis_savings + self.savings_sdec\n\n    self.mean_mrs_change = round(self.results_df[\"MRS Change\"].mean(), 2)\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.generator_patient_arrivals","title":"<code>generator_patient_arrivals()</code>","text":"<p>A SimPy process generator that handles \"in-hours\" patient arrivals.</p> <p>This function runs as a continuous loop. It checks if the current simulation time is within daytime operating hours (0-960 minutes relative to the start of a 1440-minute day).</p> <p>If in-hours, it:</p> <ol> <li> <p>Updates global arrival flags.</p> </li> <li> <p>Instantiates a new Patient object.</p> </li> <li> <p>Records trace information.</p> </li> <li> <p>Triggers the <code>stroke_assessment</code> process for the patient.</p> </li> <li> <p>Samples an inter-arrival time and yields a timeout.</p> </li> </ol> <p>If out-of-hours, it yields a small timeout before checking again.</p> <p>Arrival rates are determined by <code>random.expovariate</code> using the <code>g.patient_inter_day</code> parameter. NOTE that this does not use the <code>g.patient_inter_day</code> parameter directly, and instead uses it alongside a rate modifier - careful inspection of the code to understand the impacts of changing <code>g.patient_inter_day</code> is recommended, and this may be adjusted in a future version of the model.</p> <p>Patients generated here have their <code>arrived_ooh</code> attribute set to False.</p> <p>This process triggers the <code>stroke_assessment</code> process for every newly created patient.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def generator_patient_arrivals(self):\n    \"\"\"\n    A SimPy process generator that handles \"in-hours\" patient arrivals.\n\n    This function runs as a continuous loop. It checks if the current\n    simulation time is within daytime operating hours (0-960 minutes\n    relative to the start of a 1440-minute day).\n\n    If in-hours, it:\n\n    1. Updates global arrival flags.\n\n    2. Instantiates a new Patient object.\n\n    3. Records trace information.\n\n    4. Triggers the `stroke_assessment` process for the patient.\n\n    5. Samples an inter-arrival time and yields a timeout.\n\n    If out-of-hours, it yields a small timeout before checking again.\n\n    Arrival rates are determined by `random.expovariate` using the\n    `g.patient_inter_day` parameter. NOTE that this does not use the\n    `g.patient_inter_day` parameter directly, and instead uses it alongside\n    a rate modifier - careful inspection of the code to understand the impacts\n    of changing `g.patient_inter_day` is recommended, and this may be adjusted\n    in a future version of the model.\n\n    Patients generated here have their `arrived_ooh` attribute set to False.\n\n    This process triggers the `stroke_assessment` process for every\n    newly created patient.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    while True:\n        # if 0 &lt;= self.env.now % 1440 &lt; 960\n        time_of_day = self.env.now % 1440\n        if self.is_in_hours(time_of_day):\n            # Change the Global Class variable for the generator to TRUE\n            g.patient_arrival_gen_1 = True\n            g.patient_arrival_gen_2 = False\n\n            # Increment the patient counter by 1 for each new patient\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above. patient counter ID passed from above to patient\n            # class.\n            p = Patient(self.patient_counter)\n            self.patient_objects.append(p)\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u2600\ufe0f IN-HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                identifier=p.id,\n                config=g.trace_config,\n            )\n\n            p.arrived_ooh = False\n            if self.env.now &lt; g.warm_up_period:\n                p.generated_during_warm_up = True\n\n            # Tell SimPy to start the stroke assessment function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.stroke_assessment(p))\n\n            # TODO: SR query: explore whether this is the most intuitive/easily managed way to\n            # handle interarrival rate. I think this means arrivals average\n            # every 200 minutes.\n            sampled_inter = random.expovariate(0.025 / g.patient_inter_day)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u23f2\ufe0f Next patient arriving in {sampled_inter:.1f} minutes\",\n                config=g.trace_config,\n                identifier=p.id,\n            )\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time has elapsed.\n            yield self.env.timeout(sampled_inter)\n\n        else:\n            yield self.env.timeout(1)\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.generator_patient_arrivals_ooh","title":"<code>generator_patient_arrivals_ooh()</code>","text":"<p>A SimPy process generator that handles out-of-hours (OOH) patient arrivals.</p> <p>This function runs as a continuous loop, monitoring the simulation time to identify the \"night\" window (960 to 1440 minutes in a 24-hour cycle). When active, it instantiates patients and schedules their journey through the clinical pathway.</p> <p>If out-of-hours, it:</p> <ol> <li> <p>Updates global arrival flags.</p> </li> <li> <p>Instantiates a new Patient object.</p> </li> <li> <p>Records trace information.</p> </li> <li> <p>Triggers the <code>stroke_assessment</code> process for the patient.</p> </li> <li> <p>Samples an inter-arrival time and yields a timeout.</p> </li> </ol> <p>If in-hours, it yields a small timeout before checking again.</p> <p>Arrival rates are determined by <code>random.expovariate</code> using the <code>g.patient_inter_night</code> parameter. NOTE that this does not use the <code>g.patient_inter_night</code> parameter directly, and instead uses it alongside a rate modifier - careful inspection of the code to understand the impacts of changing <code>g.patient_inter_night</code> is recommended, and this may be adjusted in a future version of the model.</p> <p>Patients generated here have their <code>arrived_ooh</code> attribute set to True.</p> <p>This process triggers the <code>stroke_assessment</code> process for every newly created patient.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def generator_patient_arrivals_ooh(self):\n    \"\"\"\n    A SimPy process generator that handles out-of-hours (OOH) patient arrivals.\n\n    This function runs as a continuous loop, monitoring the simulation time\n    to identify the \"night\" window (960 to 1440 minutes in a 24-hour cycle).\n    When active, it instantiates patients and schedules their journey\n    through the clinical pathway.\n\n    If out-of-hours, it:\n\n    1. Updates global arrival flags.\n\n    2. Instantiates a new Patient object.\n\n    3. Records trace information.\n\n    4. Triggers the `stroke_assessment` process for the patient.\n\n    5. Samples an inter-arrival time and yields a timeout.\n\n    If in-hours, it yields a small timeout before checking again.\n\n    Arrival rates are determined by `random.expovariate` using the\n    `g.patient_inter_night` parameter. NOTE that this does not use the\n    `g.patient_inter_night` parameter directly, and instead uses it alongside\n    a rate modifier - careful inspection of the code to understand the impacts\n    of changing `g.patient_inter_night` is recommended, and this may be adjusted\n    in a future version of the model.\n\n    Patients generated here have their `arrived_ooh` attribute set to True.\n\n    This process triggers the `stroke_assessment` process for every\n    newly created patient.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n\n    \"\"\"\n    while True:\n        # if 960 &lt;= self.env.now % 1440 &lt; 1440:\n        time_of_day = self.env.now % 1440\n        if self.is_out_of_hours(time_of_day):\n            # Change the Global Class variable for the generator to TRUE\n            g.patient_arrival_gen_1 = False\n            g.patient_arrival_gen_2 = True\n\n            # Increment the patient counter by 1 for each new patient\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above. patient counter ID passed from above to patient\n            # class.\n            p = Patient(self.patient_counter)\n            self.patient_objects.append(p)\n\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udf19 OUT OF HOURS Patient {p.id} generated at {minutes_to_ampm(int(self.env.now % 1440))}. Diagnosis: {p.diagnosis}. MRS type: {p.mrs_type}.\",\n                identifier=p.id,\n                config=g.trace_config,\n            )\n\n            p.arrived_ooh = True\n            if self.env.now &lt; g.warm_up_period:\n                p.generated_during_warm_up = True\n\n            # Tell SimPy to start the stroke assessment function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.stroke_assessment(p))\n\n            # TODO: SR query: explore whether this is the most intuitive/easily managed way to\n            # handle interarrival rate. I think this means arrivals average\n            # every 666.6 minutes.\n            sampled_inter = random.expovariate(0.0075 / g.patient_inter_night)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\u23f2\ufe0f Next OOH patient arriving in {sampled_inter:.1f} minutes\",\n                identifier=p.id,\n                config=g.trace_config,\n            )\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time has elapsed.\n            yield self.env.timeout(sampled_inter)\n\n        else:\n            yield self.env.timeout(1)\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.obstruct_ctp","title":"<code>obstruct_ctp()</code>","text":"<p>Simulates periodic CTP scanner unavailability (off time).</p> <p>This process acts as a \"blocker\" by requesting the CTP scanner resource with a priority of -1. Since patients typically have a priority of 1, this process effectively preempts the queue, preventing patients from using the scanners during this period.</p> <p>The scanner will not stop a scan that is already in progress; it waits for the current user to finish before taking the resource offline.</p> <p>Frequencies and durations are governed by <code>g.ctp_unav_freq</code> and <code>g.ctp_unav_time</code>.</p> <p>Yields:</p> Type Description <code>Timeout</code> <p>Initial offset for opening hours and subsequent intervals between downtime events.</p> <code>ResourceRequest</code> <p>A high-priority request to seize the CTP scanner and take it \"offline.\"</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def obstruct_ctp(self):\n    \"\"\"\n    Simulates periodic CTP scanner unavailability (off time).\n\n    This process acts as a \"blocker\" by requesting the CTP scanner resource\n    with a priority of -1. Since patients typically have a priority of 1,\n    this process effectively preempts the queue, preventing patients from\n    using the scanners during this period.\n\n    The scanner will not stop a scan that is already in progress;\n    it waits for the current user to finish before taking the\n    resource offline.\n\n    Frequencies and durations are governed by `g.ctp_unav_freq`\n    and `g.ctp_unav_time`.\n\n    Yields\n    ------\n    simpy.events.Timeout\n        Initial offset for opening hours and subsequent intervals\n        between downtime events.\n    simpy.events.ResourceRequest\n        A high-priority request to seize the CTP scanner and take\n        it \"offline.\"\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n\n    \"\"\"\n    # TODO SR: Confirm this is ok with John\n    # SR: Add initial offset\n    # SR: Patient generators have also been updated\n    # to match with how this is working\n    yield self.env.timeout(g.ctp_opening_hour * 60)\n\n    while True:\n        yield self.env.timeout(g.ctp_unav_freq)\n        # Once elapsed, this generator requests the ctp scanner with\n        # a priority of -1. As the patient priority is set at 1\n        # the scanner will take priority over any patients waiting.\n        # This method also means that the scanner won't stop mid scan.\n        g.ctp_unav = True\n        with self.ctp_scanner.request(priority=-1) as req:\n            yield req\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udd2c CTP scanner OFFLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n            # Freeze with the scanners held in place for the unavailability\n            # time, in the model this means patients admitted in this time\n            # will not have a ctp scan.\n            # freq and unav times are set in the g class\n            yield self.env.timeout(g.ctp_unav_time)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udd2c CTP scanner back ONLINE at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n            g.ctp_unav = False\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.obstruct_sdec","title":"<code>obstruct_sdec()</code>","text":"<p>Simulates the scheduled closure or unavailability of the SDEC unit.</p> <p>Similar to the CTP obstruction, this process seizes an SDEC bed at a high priority (-1) for a defined duration. This models the real-world scenario where the SDEC unit closes at night or during specific hours, forcing patients to bypass this pathway.</p> <p>If a closure occurs after the simulation warm-up period, the <code>sdec_freeze_counter</code> is incremented.</p> <p>Patients arriving while the SDEC is \"obstructed\" will be unable to access SDEC resources.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def obstruct_sdec(self):\n    \"\"\"\n    Simulates the scheduled closure or unavailability of the SDEC unit.\n\n    Similar to the CTP obstruction, this process seizes an SDEC bed\n    at a high priority (-1) for a defined duration. This models the\n    real-world scenario where the SDEC unit closes at night or\n    during specific hours, forcing patients to bypass this pathway.\n\n    If a closure occurs after the simulation warm-up period, the\n    `sdec_freeze_counter` is incremented.\n\n    Patients arriving while the SDEC is \"obstructed\" will be\n    unable to access SDEC resources.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # TODO SR: Confirm this is ok with John\n    #  SR: Add initial offset\n    # SR: Patient generators have also been updated\n    # to match with how this is working\n    yield self.env.timeout(g.sdec_opening_hour * 60)\n\n    while True:\n        yield self.env.timeout(g.sdec_unav_freq)\n        # Once elapsed, this generator requests the SDEC with\n        # a priority of -1. As the patient priority is set at 1\n        # the SDEC will take priority over any patients waiting.\n        g.sdec_unav = True\n        with self.sdec_bed.request(priority=-1) as req:\n            yield req\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udfe5 SDEC CLOSES at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n\n            # Freeze with the SDEC held in place for the unavailability\n            # time, in the model this means patients admitted in this time\n            # will not have passed through the SDEC.\n            # freq and unav times are set in the g class\n            yield self.env.timeout(g.sdec_unav_time)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83c\udfe5 SDEC OPENS at {minutes_to_ampm(int(self.env.now % 1440))}\",\n                identifier=self.patient_counter,\n                config=g.trace_config,\n            )\n            g.sdec_unav = False\n            if self.env.now &gt; g.warm_up_period:\n                self.sdec_freeze_counter += 1\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.plot_stroke_run_graphs","title":"<code>plot_stroke_run_graphs(plot=True)</code>","text":"<p>Generate and display time-series visualizations for the simulation run.</p> <p>This method creates a line plot of the Stroke Ward occupancy over the duration of the simulation. It includes both the raw occupancy data and a linear trend line to help identify long-term capacity issues. Execution is dependent on the global <code>g.gen_graph</code> toggle.</p> <ul> <li>Data Cleaning: Automatically drops the first row (index 0) of   <code>occupancy_graph_df</code>, which is typically used as a placeholder.</li> <li>Trend Analysis: Uses a first-order polynomial fit (<code>numpy.polyfit</code>)   to calculate and display a linear trend line over the occupancy data.</li> <li>Extensibility: Contains placeholder (commented-out) logic for   an additional \"Nurse Assessment Queue\" graph.</li> <li>Dependencies: Requires <code>matplotlib.pyplot</code> as <code>plt</code> and   <code>numpy</code> as <code>np</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>plot</code> <code>bool</code> <p>If True, the generated figure is displayed immediately using <code>plt.show()</code>. If False, the figure object is returned to the caller for further processing (e.g., aggregation in a Trial report).</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure or None</code> <p>Returns a Matplotlib Figure object if <code>plot</code> is False. Returns None if <code>plot</code> is True or if <code>g.gen_graph</code> is False.</p> See Also <p>Trial.run_trial : The method that may collect these figures for batch reporting.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def plot_stroke_run_graphs(self, plot=True):\n    \"\"\"\n    Generate and display time-series visualizations for the simulation run.\n\n    This method creates a line plot of the Stroke Ward occupancy over the\n    duration of the simulation. It includes both the raw occupancy data\n    and a linear trend line to help identify long-term capacity issues.\n    Execution is dependent on the global `g.gen_graph` toggle.\n\n    - **Data Cleaning**: Automatically drops the first row (index 0) of\n      `occupancy_graph_df`, which is typically used as a placeholder.\n    - **Trend Analysis**: Uses a first-order polynomial fit (`numpy.polyfit`)\n      to calculate and display a linear trend line over the occupancy data.\n    - **Extensibility**: Contains placeholder (commented-out) logic for\n      an additional \"Nurse Assessment Queue\" graph.\n    - **Dependencies**: Requires `matplotlib.pyplot` as `plt` and\n      `numpy` as `np`.\n\n    Parameters\n    ----------\n    plot : bool, default True\n        If True, the generated figure is displayed immediately using\n        `plt.show()`. If False, the figure object is returned to the\n        caller for further processing (e.g., aggregation in a Trial report).\n\n    Returns\n    -------\n    matplotlib.figure.Figure or None\n        Returns a Matplotlib Figure object if `plot` is False.\n        Returns None if `plot` is True or if `g.gen_graph` is False.\n\n\n    See Also\n    --------\n    Trial.run_trial : The method that may collect these figures for batch reporting.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    if g.gen_graph == True:\n        # Queue for Nurse Assessment Graph (Currently Commented Out)\n\n        # self.nurse_q_graph_df.drop([0], inplace=True)\n\n        # fig, ax = plt.subplots()\n\n        # ax.set_xlabel(\"Time\")\n        # ax.set_ylabel(\"Number of patients in Q for Assessment\")\n        # ax.set_title(f\"Number of Patients in Nurse Assessment Queue \\\n        # Over Time \"f\"{self.run_number}\")\n\n        # ax.plot(self.nurse_q_graph_df[\"Time\"],\n        # self.nurse_q_graph_df[\"Patients in Assessment Queue\"],\n        # color=\"m\",\n        # linestyle=\"-\",\n        # label=\"Q for Stroke Nurse Assessment\")\n\n        # ax.legend(loc=\"upper right\")\n\n        # fig.show()\n\n        # Ward Occupancy Graph\n\n        self.occupancy_graph_df.drop([0], inplace=True)\n\n        fig, ax = plt.subplots()\n\n        ax.set_xlabel(\"Time\")\n        ax.set_ylabel(\"Stroke Ward Occupancy\")\n        ax.set_title(\n            f\"Trial \"\n            f\"{g.trials_run_counter}\\\n                     Ward Occupancy Over Time \"\n            f\"{self.run_number}\"\n        )\n\n        ax.plot(\n            self.occupancy_graph_df[\"Time\"],\n            self.occupancy_graph_df[\"Ward Occupancy\"],\n            color=\"b\",\n            linestyle=\"-\",\n            label=\"Ward Occupancy\",\n        )\n\n        # Add trend line\n        x = self.occupancy_graph_df[\"Time\"]\n        y = self.occupancy_graph_df[\"Ward Occupancy\"]\n        z = np.polyfit(x, y, 1)  # 1 = linear fit\n        p = np.poly1d(z)\n        ax.plot(x, p(x), color=\"b\", linestyle=\"--\", label=\"Trend Line\")\n\n        ax.legend(loc=\"upper right\")\n\n        if plot:\n            fig.show()\n        else:\n            return fig\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.run","title":"<code>run()</code>","text":"<p>Execute the simulation run lifecycle.</p> <p>This method initializes the simulation by registering background processes, executes the SimPy event loop for a specified duration, and performs post-simulation data processing and export tasks.</p> <p>The execution sequence is as follows: 1. Register time-tracking, patient arrival, and resource obstruction    generators as SimPy processes. 2. Execute the simulation engine until the combined limit of the    warm-up period and active simulation duration is reached. 3. Trigger final calculation of run-level results. 4. (Optional) Export patient-level results to a CSV file.</p> <ul> <li>Warm-up Period: The total runtime includes <code>g.warm_up_period</code>. This   is crucial for allowing the model to reach a 'steady state' before   results are recorded as valid.</li> <li>Concurrency: All methods passed to <code>self.env.process()</code> run   pseudo-parallelly, managed by the SimPy event scheduler.</li> <li>Post-Processing: This method must be called for <code>results_df</code>   and other KPIs to be populated with final values.</li> </ul> See Also <p>track_days : The background process that logs day transitions.</p> <p>generator_patient_arrivals: generates in-hours patients and sends them through the     assessment pathway</p> <p>generator_patient_arrivals_ooh: generates out-of-hours patients and sends them through the     assessment pathway</p> <p>obstruct_ctp: ensures the ctp scanner is only available for the specified times</p> <p>obstruct_sdec: ensures the sdec is only available for the specified times</p> <p>calculate_run_results : The method called to process data after the     event loop finishes.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def run(self):\n    \"\"\"\n    Execute the simulation run lifecycle.\n\n    This method initializes the simulation by registering background\n    processes, executes the SimPy event loop for a specified duration,\n    and performs post-simulation data processing and export tasks.\n\n    The execution sequence is as follows:\n    1. Register time-tracking, patient arrival, and resource obstruction\n       generators as SimPy processes.\n    2. Execute the simulation engine until the combined limit of the\n       warm-up period and active simulation duration is reached.\n    3. Trigger final calculation of run-level results.\n    4. (Optional) Export patient-level results to a CSV file.\n\n    - **Warm-up Period**: The total runtime includes `g.warm_up_period`. This\n      is crucial for allowing the model to reach a 'steady state' before\n      results are recorded as valid.\n    - **Concurrency**: All methods passed to `self.env.process()` run\n      pseudo-parallelly, managed by the SimPy event scheduler.\n    - **Post-Processing**: This method must be called for `results_df`\n      and other KPIs to be populated with final values.\n\n    See Also\n    --------\n    track_days : The background process that logs day transitions.\n\n    generator_patient_arrivals: generates in-hours patients and sends them through the\n        assessment pathway\n\n    generator_patient_arrivals_ooh: generates out-of-hours patients and sends them through the\n        assessment pathway\n\n    obstruct_ctp: ensures the ctp scanner is only available for the specified times\n\n    obstruct_sdec: ensures the sdec is only available for the specified times\n\n    calculate_run_results : The method called to process data after the\n        event loop finishes.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # starts up the generators in the model, of which there are three.\n\n    self.env.process(self.track_days())\n    self.env.process(self.generator_patient_arrivals())\n    self.env.process(self.generator_patient_arrivals_ooh())\n    self.env.process(self.obstruct_ctp())\n    self.env.process(self.obstruct_sdec())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=(g.sim_duration + g.warm_up_period))\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n    # Print the run number with the patient-level results from this run of\n    # the model, this is commented out at the moment.\n\n    # print (f\"Run Number {self.run_number}\")\n    # print (self.results_df)\n\n    if g.write_to_csv == True:\n        self.results_df.to_csv(\n            f\"trial {g.trials_run_counter} output {self.run_number}.csv\",\n            index=False,\n        )\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.stroke_assessment","title":"<code>stroke_assessment(patient)</code>","text":"<p>Simulates the full assessment and treatment pathway for patients in a stroke pathway.</p> <p>Parameters:</p> Name Type Description Default <code>patient</code> <code>Instance of class `Patient`</code> <p>One single unique patient object.</p> required Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def stroke_assessment(self, patient):\n    \"\"\"\n    Simulates the full assessment and treatment pathway for patients\n    in a stroke pathway.\n\n    Parameters\n    ----------\n    patient : Instance of class `Patient`\n        One single unique patient object.\n    \"\"\"\n    # This code introduces a slight element of randomness into the patient's\n    # diagnosis.\n\n    self.ich_range = random.normalvariate(g.ich, 1)\n    self.i_range = max(random.normalvariate(g.i, 1), self.ich_range)\n    self.tia_range = max(random.normalvariate(g.tia, 1), self.i_range)\n    self.stroke_mimic_range = max(\n        random.normalvariate(g.stroke_mimic, 1), self.tia_range\n    )\n    self.non_stroke_range = max(\n        random.normalvariate(g.stroke_mimic, 1), self.stroke_mimic_range\n    )\n\n    if patient.diagnosis &lt;= self.ich_range:\n        patient.patient_diagnosis = 0\n    elif patient.diagnosis &lt;= self.i_range:\n        patient.patient_diagnosis = 1\n    elif patient.diagnosis &lt;= self.tia_range:\n        patient.patient_diagnosis = 2\n    elif patient.diagnosis &lt;= self.stroke_mimic_range:\n        patient.patient_diagnosis = 3\n    elif patient.diagnosis &gt; self.non_stroke_range:\n        patient.patient_diagnosis = 4\n    # TODO: SR have added this else clause but need to confirm this is correct\n    # TODO: SR patients were occasionally not getting allocated a diagnosis and\n    # TODO: SR this would then cause issues with generating LOS etc\n    else:\n        patient.patient_diagnosis = 4\n\n    trace(\n        time=self.env.now,\n        debug=g.show_trace,\n        msg=f\"Patient {patient.id} Patient Diagnosis (category 1-4): {patient.patient_diagnosis}.\",\n        identifier=patient.id,\n        config=g.trace_config,\n    )\n\n    # Record the time the patient started queuing for a nurse\n    start_q_nurse = self.env.now\n\n    self.q_for_assessment.append(patient)\n\n    # Add the arrival time to the main DF, this is mainly to test if the\n    # patinet arrival times mirror the real world data\n\n    patient.clock_start = self.env.now\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Arrival Time\"] = patient.clock_start\n\n        self.results_df.at[patient.id, \"Patient Gen 1 Status\"] = (\n            g.patient_arrival_gen_1\n        )\n\n        self.results_df.at[patient.id, \"Patient Gen 2 Status\"] = (\n            g.patient_arrival_gen_2\n        )\n\n    # This code says request a nurse resource, and do all of the following\n    # block of code with that nurse resource held in place (and therefore\n    # not usable by another patient)\n    with self.nurse.request() as req:\n        # Freeze the function until the request for a nurse can be met.\n        # The patient is currently queuing.\n        yield req\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\udc69\u200d\u2695\ufe0f Patient {patient.id} is being seen by a nurse at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        # Control is passed back to the generator function once the request\n        # is met for a nurse. As the queue for the nurse is finished\n        # the patient then leaves the assessment queue list.\n\n        end_q_nurse = self.env.now\n\n        self.q_for_assessment.remove(patient)\n\n        # The code below checks if the warm up period has passed before\n        # entering data into the df, this code exists when ever data is\n        # recorded\n\n        if self.env.now &gt; g.warm_up_period:\n            self.nurse_q_graph_df.loc[len(self.nurse_q_graph_df)] = [\n                self.env.now,\n                len(self.q_for_assessment),\n            ]\n\n        # Calculate the time this patient was queuing for the nurse, and\n        # record it in the patient's attribute\n        patient.q_time_nurse = end_q_nurse - start_q_nurse\n\n        # The below code creates a random action time for the nurse based\n        # on the mean in g class, and assigns it ot a variable. Currently\n        # using a Exponential distribution but might need to switch to\n        # a Log normal one (though the intense variation in the real life\n        # consult time might mean a exponetial distribution is better)\n        sampled_nurse_act_time = random.expovariate(1.0 / g.mean_n_consult_time)\n\n        # Freeze this function in place for the activity time we sampled\n        # above.  This is the patient spending time with the nurse.\n        yield self.env.timeout(sampled_nurse_act_time)\n\n        # In the .at function below, the first value is the row, the second\n        # value is the column in which to add data. The final value is the\n        # the data that is to be added to the DF, in this case the Nurse\n        # Q time\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Q Time Nurse\"] = patient.q_time_nurse\n            self.results_df.at[patient.id, \"Time with Nurse\"] = (\n                sampled_nurse_act_time\n            )\n\n    # MARK: CT Perfusion Scanner Use\n    # The if formula below checks to see if the CTP scanner is active\n    # and if it is the following code is followed including updating the\n    # patient advanced CT pathway attribute\n\n    if g.ctp_unav == False:\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\u27a1\ufe0f Patient {patient.id} sent on CTP scanner pathway at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        patient.advanced_ct_pathway = True\n\n        # Randomly sample the mean ct time, as with above this may need to\n        # be updated to a log normal distribution\n\n        sampled_ctp_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n        patient.ctp_duration = sampled_ctp_act_time\n        # Freeze this function in place for the activity time that was\n        # sampled above.\n        yield self.env.timeout(sampled_ctp_act_time)\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\u27a1\ufe0f Patient {patient.id} finishes CTP scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ctp_act_time:.1f} minutes.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        # Add data to the DF afer the warm up period.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Time with CTP\"] = sampled_ctp_act_time\n\n    # If the CTP pathway is not active the below code runs, it is the same\n    # as the above however adds data to a different column and the patient\n    # advanced CT pathway remains False.\n\n    else:\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\udeab Patient {patient.id} NOT sent on CTP scanner pathway - normal CT scan commencing at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        # TODO: SR: Confirm if ct act time should still pass in this instance\n        # TODO: SR: Is a standard CT scan performed when CT perfusion scanner not available?\n        sampled_ct_act_time = random.expovariate(1.0 / g.mean_n_ct_time)\n        patient.ct_duration = sampled_ct_act_time\n\n        yield self.env.timeout(sampled_ct_act_time)\n\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\udeab Patient {patient.id} finishes normal CT scan at {minutes_to_ampm(int(self.env.now % 1440))} after {sampled_ct_act_time:.1f} minutes.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Time with CT\"] = sampled_ct_act_time\n\n    # The below code records the status of both the CTP pathway.\n    # Both exist as generators and this data is record to ensure they are\n    # operating as expected.\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"CTP Status\"] = g.ctp_unav\n\n    # The below code checks the patient's attributes to see if the\n    # thrombolysis attribute should be changed to True, this is based off\n    # the patient diagnosis, onset type and mrs type. There are different\n    # conditions depending on if CTP is available or not.\n\n    if (\n        patient.patient_diagnosis == 1\n        and patient.onset_type == 0\n        and patient.mrs_type &gt; 0\n    ):\n        patient.thrombolysis = True\n\n    if (\n        patient.patient_diagnosis == 1\n        and patient.onset_type == 1\n        and patient.advanced_ct_pathway == True\n        and patient.mrs_type &gt; 0\n    ):\n        patient.thrombolysis = True\n\n    # Thrombolysis status is added to the DF, this is mainly used to check\n    # if it is being applied correctly.\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Thrombolysis\"] = patient.thrombolysis\n\n    # The below code records the status of both the SDEC pathway.\n    # Both exist as generators and this data is recorded to ensure they are\n    # operating as expected.\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"SDEC Status\"] = g.sdec_unav\n\n    # MARK: SDEC Admission\n    # The if statement below checks if the SDEC pathway is active at this\n    # given time and if there is space in the SDEC itself.\n\n    if g.sdec_unav == False and len(self.sdec_occupancy) &lt;= g.sdec_beds:\n        # If the conditions above are met the patient attribute for the SDEC\n        # are changed to True and the patient is added to the SDEC occupancy\n        # list.\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\udecf\ufe0f\ud83c\udfce\ufe0f Patient {patient.id} admitted to SDEC (occupancy before admission: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds) at {minutes_to_ampm(int(self.env.now % 1440))}.\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n        self.sdec_occupancy.append(patient)\n\n        # The below code record the SDEC Occupancy as the patient passes\n        # this point to ensure it is working as expected.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"SDEC Occupancy\"] = len(\n                self.sdec_occupancy\n            )\n\n        patient.sdec_pathway = True\n\n        # This code checks if the patient is eligible for admission\n        # avoidance depending on if therapy support is enabled.\n\n        if g.therapy_sdec == False:\n            if (\n                patient.patient_diagnosis &lt; 2\n                and patient.mrs_type &lt; 2\n                and patient.thrombolysis == False\n            ):\n                patient.admission_avoidance = True\n\n        elif g.therapy_sdec == True:\n            if (\n                patient.patient_diagnosis &lt; 2\n                and patient.mrs_type &lt;= 3\n                and patient.thrombolysis == False\n            ):\n                patient.admission_avoidance = True\n\n        # This code applies a non stroke admission avoidance variable to the\n        # patient.\n\n        self.tia_admission_chance = random.normalvariate(g.tia_admission, 1)\n        self.stroke_mimic_admission_chance = random.normalvariate(\n            g.stroke_mimic_admission, 1\n        )\n\n        if (\n            patient.non_admission &gt;= self.tia_admission_chance\n            and patient.patient_diagnosis == 2\n        ):\n            patient.admission_avoidance = True\n\n        elif (\n            patient.non_admission &gt;= self.stroke_mimic_admission_chance\n            and patient.patient_diagnosis &gt; 2\n        ):\n            patient.admission_avoidance = True\n\n        # Calculate SDEC stay time from exponential\n        sampled_sdec_stay_time = random.expovariate(1.0 / g.mean_n_sdec_time)\n\n        # Add patient SDEC LOS to their patient object\n        patient.sdec_los = sampled_sdec_stay_time\n        # Freeze this function in place for the activity time we sampled\n        # above.\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in SDEC for {sampled_sdec_stay_time:.1f} minutes ({(sampled_sdec_stay_time / 60 / 24):.1f} days).\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n        yield self.env.timeout(sampled_sdec_stay_time)\n\n        # This code checks if the ward is full, if this is the case the\n        # patient will not be released from the SDEC, thus impeding it use\n\n        if patient.admission_avoidance != True:\n            while len(self.ward_occupancy) &gt;= g.number_of_ward_beds:\n                yield self.env.timeout(1)\n\n        # Once the above code is complete the patient is removed from the\n        # SDEC occupancy list.\n\n        self.sdec_occupancy.remove(patient)\n\n        # Code to record the SDEC stay time in the results DataFrame.\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Time in SDEC\"] = sampled_sdec_stay_time\n\n        # MARK: Discharged from SDEC\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83c\udfce\ufe0f Patient {patient.id} discharged from SDEC at {minutes_to_ampm(int(self.env.now % 1440))} after {patient.sdec_los:.1f} minutes ({(patient.sdec_los / 60 / 24):.1f} days). Occupancy after discharge: {len(self.sdec_occupancy)} of {g.sdec_beds} SDEC beds\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n\n    # The below code records the patients diagnosis attribute, this is added\n    # to the DF to check the diagnosis code is working correctly.\n\n    if patient.patient_diagnosis == 0 and self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Diagnosis Type\"] = \"ICH\"\n        patient.patient_diagnosis_type = \"ICH\"\n    elif patient.patient_diagnosis == 1 and self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Diagnosis Type\"] = \"I\"\n        patient.patient_diagnosis_type = \"I\"\n    elif patient.patient_diagnosis == 2 and self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Diagnosis Type\"] = \"TIA\"\n        patient.patient_diagnosis_type = \"TIA\"\n    elif patient.patient_diagnosis == 3 and self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Diagnosis Type\"] = \"Stroke Mimic\"\n        patient.patient_diagnosis_type = \"Stroke Mimic\"\n    elif patient.patient_diagnosis == 4 and self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Diagnosis Type\"] = \"Non Stroke\"\n        patient.patient_diagnosis_type = \"Non Stroke\"\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"Onset Type\"] = patient.onset_type\n\n    # This code add information regarding the patients admission avoidance.\n\n    if patient.admission_avoidance == True and patient.patient_diagnosis &lt; 2:\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Admission Avoidance\"] = (\n                patient.sdec_pathway\n            )\n\n            last_index = self.results_df[\"SDEC Savings\"].last_valid_index()\n            last_value = self.results_df.loc[last_index, \"SDEC Savings\"]\n            if last_index &gt; 0 and pd.notnull:\n                self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                    last_value + g.inpatient_bed_cost\n                )\n\n            else:\n                self.results_df.at[patient.id, \"SDEC Savings\"] = (\n                    g.inpatient_bed_cost\n                )\n\n    # This code adds the Patient's MRS to the DF, this can be used to check\n    # all code that interacts with this runs correctly.\n\n    if self.env.now &gt; g.warm_up_period:\n        self.results_df.at[patient.id, \"MRS Type\"] = patient.mrs_type\n\n    # Patients with a True admission avoidance are added to a list that is\n    # used to calculate the savings from the avoided admissions.\n\n    if (\n        patient.admission_avoidance == True\n        and patient.patient_diagnosis &lt; 2\n        and self.env.now &gt; g.warm_up_period\n    ):\n        self.admission_avoidance.append(patient)\n\n    # This code introduces a small element of randomness into the admission\n    # rates for the non stroke, tia and stroke mimic patients.\n\n    self.tia_admission_chance = random.normalvariate(g.tia_admission, 1)\n    self.stroke_mimic_admission_chance = random.normalvariate(\n        g.stroke_mimic_admission, 1\n    )\n\n    # This code exists after the admission avoidance code so they are not\n    # added to the admission avoidance list, as that should only be for\n    # SDEC patients who avoid admission. This code checks if TIA, non stroke\n    # and stroke mimic patients should be admitted based on the values\n    # established in the previous code and g class.\n\n    if (\n        patient.non_admission &gt;= self.tia_admission_chance\n        and patient.patient_diagnosis == 2\n    ):\n        patient.admission_avoidance = True\n\n    elif (\n        patient.non_admission &gt;= self.stroke_mimic_admission_chance\n        and patient.patient_diagnosis &gt; 2\n    ):\n        patient.admission_avoidance = True\n\n    # MARK: Ward Admission\n    # once all the above code has been run all patients who will not admit\n    # have a True admission avoidance attribute. For all the patients that\n    # remain false, the below code will run simulating the admission to the\n    # ward.\n\n    if patient.admission_avoidance != True:\n        # These code assigns a time to the start q variable. In stroke care\n        # delays can have serious consequence so modeling this is very\n        # important as flow disruption are a common issue.\n\n        start_q_ward = self.env.now\n\n        # Request the ward bed and hold the patient in a queue until this\n        # is met.\n\n        with self.ward_bed.request() as req:\n            yield req\n            # Add patient to the ward list\n\n            self.ward_occupancy.append(patient)\n            trace(\n                time=self.env.now,\n                debug=g.show_trace,\n                msg=f\"\ud83d\udecf\ufe0f Patient {patient.id} admitted to main ward at {minutes_to_ampm(int(self.env.now % 1440))}. Occupancy after admission: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n                identifier=patient.id,\n                config=g.trace_config,\n            )\n\n            if self.env.now &gt; g.warm_up_period:\n                self.results_df.at[patient.id, \"Ward Occupancy\"] = len(\n                    self.ward_occupancy\n                )\n\n            if self.env.now &gt; g.warm_up_period:\n                self.occupancy_graph_df.loc[len(self.occupancy_graph_df)] = [\n                    self.env.now,\n                    len(self.ward_occupancy),\n                ]\n\n            # The patient attribute for the queuing time in the ward is\n            # assigned here.\n\n            end_q_ward = self.env.now\n\n            patient.q_time_ward = end_q_ward - start_q_ward\n\n            # The below code checks the patients diagnosis and MRS,\n            # adjusting MRS change and LOS baised on these. This code is\n            # for ICH patients.\n\n            ###############################\n            # MARK: Patient diagnosis = 0 #\n            # Intracerebral haemorrhage   #\n            # Unsuitable for thrombolysis #\n            ###############################\n\n            if patient.patient_diagnosis == 0 and patient.mrs_type == 0:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_ich_ward_time_mrs_0\n                )\n                patient.mrs_discharge = patient.mrs_type\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 1:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_ich_ward_time_mrs_1\n                )\n                patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 2:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_ich_ward_time_mrs_2\n                )\n                patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 3:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_ich_ward_time_mrs_3\n                )\n                patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 4:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_ich_ward_time_mrs_4\n                )\n                patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 0 and patient.mrs_type == 5:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_ich_ward_time_mrs_5\n                )\n                patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            ###############################\n            # MARK: Patient diagnosis = 1 #\n            # Ischaemic Stroke            #\n            # Some may be suitable for    #\n            # thrombolysis                #\n            ###############################\n\n            # The below code checks the patients diagnosis and MRS,\n            # adjusting MRS change and LOS baised on these. This code is\n            # for I patients amd also checks for thrombolysis and adjusts\n            # LOS and associated savings accordingly.\n\n            if patient.patient_diagnosis == 1 and patient.mrs_type == 0:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_i_ward_time_mrs_0\n                )\n                patient.mrs_discharge = patient.mrs_type\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 1:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_i_ward_time_mrs_1\n                )\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    self.ward_occupancy.remove(patient)\n                else:\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 2:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_i_ward_time_mrs_2\n                )\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    self.ward_occupancy.remove(patient)\n                else:\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 3:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_i_ward_time_mrs_3\n                )\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    self.ward_occupancy.remove(patient)\n                else:\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 4:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_i_ward_time_mrs_4\n                )\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    self.ward_occupancy.remove(patient)\n                else:\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n            elif patient.patient_diagnosis == 1 and patient.mrs_type == 5:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_i_ward_time_mrs_5\n                )\n                if patient.thrombolysis == True:\n                    sampled_ward_act_time_thrombolysis = (\n                        sampled_ward_act_time * g.thrombolysis_los_save\n                    )\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 2)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"\ud83d\udc89 Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) THROMBOLYSED. Will be in ward for {sampled_ward_act_time_thrombolysis:.1f} minutes ({(sampled_ward_act_time_thrombolysis / 24 / 60):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    # Record generated LOS in patient object\n                    patient.ward_los_thrombolysis = (\n                        sampled_ward_act_time_thrombolysis\n                    )\n                    yield self.env.timeout(sampled_ward_act_time_thrombolysis)\n                    if (\n                        self.env.now &gt; g.warm_up_period\n                        and patient.advanced_ct_pathway == True\n                    ):\n                        self.results_df.at[patient.id, \"Thrombolysis Savings\"] = (\n                            (\n                                (\n                                    sampled_ward_act_time\n                                    - sampled_ward_act_time_thrombolysis\n                                )\n                                / 60\n                            )\n                            / 24\n                        ) * g.inpatient_bed_cost_thrombolysis\n                    self.ward_occupancy.remove(patient)\n                else:\n                    patient.mrs_discharge = patient.mrs_type - random.randint(0, 1)\n                    trace(\n                        time=self.env.now,\n                        debug=g.show_trace,\n                        msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                        identifier=patient.id,\n                        config=g.trace_config,\n                    )\n                    # Record generated LOS in patient object\n                    patient.ward_los = sampled_ward_act_time\n                    yield self.env.timeout(sampled_ward_act_time)\n                    self.ward_occupancy.remove(patient)\n\n            #################################\n            # MARK: Patient diagnosis = 2   #\n            # Transient Ischaemic Attack    #\n            # Not suitable for thrombolysis #\n            #################################\n            # The below code is for the non stroke diagnosis.\n\n            if patient.patient_diagnosis == 2:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_tia_ward_time\n                )\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n                # Record generated LOS in patient object\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n            ###############################\n            # MARK: Patient diagnosis &gt; 2 #\n            # Stroke mimic OR non-stroke  #\n            ###############################\n            if patient.patient_diagnosis &gt; 2:\n                sampled_ward_act_time = random.expovariate(\n                    1.0 / g.mean_n_non_stroke_ward_time\n                )\n\n                trace(\n                    time=self.env.now,\n                    debug=g.show_trace,\n                    msg=f\"Patient {patient.id} (diagnosis {patient.diagnosis} ({patient.patient_diagnosis}), MRS type {patient.mrs_type}) will be in ward for {sampled_ward_act_time:.1f} minutes ({(sampled_ward_act_time / 60 / 24):.1f} days).\",\n                    identifier=patient.id,\n                    config=g.trace_config,\n                )\n\n                # Record generated LOS in patient object\n                patient.ward_los = sampled_ward_act_time\n                yield self.env.timeout(sampled_ward_act_time)\n                self.ward_occupancy.remove(patient)\n\n        # Relevent information is recorded in the results DataFrame.\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Q Time Ward\"] = patient.q_time_ward\n\n        # TODO: SR: Confirm this is expected\n        # SR: This triggered an error in a patient with a diagnosis of 1 and MRS of 0\n        # who didn't seem to have a ward stay\n        # TODO: SR: I've tweaked this to take whichever of the ward_los or thrombolysis los is generated\n        # TODO SR: It would be better to take a more robust approach to this step.\n        try:\n            final_ward_los = sampled_ward_act_time\n        except:\n            final_ward_los = sampled_ward_act_time_thrombolysis\n\n        if self.env.now &gt; g.warm_up_period:\n            self.results_df.at[patient.id, \"Ward LOS\"] = final_ward_los\n\n            self.results_df.at[patient.id, \"MRS DC\"] = patient.mrs_discharge\n\n            self.results_df.at[patient.id, \"MRS Change\"] = (\n                patient.mrs_type - patient.mrs_discharge\n            )\n\n        # MARK: Discharged from main ward\n        trace(\n            time=self.env.now,\n            debug=g.show_trace,\n            msg=f\"\ud83d\ude97 Patient {patient.id} discharged from main ward at {minutes_to_ampm(int(self.env.now % 1440))} after {final_ward_los:.1f} minutes ({(final_ward_los / 24 / 60):.1f} days). Occupancy after discharge: {len(self.ward_occupancy)} of {g.number_of_ward_beds} ward beds\",\n            identifier=patient.id,\n            config=g.trace_config,\n        )\n</code></pre>"},{"location":"model/#stroke_ward_model.stroke_admission_classes.Model.track_days","title":"<code>track_days()</code>","text":"<p>A SimPy process that logs the progression of simulation days.</p> <p>This generator functions as a background 'clock' process. It wakes up at the start of every 1440-minute interval (24 hours) to output a formatted debug message indicating the current day of the simulation run. This helps track progress in the console during long-running simulations.</p> <ul> <li>The day calculation is performed using floor division:   <code>self.env.now // 1440</code>.</li> <li>The trace message visibility depends on the <code>g.show_trace</code> flag and   the <code>g.tracked_cases</code> configuration.</li> <li>This process runs concurrently with patient arrivals and clinical   obstructions without interfering with their logic.</li> </ul> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def track_days(self):\n    \"\"\"\n    A SimPy process that logs the progression of simulation days.\n\n    This generator functions as a background 'clock' process. It wakes up\n    at the start of every 1440-minute interval (24 hours) to output a\n    formatted debug message indicating the current day of the simulation\n    run. This helps track progress in the console during long-running\n    simulations.\n\n    - The day calculation is performed using floor division:\n      `self.env.now // 1440`.\n    - The trace message visibility depends on the `g.show_trace` flag and\n      the `g.tracked_cases` configuration.\n    - This process runs concurrently with patient arrivals and clinical\n      obstructions without interfering with their logic.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # Print a debugging message every day\n    while self.env.now &lt;= g.sim_duration:\n        # TODO: this doesn't always reliably appear depending on number of tracked cases\n        trace(\n            msg=f\"========= DAY {(self.env.now // 1440):.0f} ===============\",\n            time=self.env.now,\n            debug=g.show_trace,\n            identifier=max(g.tracked_cases),\n            config=g.trace_config,\n        )\n        yield self.env.timeout(1440)\n</code></pre>"},{"location":"patient/","title":"Reference","text":"<p>Representation of an individual patient within the simulation.</p> <p>A <code>Patient</code> object stores all clinical, pathway, and state-related attributes required for modelling flow through the stroke/TIA care process. Several characteristics (onset type, MRS score, diagnosis category, admission likelihood) are randomly generated on creation using parameters defined in the global configuration class <code>g</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p_id</code> <code>int or str</code> <p>Unique identifier for the patient.</p> required <p>Attributes:</p> Name Type Description <code>id</code> <code>int or str</code> <p>Patient identifier.</p> <code>q_time_nurse</code> <code>float</code> <p>Time spent waiting for nursing assessment or consultation.</p> <code>q_time_ward</code> <code>float</code> <p>Time spent waiting for an inpatient ward bed.</p> <code>onset_type</code> <code>int</code> <p>Categorisation of onset information: - 0 : Known onset - 1 : Unknown onset but within CTP window - 2 : Unknown onset and outside CTP window</p> <code>mrs_type</code> <code>int</code> <p>Modified Rankin Scale score at presentation (0\u20135). Drawn from an exponential distribution and capped at 5.</p> <code>mrs_discharge</code> <code>int</code> <p>Modified Rankin Scale score at discharge (set later by the model).</p> <code>diagnosis</code> <code>int</code> <p>Raw randomised diagnostic value (0\u2013100). Used to map to a clinical category based on thresholds defined in <code>g</code>.</p> <code>patient_diagnosis</code> <code>int</code> <p>Encoded diagnosis category: - 0 : Intracerebral haemorrhage (ICH) - 1 : Ischaemic stroke (I) - 2 : Transient ischaemic attack (TIA) - 3 : Stroke mimic - 4 : Non-stroke</p> <code>priority</code> <code>int</code> <p>Triage priority level (used for queue ordering).</p> <code>non_admission</code> <code>int</code> <p>Randomised admission likelihood score (0\u2013100).</p> <code>advanced_ct_pathway</code> <code>bool</code> <p>Whether the patient enters an advanced CT imaging pathway.</p> <code>sdec_pathway</code> <code>bool</code> <p>Whether the patient is routed through SDEC.</p> <code>thrombolysis</code> <code>bool</code> <p>Whether the patient receives thrombolysis.</p> <code>thrombectomy</code> <code>bool</code> <p>Whether the patient receives thrombectomy.</p> <code>admission_avoidance</code> <code>bool</code> <p>Whether the patient avoids an admission by being seen in SDEC instead.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of ChatGPT 5.1. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>class Patient:\n    \"\"\"\n    Representation of an individual patient within the simulation.\n\n    A `Patient` object stores all clinical, pathway, and state-related\n    attributes required for modelling flow through the stroke/TIA care\n    process. Several characteristics (onset type, MRS score, diagnosis\n    category, admission likelihood) are randomly generated on creation\n    using parameters defined in the global configuration class `g`.\n\n    Parameters\n    ----------\n    p_id : int or str\n        Unique identifier for the patient.\n\n    Attributes\n    ----------\n    id : int or str\n        Patient identifier.\n    q_time_nurse : float\n        Time spent waiting for nursing assessment or consultation.\n    q_time_ward : float\n        Time spent waiting for an inpatient ward bed.\n    onset_type : int\n        Categorisation of onset information:\n        - 0 : Known onset\n        - 1 : Unknown onset but within CTP window\n        - 2 : Unknown onset and outside CTP window\n    mrs_type : int\n        Modified Rankin Scale score at presentation (0\u20135).\n        Drawn from an exponential distribution and capped at 5.\n    mrs_discharge : int\n        Modified Rankin Scale score at discharge (set later by the model).\n    diagnosis : int\n        Raw randomised diagnostic value (0\u2013100). Used to map to a clinical\n        category based on thresholds defined in `g`.\n    patient_diagnosis : int\n        Encoded diagnosis category:\n        - 0 : Intracerebral haemorrhage (ICH)\n        - 1 : Ischaemic stroke (I)\n        - 2 : Transient ischaemic attack (TIA)\n        - 3 : Stroke mimic\n        - 4 : Non-stroke\n    priority : int\n        Triage priority level (used for queue ordering).\n    non_admission : int\n        Randomised admission likelihood score (0\u2013100).\n    advanced_ct_pathway : bool\n        Whether the patient enters an advanced CT imaging pathway.\n    sdec_pathway : bool\n        Whether the patient is routed through SDEC.\n    thrombolysis : bool\n        Whether the patient receives thrombolysis.\n    thrombectomy : bool\n        Whether the patient receives thrombectomy.\n    admission_avoidance : bool\n        Whether the patient avoids an admission by being seen in SDEC instead.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of ChatGPT 5.1.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    def __init__(self, p_id):\n        self.id = p_id\n        self.q_time_nurse = np.NaN  # SR NOTE - changed this to NaN by default\n        self.q_time_ward = np.NaN  # SR NOTE - changed this to NaN by default\n        # 0 = known onset, 1 = unknown onset (in ctp range), 2 = unknown (out of\n        # ctp range)\n        self.onset_type = random.randint(0, 2)\n        # Max MRS is set to 5\n        self.mrs_type = min(round(random.expovariate(1.0 / g.mean_mrs)), 5)\n        self.mrs_discharge = np.NaN  # SR NOTE - changed this to NaN by default\n        # &lt;=5 is ICH, &lt;=55 is I, &lt;= 70 is TIA, &lt;=85 is Stroke Mimic, &gt;85 is non\\\n        # stroke, this set in g class\n        self.diagnosis = random.randint(0, 100)\n        # 0 = ICH, 1 = I, 2 = TIA, 3 = Stroke Mimic, 4 = non stroke\n        self.patient_diagnosis = np.NaN  # SR NOTE - changed this to NaN by default\n        self.priority = 1\n        self.non_admission = random.randint(0, 100)\n        self.advanced_ct_pathway = False\n        self.sdec_pathway = False\n        self.thrombolysis = False\n        self.thrombectomy = False\n        self.admission_avoidance = False\n\n        # NOTE: Additional items added by SR\n        self.ward_los = np.NaN\n        self.ward_los_thrombolysis = np.NaN\n        self.sdec_los = np.NaN\n        self.ctp_duration = np.NaN\n        self.ct_duration = np.NaN\n        self.arrived_ooh = False\n        self.generated_during_warm_up = False\n        self.patient_diagnosis_type = None\n</code></pre>"},{"location":"trial/","title":"Reference","text":"<p>Orchestrator for running multiple simulation iterations (runs) and aggregating results.</p> <p>The Trial class manages the execution of multiple <code>Model</code> instances as defined in the global configuration. It collects performance metrics, financial data, and patient-level logs from each individual run into centralized DataFrames for cross-run analysis.</p> <p>Attributes:</p> Name Type Description <code>df_trial_results</code> <code>DataFrame</code> <p>A summary DataFrame where each row represents a single simulation run. Tracks metrics such as mean queue times, occupancy, and financial savings.</p> <code>graph_objects</code> <code>list</code> <p>Storage for visualization objects generated during each simulation run.</p> <code>model_objects</code> <code>list</code> <p>A collection of <code>Model</code> instances created during the trial, allowing for post-hoc inspection of specific run states.</p> <code>trial_patient_dataframes</code> <code>list</code> <p>A list of DataFrames, each containing detailed attribute data for every patient in a specific run.</p> <code>trial_patient_df</code> <code>DataFrame</code> <p>The master DataFrame created by concatenating all patient-level data across all runs in the trial.</p> <code>trial_info</code> <code>str</code> <p>A descriptive string containing the configuration settings used for the current trial (e.g., SDEC therapy status and resource availability).</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>class Trial:\n    \"\"\"\n    Orchestrator for running multiple simulation iterations (runs) and aggregating results.\n\n    The Trial class manages the execution of multiple `Model` instances as defined\n    in the global configuration. It collects performance metrics, financial data,\n    and patient-level logs from each individual run into centralized DataFrames\n    for cross-run analysis.\n\n    Attributes\n    ----------\n    df_trial_results : pd.DataFrame\n        A summary DataFrame where each row represents a single simulation run.\n        Tracks metrics such as mean queue times, occupancy, and financial savings.\n    graph_objects : list\n        Storage for visualization objects generated during each simulation run.\n    model_objects : list\n        A collection of `Model` instances created during the trial, allowing\n        for post-hoc inspection of specific run states.\n    trial_patient_dataframes : list\n        A list of DataFrames, each containing detailed attribute data for every\n        patient in a specific run.\n    trial_patient_df : pd.DataFrame\n        The master DataFrame created by concatenating all patient-level data\n        across all runs in the trial.\n    trial_info : str\n        A descriptive string containing the configuration settings used for\n        the current trial (e.g., SDEC therapy status and resource availability).\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run with run number as the index.\n\n    def __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Q Time Nurse (Mins)\"] = [0.0]\n        self.df_trial_results[\"Number of Admissions Avoided In Run\"] = [0.0]\n        self.df_trial_results[\"Mean Q Time Ward (Hour)\"] = [0.0]\n        self.df_trial_results[\"Mean Occupancy\"] = [0.0]\n        self.df_trial_results[\"Number of Admission Delays\"] = [0.0]\n        self.df_trial_results[\"Mean Length of Stay Ward (Hours)\"] = [0.0]\n        self.df_trial_results[\"Financial Savings of Admissions Avoidance (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"SDEC Medical Staff Cost (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"SDEC Savings (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"Thrombolysis Savings (\u00a3)\"] = [0.0]\n        self.df_trial_results[\"Total Savings\"] = [0.0]\n        self.df_trial_results[\"Mean MRS Change\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.graph_objects = []\n        self.model_objects = []\n        # self.patient_objects = {}\n        self.trial_patient_dataframes = []\n        self.trial_patient_df = pd.DataFrame()\n\n    # MARK: M: run_trial\n    # Method to run a trial\n    def run_trial(self):\n        \"\"\"\n        Executes the batch of simulation runs and aggregates the resulting data.\n\n        This method performs the following steps:\n\n        1. Loops through the number of runs specified in `g.number_of_runs`.\n\n        2. Instantiates and executes a `Model` for each run.\n\n        3. Collects summary metrics (e.g., queue times, savings) into `df_trial_results`.\n\n        4. Flattens patient-level data into a single master DataFrame.\n\n        5. Calculates trial-level means and updates the global `g` class attributes.\n\n        6. Optionally exports results to a CSV file if `g.write_to_csv` is True.\n\n        This method dynamically updates the global configuration class `g` by\n        calculating the mean of results across all runs and storing them in\n        dictionaries keyed by the trial counter.\n\n        See Also\n        --------\n        Model.run : The method called to execute an individual simulation iteration.\n\n        Notes\n        -----\n        GENAI declaration (SR): this docstring has been generated with the aid\n        of Google Gemini Flash.\n        All generated content has been thoroughly reviewed.\n        \"\"\"\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results\n        # and store it against the run number in the trial results dataframe.\n\n        for run in range(g.number_of_runs):\n            my_model = Model(run)\n            my_model.run()\n\n            self.model_objects.append(my_model)\n\n            self.df_trial_results.loc[run] = [\n                my_model.mean_q_time_nurse,\n                my_model.number_of_admissions_avoided,\n                my_model.mean_q_time_ward,\n                my_model.mean_ward_occupancy,\n                my_model.admission_delays,\n                my_model.mean_los_ward,\n                my_model.sdec_financial_savings,\n                my_model.medical_staff_cost,\n                my_model.savings_sdec,\n                my_model.thrombolysis_savings,\n                my_model.total_savings,\n                my_model.mean_mrs_change,\n            ]\n\n            # self.patient_objects[run] = my_model.patient_objects\n            patient_dataframe = pd.DataFrame(\n                [p.__dict__ for p in my_model.patient_objects]\n            )\n            patient_dataframe[\"run\"] = run + 1\n            self.trial_patient_dataframes.append(patient_dataframe)\n\n        self.trial_patient_df = pd.concat(self.trial_patient_dataframes)\n\n        if g.write_to_csv == True:\n            self.df_trial_results.to_csv(\n                f\"trial {g.trials_run_counter} trial results.csv\", index=False\n            )\n\n        # TODO: SR: FIX appending of per-run graphs to trial class\n        # if g.gen_graph:\n        #     self.graph_objects.append(my_model.plot_stroke_run_graphs(plot=False))\n\n        # This is new code that will store all averages to compare across\n        # the different trials. It does this by checking if the attribute\n        # exists in the global g class, and if it doesn't it creates it. It\n        # then stores the mean of each run against the attribute\n        # (eg \"trial_mean_q_time_nurse\")\n\n        # The mean is stored against the key of g.trials_run_counter.\n\n        for attr, col in [\n            (\"trial_mean_q_time_nurse\", \"Mean Q Time Nurse (Mins)\"),\n            (\n                \"trial_number_of_admissions_avoided\",\n                \"Number of Admissions Avoided In Run\",\n            ),\n            (\"trial_mean_q_time_ward\", \"Mean Q Time Ward (Hour)\"),\n            (\"trial_mean_occupancy\", \"Mean Occupancy\"),\n            (\"trial_number_of_admission_delays\", \"Number of Admission Delays\"),\n            (\n                \"trial_financial_savings_of_a_a\",\n                \"Financial Savings of Admissions Avoidance (\u00a3)\",\n            ),\n            (\"sdec_medical_cost\", \"SDEC Medical Staff Cost (\u00a3)\"),\n            (\"trial_sdec_financial_savings\", \"SDEC Savings (\u00a3)\"),\n            (\"trial_thrombolysis_savings\", \"Thrombolysis Savings (\u00a3)\"),\n            (\"trial_total_savings\", \"Total Savings\"),\n            (\"trial_mrs_change\", \"Mean MRS Change\"),\n        ]:\n            # Checks to see if the attribute already exists and if it doesn't\n            # create it. Creates a mean of each trial and creates a dictionary\n            # that can be read later.\n\n            if not hasattr(g, attr):\n                setattr(g, attr, {})\n            getattr(g, attr)[g.trials_run_counter] = round(\n                self.df_trial_results[col].mean(), 2\n            )\n\n        # Code to store the configuration that was used for this trial.\n        self.trial_info = (\n            f\"Trial {g.trials_run_counter}, SDEC Therapy = {g.therapy_sdec},\"\n            f\" SDEC Open % = {g.sdec_value}, CTP Open % = {g.ctp_value}\"\n        )\n\n        print(\"---------------------------------------------------\")\n        print(f\"{self.trial_info}\")\n        print(f\"Trial {g.trials_run_counter} Results:\")\n        print(\" \")\n        print(\n            f\"Trial Mean Q Time Nurse (Mins):     \\\n              {g.trial_mean_q_time_nurse[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Number of Admissions Avoided: \\\n              {g.trial_number_of_admissions_avoided[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Mean Q Time Ward (Hours):     \\\n              {g.trial_mean_q_time_ward[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Mean Ward Occupancy:          \\\n              {g.trial_mean_occupancy[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Number of Admission Delays:   \\\n              {g.trial_number_of_admission_delays[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial SDEC Total Savings (\u00a3):       \\\n              {g.trial_financial_savings_of_a_a[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial SDEC Medical Cost (\u00a3):        \\\n              {g.sdec_medical_cost[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial SDEC Savings - Cost (\u00a3):      \\\n              {g.trial_sdec_financial_savings[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Thrombolysis Savings (\u00a3):     \\\n              {g.trial_thrombolysis_savings[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Trial Total Savings (\u00a3):            \\\n              {g.trial_total_savings[g.trials_run_counter]}\"\n        )\n        print(\n            f\"Mean MRS Change:                    \\\n              {g.trial_mrs_change[g.trials_run_counter]}\"\n        )\n</code></pre>"},{"location":"trial/#stroke_ward_model.stroke_admission_classes.Trial.run_trial","title":"<code>run_trial()</code>","text":"<p>Executes the batch of simulation runs and aggregates the resulting data.</p> <p>This method performs the following steps:</p> <ol> <li> <p>Loops through the number of runs specified in <code>g.number_of_runs</code>.</p> </li> <li> <p>Instantiates and executes a <code>Model</code> for each run.</p> </li> <li> <p>Collects summary metrics (e.g., queue times, savings) into <code>df_trial_results</code>.</p> </li> <li> <p>Flattens patient-level data into a single master DataFrame.</p> </li> <li> <p>Calculates trial-level means and updates the global <code>g</code> class attributes.</p> </li> <li> <p>Optionally exports results to a CSV file if <code>g.write_to_csv</code> is True.</p> </li> </ol> <p>This method dynamically updates the global configuration class <code>g</code> by calculating the mean of results across all runs and storing them in dictionaries keyed by the trial counter.</p> See Also <p>Model.run : The method called to execute an individual simulation iteration.</p> Notes <p>GENAI declaration (SR): this docstring has been generated with the aid of Google Gemini Flash. All generated content has been thoroughly reviewed.</p> Source code in <code>src\\stroke_ward_model\\stroke_admission_classes.py</code> <pre><code>def run_trial(self):\n    \"\"\"\n    Executes the batch of simulation runs and aggregates the resulting data.\n\n    This method performs the following steps:\n\n    1. Loops through the number of runs specified in `g.number_of_runs`.\n\n    2. Instantiates and executes a `Model` for each run.\n\n    3. Collects summary metrics (e.g., queue times, savings) into `df_trial_results`.\n\n    4. Flattens patient-level data into a single master DataFrame.\n\n    5. Calculates trial-level means and updates the global `g` class attributes.\n\n    6. Optionally exports results to a CSV file if `g.write_to_csv` is True.\n\n    This method dynamically updates the global configuration class `g` by\n    calculating the mean of results across all runs and storing them in\n    dictionaries keyed by the trial counter.\n\n    See Also\n    --------\n    Model.run : The method called to execute an individual simulation iteration.\n\n    Notes\n    -----\n    GENAI declaration (SR): this docstring has been generated with the aid\n    of Google Gemini Flash.\n    All generated content has been thoroughly reviewed.\n    \"\"\"\n    # Run the simulation for the number of runs specified in g class.\n    # For each run, we create a new instance of the Model class and call its\n    # run method, which sets everything else in motion.  Once the run has\n    # completed, we grab out the stored run results\n    # and store it against the run number in the trial results dataframe.\n\n    for run in range(g.number_of_runs):\n        my_model = Model(run)\n        my_model.run()\n\n        self.model_objects.append(my_model)\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_nurse,\n            my_model.number_of_admissions_avoided,\n            my_model.mean_q_time_ward,\n            my_model.mean_ward_occupancy,\n            my_model.admission_delays,\n            my_model.mean_los_ward,\n            my_model.sdec_financial_savings,\n            my_model.medical_staff_cost,\n            my_model.savings_sdec,\n            my_model.thrombolysis_savings,\n            my_model.total_savings,\n            my_model.mean_mrs_change,\n        ]\n\n        # self.patient_objects[run] = my_model.patient_objects\n        patient_dataframe = pd.DataFrame(\n            [p.__dict__ for p in my_model.patient_objects]\n        )\n        patient_dataframe[\"run\"] = run + 1\n        self.trial_patient_dataframes.append(patient_dataframe)\n\n    self.trial_patient_df = pd.concat(self.trial_patient_dataframes)\n\n    if g.write_to_csv == True:\n        self.df_trial_results.to_csv(\n            f\"trial {g.trials_run_counter} trial results.csv\", index=False\n        )\n\n    # TODO: SR: FIX appending of per-run graphs to trial class\n    # if g.gen_graph:\n    #     self.graph_objects.append(my_model.plot_stroke_run_graphs(plot=False))\n\n    # This is new code that will store all averages to compare across\n    # the different trials. It does this by checking if the attribute\n    # exists in the global g class, and if it doesn't it creates it. It\n    # then stores the mean of each run against the attribute\n    # (eg \"trial_mean_q_time_nurse\")\n\n    # The mean is stored against the key of g.trials_run_counter.\n\n    for attr, col in [\n        (\"trial_mean_q_time_nurse\", \"Mean Q Time Nurse (Mins)\"),\n        (\n            \"trial_number_of_admissions_avoided\",\n            \"Number of Admissions Avoided In Run\",\n        ),\n        (\"trial_mean_q_time_ward\", \"Mean Q Time Ward (Hour)\"),\n        (\"trial_mean_occupancy\", \"Mean Occupancy\"),\n        (\"trial_number_of_admission_delays\", \"Number of Admission Delays\"),\n        (\n            \"trial_financial_savings_of_a_a\",\n            \"Financial Savings of Admissions Avoidance (\u00a3)\",\n        ),\n        (\"sdec_medical_cost\", \"SDEC Medical Staff Cost (\u00a3)\"),\n        (\"trial_sdec_financial_savings\", \"SDEC Savings (\u00a3)\"),\n        (\"trial_thrombolysis_savings\", \"Thrombolysis Savings (\u00a3)\"),\n        (\"trial_total_savings\", \"Total Savings\"),\n        (\"trial_mrs_change\", \"Mean MRS Change\"),\n    ]:\n        # Checks to see if the attribute already exists and if it doesn't\n        # create it. Creates a mean of each trial and creates a dictionary\n        # that can be read later.\n\n        if not hasattr(g, attr):\n            setattr(g, attr, {})\n        getattr(g, attr)[g.trials_run_counter] = round(\n            self.df_trial_results[col].mean(), 2\n        )\n\n    # Code to store the configuration that was used for this trial.\n    self.trial_info = (\n        f\"Trial {g.trials_run_counter}, SDEC Therapy = {g.therapy_sdec},\"\n        f\" SDEC Open % = {g.sdec_value}, CTP Open % = {g.ctp_value}\"\n    )\n\n    print(\"---------------------------------------------------\")\n    print(f\"{self.trial_info}\")\n    print(f\"Trial {g.trials_run_counter} Results:\")\n    print(\" \")\n    print(\n        f\"Trial Mean Q Time Nurse (Mins):     \\\n          {g.trial_mean_q_time_nurse[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Number of Admissions Avoided: \\\n          {g.trial_number_of_admissions_avoided[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Mean Q Time Ward (Hours):     \\\n          {g.trial_mean_q_time_ward[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Mean Ward Occupancy:          \\\n          {g.trial_mean_occupancy[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Number of Admission Delays:   \\\n          {g.trial_number_of_admission_delays[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial SDEC Total Savings (\u00a3):       \\\n          {g.trial_financial_savings_of_a_a[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial SDEC Medical Cost (\u00a3):        \\\n          {g.sdec_medical_cost[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial SDEC Savings - Cost (\u00a3):      \\\n          {g.trial_sdec_financial_savings[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Thrombolysis Savings (\u00a3):     \\\n          {g.trial_thrombolysis_savings[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Trial Total Savings (\u00a3):            \\\n          {g.trial_total_savings[g.trials_run_counter]}\"\n    )\n    print(\n        f\"Mean MRS Change:                    \\\n          {g.trial_mrs_change[g.trials_run_counter]}\"\n    )\n</code></pre>"}]}